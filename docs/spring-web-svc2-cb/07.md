# 七、使用 XWSS 库保护 SOAP Web 服务

在本章中，我们将介绍：

*   使用用户名令牌和普通/摘要密码验证 Web 服务调用
*   使用 Spring security 对 Web 服务调用进行身份验证，以使用普通/摘要密码对用户名令牌进行身份验证
*   使用 JAAS 服务验证用户名令牌来验证 Web 服务调用
*   准备成对和对称密钥存储库
*   使用数字签名保护 SOAP 消息
*   使用 X509 证书验证 Web 服务调用
*   加密/解密 SOAP 消息

# 导言

WS-Security（WSS），由 OASIS 发布，是 SOAP 的扩展，为 Web 服务提供安全标准特性。XML 和 Web 服务安全性（XWSS）是 SUN 对 WSS 的实现，它包含在 Java Web 服务开发包（WSDP）中。

XWSS 是消息级安全的一种形式，其中安全数据包含在 SOAP 消息/附件中，并允许安全信息与消息或附件一起传输。例如，在对消息进行签名时，安全令牌将添加到消息中，该消息是通过对特定接收方的消息的一部分进行加密而生成的。当发送者发送此消息时，此令牌保持加密形式，并随消息一起移动。当接收者收到此消息时，只有当他/她拥有用于解密的特定密钥时，才能解密令牌。因此，如果在该消息的传输过程中，任何未经授权的接收者（没有特定密钥）获得该消息，则他/她无法解密该令牌（该令牌将用于检查原始消息是否被更改）。消息验证的原创性可以通过在接收方端重新生成令牌（来自传入消息）并将其与消息附带的传入令牌进行比较来完成。

顾名思义， `EndpointInterceptor`截取请求并在调用端点之前执行一些操作。在调用适当的端点以执行多个处理方面（如日志记录、验证、安全性等）之前调用 `EndpointInterceptors`。在前面的章节中， `SoapEnvelopeLoggingInterceptor, PayloadLoggingInterceptor`和 `PayloadValidatingInterceptor`是为了记录和验证而解释的。

在本章和下一章中，将对 `SecurityInterceptors`进行解释。

Spring WS `XwsSecurityInterceptor`是一个 `EndpointInterceptor`，用于在调用端点之前对请求消息执行安全操作。此拦截器基于 XWSS，需要策略配置文件才能运行。以下是策略配置文件的示例，其中可能包括几个安全要求：

```java
<xwss:SecurityConfiguration ...>
<xwss:RequireTimestamp .../>
<xwss:RequireUsernameToken ...../>
........
</xwss:SecurityConfiguration>

```

安全拦截器使用此配置来查找从传入的 SOAP 消息（在接收方）预期的安全信息，以及要添加到传出消息（在发送方）的信息。

此外，此拦截器需要一个或多个 `callBackHandlers`来执行安全操作，如身份验证、对传出消息进行签名、验证传入消息的签名、解密和加密。这些 `callBackHandlers`需要在应用程序上下文文件中注册

```java
<sws:interceptors>
<bean
class="...XwsSecurityInterceptor">
<property name="policyConfiguration" value="/WEB-INF/securityPolicy.xml" />
<property name="policyConfiguration" value="/WEB-INF/securityPolicy.xml" />
<property name="callbackHandlers">
<list>
<ref bean="callbackHandler1" />
<ref bean="callbackHandler2" />
..............
</list>
</property>
</bean>
</sws:interceptors>
<bean id="callbackHandler1"
class=".....SimplePasswordValidationCallbackHandler">
<property name="users">
<props>
<prop key="admin">secret</prop>
<prop key="clinetUser">pass</prop>
</props>
</property>
</bean>
.........

```

本章介绍如何将 SpringWSXWSS 应用于不同的安全操作。在每个配方的项目中，客户端通过在传出消息中添加或修改数据来应用安全操作，并将其发送到服务器。服务器接收消息，提取安全信息，如果安全信息符合预期要求，则继续处理该消息；否则返回*故障*消息给客户端。

为了简化，本章中的大多数配方使用[第 3 章](03.html "Chapter 3. Testing and Monitoring Web-Services")、*测试和监控 Web 服务*中讨论的*使用 Spring JUnit 支持的集成测试*配方中使用的项目来设置服务器并通过客户端发送和接收消息。然而，在上一个配方中，服务器端和客户端使用了[第 2 章](02.html "Chapter 2. Building Clients for SOAP Web-Services")*为 WS-Addressing endpoint*配方中*创建 Web 服务客户端*的项目。

# 使用普通/摘要用户名令牌验证 Web 服务调用

身份验证仅仅意味着检查服务的呼叫者是否是他们声称的人。检查调用方身份验证的一种方法是检查密码。

XWSS 提供 API，从传入的 SOAP 消息中获取用户名和密码，并将它们与配置文件中定义的内容进行比较。这一目标将通过为消息的发送方和接收方定义策略文件来实现，在发送方端，客户端在传出消息中包含用户名令牌，在接收方端，服务器期望接收此用户名令牌以及传入消息以进行身份验证。

传输普通密码会使 SOAP 消息不安全。XWSS 在策略文件中提供配置设置，以便在发送方消息中包含密码摘要（由特定算法从密码文本生成的哈希）。在服务器端，服务器将传入消息中包含的摘要密码与根据配置文件中设置的内容计算的摘要密码进行比较（请参见 `spring-ws-servlet.xml)`中 `callbackHandler`bean 中的属性用户）在发送方端使用相同的算法。此配方显示如何使用用户名令牌和普通/摘要密码对 Web 服务调用进行身份验证。此配方包含两种情况。在第一种情况下，密码将以纯文本格式传输。但是，在第二种情况下，通过更改策略文件配置，password 将以摘要格式传输。

## 准备好了吗

在此配方中，项目名称为 `LiveRestaurant_R-7.1`（用于服务器端 Web 服务），并且具有以下 Maven 依赖项：

*   `spring-ws-security-2.0.1.RELEASE.jar`
*   `spring-expression-3.0.5.RELEASE.jar`
*   `log4j-1.2.9.jar`

`LiveRestaurant_R-7.1-Client`（用于客户端 Web 服务）具有以下 Maven 依赖项：

*   `spring-ws-security-2.0.1.RELEASE.jar`
*   `spring-ws-test-2.0.0.RELEASE.jar`
*   `spring-expression-3.0.5.RELEASE.jar`
*   `log4j-1.2.9.jar`
*   `junit-4.7.jar`

## 怎么做。。。

以下步骤使用带有普通密码的用户名令牌实现身份验证：

1.  在 `LiveRestaurant_R-7.1-Client`的应用上下文文件`applicationContext.xml`中注册安全拦截器（`XwsSecurityInterceptor`）和 `callbackHandler`（`SimplePasswordValidationCallbackHandler`）。
2.  为 `LiveRestaurant_R-7.1-Client`添加安全策略文件（`securityPolicy.xml`。
3.  在 `LiveRestaurant_R-7.1`的应用上下文文件`spring-ws-servlet.xml`中注册安全拦截器（`XwsSecurityInterceptor`）和 `callbackHandler`（`SimplePasswordValidationCallbackHandler`）。
4.  为 `LiveRestaurant_R-7.1`添加安全策略文件（`securityPolicy.xml`。
5.  从 `Liverestaurant_R-7.1:`

    ```java
    mvn clean package tomcat:run 

    ```

    运行以下命令
6.  从 `Liverestaurant_R-7.1-Client:`运行以下命令

```java
mvn clean package 

```

*   以下是带下划线部分内的客户端输出（注意密码标签`wsse:Password ...#PasswordText`：

```java
INFO: ==== Sending Message Start ====
<SOAP-ENV:Envelope ...">
<SOAP-ENV:Header>
<wsse:Security ..>
<wsu:Timestamp ...>
<wsu:Created>2011-11-06T07:19:16.225Z</wsu:Created>
<wsu:Expires>2011-11-06T07:24:16.225Z</wsu:Expires>
</wsu:Timestamp>
<wsse:UsernameToken .....>
<wsse:Username>clinetUser</wsse:Username>
<wsse:Password ...#PasswordText">****</wsse:Password>
<wsse:Nonce ..#Base64Binary">...</wsse:Nonce>
<wsu:Created>2011-11-06T07:19:16.272Z</wsu:Created>
</wsse:UsernameToken>
</wsse:Security>
</SOAP-ENV:Header>
<SOAP-ENV:Body>
<tns:placeOrderRequest xmlns:tns="...">
.....
.......
</tns:placeOrderRequest>
</SOAP-ENV:Body>
</SOAP-ENV:Envelope>
==== Sending Message End ====
.....
INFO: ==== Received Message Start ====
......
<SOAP-ENV:Envelope....">
<SOAP-ENV:Header/>
<SOAP-ENV:Body>
<tns:placeOrderResponse .....>
<tns:refNumber>order-John_Smith_1234</tns:refNumber>
</tns:placeOrderResponse>
</SOAP-ENV:Body>
</SOAP-ENV:Envelope>
==== Received Message End ==== 

```

以下步骤使用用户名令牌和摘要密码实现身份验证：

1.  修改 `Liverestaurant_R-7.1`的安全策略文件`securityPolicy.xml`，从传入消息中获取摘要密码。
2.  修改 `Liverestaurant_R-7.1-Client`的安全策略文件`securityPolicy.xml`发送摘要密码。
3.  从 `Liverestaurant_R-7.1:`

    ```java
    mvn clean package tomcat:run 

    ```

    运行以下命令
4.  从 `Liverestaurant_R-7.1-Client:`运行以下命令

```java
mvn clean package 

```

*   以下是带下划线部分中的客户端输出（注意密码的标记 wsse:password…#PasswordDigest）：

```java
Nov 6, 2011 12:19:25 PM com.sun.xml.wss.impl.filter.DumpFilter process
INFO: ==== Sending Message Start ====
..
<SOAP-ENV:Envelope .../">
<SOAP-ENV:Header>
<wsse:Security ...>
<wsu:Timestamp ..>
<wsu:Created>2011-11-06T08:19:25.515Z</wsu:Created>
<wsu:Expires>2011-11-06T08:24:25.515Z</wsu:Expires>
</wsu:Timestamp>
<wsse:UsernameToken...>
<wsse:Username>clinetUser</wsse:Username>
<wsse:Password ...#PasswordDigest">****</wsse:Password>
<wsse:Nonce ...#Base64Binary">...</wsse:Nonce>
<wsu:Created>2011-11-06T08:19:25.562Z</wsu:Created>
</wsse:UsernameToken>
</wsse:Security>
</SOAP-ENV:Header>
<SOAP-ENV:Body>
<tns:placeOrderRequest..">
......
</tns:placeOrderRequest>
</SOAP-ENV:Body>
</SOAP-ENV:Envelope>
==== Sending Message End ====
........
INFO: ==== Received Message Start ====
<?xml version="1.0" ...>
<SOAP-ENV:Header/>
<SOAP-ENV:Body>
<tns:placeOrderResponse ...>
<tns:refNumber>order-John_Smith_1234</tns:refNumber>
</tns:placeOrderResponse>
</SOAP-ENV:Body>
</SOAP-ENV:Envelope>
==== Received Message End ==== 

```

## 它是如何工作的。。。

`Liverestaurant_R-7.1`项目是一个服务器端 Web 服务，它要求其客户端发送一条消息以及用户名令牌和密码。 `Liverestaurant_R-7.1-Client`项目是一个客户端测试项目，它向服务器发送一条消息以及用户名令牌和密码。

在服务器端， `XwsSecurityInterceptor`强制服务器将 `securityPolicy.xml`中的策略应用于所有传入消息，并使用 `SimplePasswordValidationCallbackHandler`将传入消息用户名/密码与服务器配置文件中包含的用户名/密码进行比较（请参见 `callbackHandler`bean 中的属性用户）：

```java
<sws:interceptors>
...
<bean class="org.springframework.ws.soap.security.xwss.XwsSecurityInterceptor">
<property name="policyConfiguration" value="/WEB-INF/securityPolicy.xml" />
<property name="callbackHandlers">
<list>
<ref bean="callbackHandler" />
</list>
</property>
</bean>
</sws:interceptors>
<bean id="callbackHandler"
class="org.springframework.ws.soap.security.xwss.callback.SimplePasswordValidationCallbackHandler">
<property name="users">
<props>
<prop key="admin">secret</prop>
<prop key="clinetUser">pass</prop>
</props>
</property> 
</bean>

```

在 `securityPolicy.xml`文件中，`<xwss:RequireUsernameToken passwordDigestRequired="false" nonceRequired="true"/>`要求传入消息具有带有未加密密码的用户名令牌。 `useNonce="true`“表示每个传入消息将有一个随机数，该随机数不等于前一条消息：

```java
<xwss:SecurityConfiguration dumpMessages="true" xmlns:xwss="http://java.sun.com/xml/ns/xwss/config">
<xwss:RequireTimestamp maxClockSkew="60" timestampFreshnessLimit="300"/>
<xwss:RequireUsernameToken passwordDigestRequired="false" nonceRequired="true"/>
</xwss:SecurityConfiguration>

```

在客户端， `XwsSecurityInterceptor`强制客户端对所有传出消息应用 `securityPolicy.xml`中的策略：

```java
<bean id="webServiceTemplate" class="org.springframework.ws.client.core.WebServiceTemplate">
....
<property name="interceptors">
<list>
<ref local="xwsSecurityInterceptor" />
</list>
</property>
</bean>
<bean id="xwsSecurityInterceptor"
class="org.springframework.ws.soap.security.xwss.XwsSecurityInterceptor">
<property name="policyConfiguration" value="/securityPolicy.xml"/>
<property name="callbackHandlers">
<list>
<ref bean="callbackHandler"/>
</list>
</property>
</bean>
<bean id="callbackHandler" class="org.springframework.ws.soap.security.xwss.callback.SimplePasswordValidationCallbackHandler"/>

```

在 `securityPolicy.xml`文件中，`<xwss:UsernameToken name="clinetUser" password="pass" digestPassword="false" useNonce="true"/>`包含用户名令牌和所有传出消息的密码：

```java
<xwss:SecurityConfiguration dumpMessages="true" xmlns:xwss="http://java.sun.com/xml/ns/xwss/config">
<xwss:Timestamp />
<xwss:UsernameToken name="clinetUser" password="pass" digestPassword="false" useNonce="true"/> ...
</xwss:SecurityConfiguration>

```

这里， `useNonce="true`表示每个请求都将被发送，每个消息都有一个新的随机数（`Nonce`有助于防止用户名令牌被劫持）。

在使用带有普通密码的用户名令牌进行身份验证的情况下，由于 `digestPassword="false`同时位于客户端和服务器端策略文件中，您可以在输出结果中看到，客户端发送的消息在用户名令牌中包含用户名和纯文本密码：

```java
<wsse:UsernameToken ....>
<wsse:Username>clinetUser</wsse:Username>
<wsse:Password ..>****</wsse:Password>
...
</wsse:UsernameToken> 

```

但是，在使用摘要用户名令牌和摘要密码进行身份验证的第二种情况下，由于 `digestPassword="true`同时位于客户端和服务器端策略文件中，因此用户名令牌中包含密码摘要：

```java
<wsse:UsernameToken ....>
<wsse:Username>clinetUser</wsse:Username>
<wsse:Password ...#PasswordDigest">****</wsse:Password>
...
</wsse:UsernameToken> 

```

在这种情况下，服务器将传入的 SOAP 消息摘要密码与从 `spring-ws-servlet.xml`内部计算的摘要密码进行比较。通过这种方式，与第一种以纯文本传输密码的情况相比，通信将更加安全（纯文本密码可以很容易地从 SOAP 消息中提取。但是，使用 SSL 连接可以保护此类通信）。

## 另见。。。

本章讨论了使用 Spring security 对 Web 服务调用进行身份验证的方法*使用普通/摘要密码对用户名令牌进行身份验证，使用 JAAS 服务对 Web 服务调用进行身份验证的方法*，以及使用 X509 证书对 Web 服务调用进行身份验证的方法*。*

# 使用 Spring security 对 Web 服务调用进行身份验证，以使用普通/摘要密码对用户名令牌进行身份验证

在这里，我们使用第一个配方中使用的相同身份验证方法。这里唯一的区别是 Spring 安全框架用于身份验证。因为 Spring 安全框架超出了本书的范围，所以这里不进行描述。但是，您可以在 Spring 安全参考文档（[中了解更多信息 http://www.springsource.org/security](http://www.springsource.org/security) ）。

与本章第一个配方相同，本配方也包含两个案例。在第一种情况下，密码将以纯文本格式传输。在第二种情况下，通过更改策略文件的配置，密码将以摘要格式传输。

## 准备好了吗

在此配方中，项目名称为 `LiveRestaurant_R-7.2`（用于服务器端 Web 服务），并具有以下 Maven 依赖项：

*   `spring-ws-security-2.0.1.RELEASE.jar`
*   `spring-expression-3.0.5.RELEASE.jar`
*   `log4j-1.2.9.jar`

`LiveRestaurant_R-7.2-Client`（用于客户端 Web 服务）具有以下 Maven 依赖项：

*   `spring-ws-security-2.0.1.RELEASE.jar`
*   `spring-ws-test-2.0.0.RELEASE.jar`
*   `spring-expression-3.0.5.RELEASE.jar`
*   `log4j-1.2.9.jar`
*   `junit-4.7.jar`

## 怎么做。。。

在此配方中，除了服务器端应用程序上下文文件（`spring-ws.servlet.xml`回调处理程序更改并使用 DAO 层获取数据外，所有步骤都与上一配方相同，*使用用户名令牌和普通/摘要密码*对 Web 服务调用进行身份验证：

以下步骤使用 Spring Security 实现 Web 服务调用的身份验证，以使用普通密码验证用户名令牌：

1.  在 `LiveRestaurant_R-7.2`的应用上下文文件`spring-ws-servlet.xml`中注册安全拦截器（`XwsSecurityInterceptor`）和 `callbackHandler`（`SpringPlainTextPasswordValidationCallbackHandler`）。
2.  添加 DAO 层类以获取数据。
3.  从 `Liverestaurant_R-7.2:`

    ```java
    mvn clean package tomcat:run 

    ```

    运行以下命令
4.  从 `Liverestaurant_R-7.2-Client:`运行以下命令

```java
mvn clean package 

```

*   以下是客户端输出：

```java
Nov 6, 2011 1:42:37 PM com.sun.xml.wss.impl.filter.DumpFilter process
INFO: ==== Sending Message Start ====
...
<SOAP-ENV:Envelope ....>
<SOAP-ENV:Header>
<wsse:Security ...>
<wsu:Timestamp....>
<wsu:Created>2011-11-06T09:42:37.391Z</wsu:Created>
<wsu:Expires>2011-11-06T09:47:37.391Z</wsu:Expires>
</wsu:Timestamp>
<wsse:UsernameToken ...>
<wsse:Username>clinetUser</wsse:Username>
<wsse:Password ...#PasswordText">****</wsse:Password>
<wsse:Nonce ...#Base64Binary">...</wsse:Nonce>
<wsu:Created>2011-11-06T09:42:37.442Z</wsu:Created>
</wsse:UsernameToken>
</wsse:Security>
</SOAP-ENV:Header>
<SOAP-ENV:Body>
<tns:placeOrderRequest ...>
......
</tns:placeOrderRequest>
</SOAP-ENV:Body>
</SOAP-ENV:Envelope>
==== Sending Message End ====
INFO: ==== Received Message Start ====
<SOAP-ENV:Envelope ...">
<SOAP-ENV:Header/>
<SOAP-ENV:Body>
<tns:placeOrderResponse ....">
<tns:refNumber>order-John_Smith_1234</tns:refNumber>
</tns:placeOrderResponse>
</SOAP-ENV:Body>
</SOAP-ENV:Envelope>
==== Received Message End ==== 

```

以下步骤使用 Spring Security 来验证摘要用户名令牌，从而实现 Web 服务调用的身份验证：

1.  将服务器应用程序上下文文件（`spring-ws-servlet.xml`中的 `springSecurityHandler`修改为 `SpringDigestPasswordValidationCallbackHandler`。
2.  修改服务器端和客户端的安全策略文件（`securityPolicy.xml`）以消化密码。
3.  从 `Liverestaurant_R-7.2:`

    ```java
    mvn clean package tomcat:run 

    ```

    运行以下命令
4.  从 `Liverestaurant_R-7.2-Client:`运行以下命令

```java
mvn clean package 

```

*   以下是客户端输出：

```java
Nov 6, 2011 2:04:37 PM com.sun.xml.wss.impl.filter.DumpFilter process
INFO: ==== Sending Message Start ====
...
<SOAP-ENV:Envelope ...>
<SOAP-ENV:Header>
<wsse:Security ...>
<wsu:Timestamp ...>
<wsu:Created>2011-11-06T10:04:36.622Z</wsu:Created>
<wsu:Expires>2011-11-06T10:09:36.622Z</wsu:Expires>
</wsu:Timestamp>
<wsse:UsernameToken...>
<wsse:Username>clinetUser</wsse:Username>
<wsse:Password #PasswordDigest">****</wsse:Password>
<wsse:Nonce #Base64Binary">...</wsse:Nonce>
<wsu:Created>2011-11-06T10:04:36.683Z</wsu:Created>
</wsse:UsernameToken>
</wsse:Security>
</SOAP-ENV:Header>
<SOAP-ENV:Body>
<tns:placeOrderRequest xmlns:tns="http://www.packtpub.com/liverestaurant/OrderService/schema">
......
</tns:placeOrderRequest>
</SOAP-ENV:Body>
</SOAP-ENV:Envelope>
==== Sending Message End ====
Nov 6, 2011 2:04:37 PM com.sun.xml.wss.impl.filter.DumpFilter process
INFO: ==== Received Message Start ====
<?xml version="1.0" encoding="UTF-8"?><SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/">
<SOAP-ENV:Header/>
<SOAP-ENV:Body>
<tns:placeOrderResponse...">
<tns:refNumber>order-John_Smith_1234</tns:refNumber>
</tns:placeOrderResponse>
</SOAP-ENV:Body>
</SOAP-ENV:Envelope>
==== Received Message End ==== 

```

## 它是如何工作的。。。

在 `Liverestaurant_R-7.2`项目中，客户端和服务器的安全性的各个方面几乎与我们在*配方中使用的 `Liverestaurant_R-7.1`相同，即使用用户名和普通/摘要密码令牌*来验证 Web 服务调用，除了验证服务器端的用户。Spring 安全类负责通过使用从 DAO 层获取的数据与传入消息的用户名/密码进行比较来验证用户和密码（而不是在 `spring-ws-servlet.xml)`中硬编码用户名/密码。此外，与成功验证的用户相关的其他数据（如 `permissions, isAccountBlocked, isAccountExpired`等）（与用户名和密码匹配）可以从 DAO 层获取并返回，用于授权任务或验证帐户的到期日期，并检查帐户是否被阻止。

在第一种情况下， `CallbackHandler SpringPlainTextPasswordValidationCallbackHandler`将传入 SOAP 消息中包含的普通密码与从 DAO 层获取的普通密码进行比较。

```java
<sws:interceptors>
<bean
....
<bean class="org.springframework.ws.soap.security.xwss.XwsSecurityInterceptor">
<property name="policyConfiguration" value="/WEB-INF/securityPolicy.xml"/>
<property name="callbackHandlers">
<list>
<ref bean="springSecurityHandler"/>
</list>
</property>
</bean>
</sws:interceptors>
<bean id="springSecurityHandler"
class="org.springframework.ws.soap.security.xwss.callback.SpringPlainTextPasswordValidationCallbackHandler">
<property name="authenticationManager" ref="authenticationManager"/>
</bean>
....

```

然而，在第二个测试中， `CallbackHandler`是 `SpringDigestPasswordValidationCallbackHandler`，它将传入 SOAP 消息中包含的摘要密码与从 DAO 层获取的密码摘要进行比较。

```java
<bean id="springSecurityHandler"
class="org.springframework.ws.soap.security.xwss.callback.SpringDigestPasswordValidationCallbackHandler">
<property name="userDetailsService" ref="userDetailsService"/>
</bean>

```

`springSecurityHandler`使用 `MyUserDetailService.java`，应该实现 Spring 的 `UserDetailService`从提供者获取用户名，并从 DAO 层内部获取该用户的所有信息（例如，密码、角色、过期等）。

```java
public class MyUserDetailService implements UserDetailsService {
@Override
public UserDetails loadUserByUsername(String username)
throws UsernameNotFoundException, DataAccessException {
return getUserDataFromDao(username);
}
private MyUserDetail getUserDataFromDao(String username) {
/**
*Real scenario: find user data from a DAO layer by userName,
* if this user name found, populate MyUserDetail with its data(username, password,Role, ....).
*/
MyUserDetail mydetail=new MyUserDetail(username,"pass",true,true,true,true);
mydetail.getAuthorities().add(new GrantedAuthorityImpl("ROLE_GENERAL_OPERATOR"));
return mydetail;
}

```

此服务最终返回 `MyUserDetails.java`中填充的数据，应该实现 Spring 的 `UserDetails`。

```java
public class MyUserDetail implements UserDetails {
private String password;
private String userName;
private boolean isAccountNonExpired;
private boolean isAccountNonLocked;
private boolean isCredentialsNonExpired;
private boolean isEnabled;
public static Collection<GrantedAuthority> authority =
new ArrayList<GrantedAuthority>();
public MyUserDetail( String userName, String password,boolean isAccountNonExpired, boolean isAccountNonlocked,boolean isCredentialsNonExpired, boolean isEnabled){
this.userName=userName;
this.password=password;
this.isAccountNonExpired=isAccountNonExpired;
this.isAccountNonLocked=isAccountNonlocked;
this.isCredentialsNonExpired=isCredentialsNonExpired;
this.isEnabled=isEnabled;
}
@Override
public Collection<GrantedAuthority> getAuthorities() {
return authority;
}
.....
}

```

现在，如果 `UserDetails`数据与传入消息的用户名/密码匹配，则返回响应；否则，它将返回一条 SOAP 错误消息。

与 7.1 项目相同，在服务器/客户端的 `securityPolicy.xml`中将 `digestPassword`设置为 `true/false`会导致密码以明文或摘要格式传输。

### 提示

在实时中，我们从不配置普通密码选项。这是黑客启用和禁用的一个好选项。我们永远不需要这样一个实时选项。密码始终以加密格式传输，而与任何类型的系统或应用程序配置无关。

## 另见。。。

本章讨论了使用 Spring security 对 Web 服务调用进行身份验证的方法*使用普通/摘要密码对用户名令牌进行身份验证，使用 JAAS 服务对 Web 服务调用进行身份验证的方法*，以及使用 X509 证书对 Web 服务调用进行身份验证的方法*。*

# 使用 JAAS 服务验证用户名令牌来验证 Web 服务调用

我们使用与第一个配方中使用的相同的身份验证任务和普通用户名令牌。这里唯一的区别是 Java 身份验证和授权服务（JAAS）用于身份验证和授权。因为 JAAS 框架超出了本书的范围，所以这里不进行描述。但是，您可以在参考文档（[中阅读有关 JAAS 的更多信息 http://download.oracle.com/javase/6/docs/technotes/guides/security/jaas/JAASRefGuide.html](http://download.oracle.com/javase/6/docs/technotes/guides/security/jaas/JAASRefGuide.html) ）。

`xwss`包中的`JaasPlainTextPasswordValidationCallbackHandler`是调用 JAAS 配置文件中配置的 `Login`模块的 API。

## 准备好了吗

在此配方中，项目名称为 `LiveRestaurant_R-7.3`（用于服务器端 Web 服务），并具有以下 Maven 依赖项：

*   `spring-ws-security-2.0.1.RELEASE.jar`
*   `spring-expression-3.0.5.RELEASE.jar`
*   `log4j-1.2.9.jar`

`LiveRestaurant_R-7.3-Client`（用于客户端 Web 服务）具有以下 Maven 依赖项：

*   `spring-ws-security-2.0.1.RELEASE.jar`
*   `spring-ws-test-2.0.0.RELEASE.jar`
*   `spring-expression-3.0.5.RELEASE.jar`
*   `log4j-1.2.9.jar`
*   `junit-4.7.jar`

## 怎么做。。。

在此配方中，所有步骤都与上一配方相同，*使用用户名令牌和普通/摘要密码*对 Web 服务调用进行身份验证，除了服务器端应用程序上下文文件（`spring-ws.servlet.xml`回调处理程序发生更改并使用 JAAS 框架作为身份验证和授权服务：

1.  在服务器端应用程序上下文文件（`spring-ws.servlet.xml`中注册 JAAS `callbackHandler`（`JaasPlainTextPasswordValidationCallbackHandler`）。
2.  添加 JAAS 框架所需的类`(RdbmsPrincipal, RdbmsCredential`、 `RdbmsPlainTextLoginModule)`和配置文件（`jaas.config`。
3.  从 `Liverestaurant_R-7.3:`

    ```java
    mvn clean package tomcat:run -Djava.security.auth.login.config="src/main/resources/jaas.config" 

    ```

    运行以下命令
4.  从 `Liverestaurant_R-7.3-Client:`运行以下命令

```java
mvn clean package 

```

*   以下是客户端输出：

```java
INFO: ==== Sending Message Start ====
....
<SOAP-ENV:Envelope ....">
<SOAP-ENV:Header>
<wsse:Security ....>
<wsu:Timestamp ...>
<wsu:Created>2011-11-06T11:59:09.712Z</wsu:Created>
<wsu:Expires>2011-11-06T12:04:09.712Z</wsu:Expires>
</wsu:Timestamp>
<wsse:UsernameToken ...>
<wsse:Username>clinetUser</wsse:Username>
<wsse:Password ....#PasswordText">****</wsse:Password>
<wsse:Nonce ...0#Base64Binary">...</wsse:Nonce>
<wsu:Created>2011-11-06T11:59:09.774Z</wsu:Created>
</wsse:UsernameToken>
</wsse:Security>
</SOAP-ENV:Header>
<SOAP-ENV:Body>
<tns:placeOrderRequest...>
.....
</tns:placeOrderRequest>
</SOAP-ENV:Body>
</SOAP-ENV:Envelope>
==== Sending Message End ====
...
INFO: ==== Received Message Start ====
...
<SOAP-ENV:Envelope ...>
<SOAP-ENV:Header>
<wsse:Security ...>
<wsu:Timestamp ....>
<wsu:Created>2011-11-06T11:59:11.630Z</wsu:Created>
<wsu:Expires>2011-11-06T12:04:11.630Z</wsu:Expires>
</wsu:Timestamp>
</wsse:Security>
</SOAP-ENV:Header>
<SOAP-ENV:Body>
<tns:placeOrderResponse ...>
<tns:refNumber>order-John_Smith_1234</tns:refNumber>
</tns:placeOrderResponse>
</SOAP-ENV:Body>
</SOAP-ENV:Envelope>
==== Received Message End ==== 

```

## 它是如何工作的。。。

在 `Liverestaurant_R-7.3`项目中，除了验证服务器端的用户外，客户端和服务器的安全性几乎与我们在*配方中使用的 `Liverestaurant_R-7.1`项目相同，该配方使用带有普通/摘要密码令牌*的用户名验证 Web 服务调用。JAAS 框架负责通过比较传入消息的用户名/密码与从数据源（此处的数据库）获取的数据来验证用户和密码。

客户端发送一条请求 SOAP 消息，该消息包含纯文本形式的用户名令牌。服务器接收此消息并使用 JAAS 框架将传入的消息用户名/密码与 JAAS 从 DAO 层获取的内容进行比较。如果匹配，则返回正常响应；否则，它将返回失败消息。

在 `spring-ws-servlet.xml, JaasPlainTextPasswordValidationCallbackHandler`中注册为回调处理程序，使用 `RdbmsPlainText`作为可插拔 JAAS 登录模块进行用户名/密码验证：

```java
<sws:interceptors>
.......
<bean class="org.springframework.ws.soap.security.xwss.XwsSecurityInterceptor">
<property name="policyConfiguration" value="/WEB-INF/securityPolicy.xml" />
<property name="callbackHandlers">
<list>
<ref bean="jaasValidationHandler" />
</list>
</property>
</bean>
</sws:interceptors>
<bean id="jaasValidationHandler" class="org.springframework.ws.soap.security.xwss.callback.jaas.JaasPlainTextPasswordValidationCallbackHandler">
<property name="loginContextName" value="RdbmsPlainText" />
</bean>

```

当服务器端使用 `mvn -Djava.security.auth.login.config="src/main/resources/jaas.config`运行时，它使用 `jaas.config`文件定位在服务器端应用程序上下文中注册为 `RdbmsPlainText:`的 JAAS 登录模块（`RdbmsPlainTextLoginModule`

```java
RdbmsPlainText {
com.packtpub.liverestaurant.service.security.RdbmsPlainTextLoginModule Required;
};

```

将调用 `RdbmsPlainTextLoginModule.java`中的 `login`方法从 DAO 层获取用户密码和凭证。如果提取的密码与传入消息的密码匹配，则设置凭证并返回 `true`；否则会抛出异常，导致服务器向客户端发回故障消息：

```java
public class RdbmsPlainTextLoginModule implements LoginModule {
private Subject subject;
private CallbackHandler callbackHandler;
private boolean success;
private List<RdbmsPrincipal> principals = new ArrayList<RdbmsPrincipal>();
private List<RdbmsCredential> credentials = new ArrayList<RdbmsCredential>();
@Override
public void initialize(Subject subject, CallbackHandler callbackHandler,
Map<String, ?> sharedState, Map<String, ?> options) {
.....
}
@Override
public boolean login() throws LoginException {
......
}
private List<String> getAllPermission(String username) {
......
}
private boolean authenticate(String username,String password)
{
....
}
public boolean commit() throws LoginException {
.....
}
@Override
public boolean logout() throws LoginException {
.....
}
}

```

### 注

在重要的应用程序中，甚至用户名都是加密的。这提供了更高的安全性，而且竞争对手无法通过 ISP 级别的过滤猜测哪些用户来自哪个位置。黑客猜测或跟踪用户名，并发送重复请求，以加载包含不必要数据的服务器。在此配方中，由于密码以纯文本格式传输，因此建议使用 SSL 连接。SpringWS 还支持使用证书进行身份验证的 `JaasCertificateValidationCallbackHandler`。此处不使用此处理程序。但是，您可以通过以下 URL 了解更多信息：

[http://static.springsource.org/spring-ws/site/apidocs/org/springframework/ws/soap/security/xwss/callback/jaas/JaasCertificateValidationCallbackHandler.html](http://static.springsource.org/spring-ws/site/apidocs/org/springframework/ws/soap/security/xwss/callback/jaas/JaasCertificateValidationCallbackHandler.html) 。

## 另见。。。

本章讨论了使用带有普通/摘要密码的用户名令牌来验证 Web 服务调用的方法*，使用 Spring Security 来验证带有普通/摘要密码的用户名令牌的 Web 服务调用的方法*，以及使用 X509 证书来验证 Web 服务调用的方法*。*

# 准备对和对称密钥存储

为了为 Web 服务调用添加更多的安全措施，我们确实需要一些额外的操作，例如对 Web 服务消息的签名进行签名和验证、加密/解密以及使用证书进行身份验证。XWSS 使用密钥库提供这些操作。 `java.security.KeyStore`类为加密密钥和证书提供了一个内存容器。此类可包括三种类型的条目：

*   私钥条目，包含私钥和公钥证书（注意，此处的公钥包装在 X.509 证书中。私钥和公钥证书的组合称为**密钥对）**
*   包含对称密钥的密钥项
*   可信证书条目，其中包含可信证书（此证书是另一方证书，作为可信证书导入，这意味着所有者密钥将公钥存储在属于第三方的另一方证书中）

密钥库可能包含一到多个条目。密钥库中的别名用于区分条目。私钥和证书由一个别名引用，而任何其他受信任证书或密钥项由密钥库中的不同别名引用。

本章前面介绍了使用用户名令牌对 Web 服务调用进行身份验证。可以使用证书对 Web 服务调用进行身份验证。在本章后面的*配方中，使用 X509 证书*验证 Web 服务调用，将介绍使用证书的验证。此外，这些证书还可用于证书验证、签名验证和加密。

**Java keytool**是一种生成密钥和证书并将其存储在密钥库文件中的工具。此密钥库受密钥库密码保护。此外，还有另一个密码保护私钥。

在此配方中，使用 keytool 生成具有对称密钥项、私钥项（私钥和公钥证书）和可信证书项的密钥库。这些密钥将在本章后面部分以及[第 8 章](08.html "Chapter 8. Securing SOAP Web-Services using WSS4J Library")*中使用 WSS4J 库*保护 SOAP Web 服务，用于签名和验证 Web 服务消息的签名、加密/解密以及使用证书进行身份验证。

## 准备好了吗

安装 Java，如第一个配方中所述。

## 怎么做。。。

要使用别名为*对称*的密钥项生成密钥库，请运行以下命令（此密钥库稍后用于对称加密/解密）：

```java
keytool -genseckey -alias 'symmetric' -keyalg 'DESede' -keystore symmetricStore.jks -storepass 'symmetricPassword' -keypass 'keyPassword' -storetype "JCEKS" 

```

要使用私钥项或密钥对（包含私钥和公钥对）生成密钥库，请执行以下步骤：

1.  要生成接收方（此处为服务器端）密钥库，请运行以下命令并遵循命令提示：

    ```java
    keytool -genkey -alias server -keyalg RSA -keystore serverStore.jks -validity 3653
    Enter keystore password:serverPassword
    Re-enter new password:serverPassword
    What is your first and last name?
    [Unknown]: MyFirstName MyLastName
    What is the name of your organizational unit?
    [Unknown]: Software
    What is the name of your organization?
    [Unknown]: MyCompany
    What is the name of your City or Locality?
    [Unknown]: MyCity
    What is the name of your State or Province?
    [Unknown]: MyProvince
    What is the two-letter country code for this unit?
    [Unknown]: ME
    Is CN=MyFirstName MyLastName, OU=Software, O=MyCompany, L=MyCity, ST=MyProvince, C=ME correct?
    [no]: yes
    Enter key password for <server>
    (RETURN if same as keystore password):serPkPassword
    Re-enter new password:serPkPassword 

    ```

2.  要生成发送方（此处为客户端）密钥库，请运行以下命令并遵循命令提示：

    ```java
    keytool -genkey -alias client -keyalg RSA -keystore clientStore.jks -validity 3653
    Enter keystore password:clientPassword
    Re-enter new password:clientPassword
    What is your first and last name?
    [Unknown]: MyFirstName MyLastName
    What is the name of your organizational unit?
    [Unknown]: Software
    What is the name of your organization?
    [Unknown]: MyCompany
    What is the name of your City or Locality?
    [Unknown]: MyCity
    What is the name of your State or Province?
    [Unknown]: MyProvince
    What is the two-letter country code for this unit?
    [Unknown]: ME
    Is CN=MyFirstName MyLastName, OU=Software, O=MyCompany, L=MyCity, ST=MyProvince, C=ME correct?
    [no]: yes
    Enter key password for <server>
    (RETURN if same as keystore password):cliPkPassword
    Re-enter new password:cliPkPassword 

    ```

3.  要在密钥库中查看生成的私钥条目，请运行以下命令（请注意下划线文本中的 `privateKeyEntry`：

    ```java
    keytool -list -v -keystore serverStore.jks -storepass serverPassword
    Keystore type: JKS
    Keystore provider: SUN
    Your keystore contains 1 entry
    Alias name: server
    Creation date: 26-Jul-2011
    Entry type: PrivateKeyEntry
    Certificate chain length: 1
    Certificate[1]:
    Owner: CN=MyFirstName MyLastName, OU=Software, O=MyCompany, L=MyCity, ST=MyProvince, C=ME
    Issuer: CN=MyFirstName MyLastName, OU=Software, O=MyCompany, L=MyCity, ST=MyProvince, C=ME
    Serial number: 4e2ebd0c
    Valid from: Tue Jul 26 17:11:40 GST 2011 until: Mon Jul 26 17:11:40 GST 2021
    Certificate fingerprints:
    MD5: 9E:DF:5E:18:F5:F6:52:4A:B6:9F:67:04:39:C9:57:66
    SHA1: C5:0B:8C:E6:B6:02:BD:38:56:CD:BB:50:CC:C6:BA:74:86:27:6C:C7
    Signature algorithm name: SHA1withRSA
    Version: 3 

    ```

4.  要从具有私钥项的密钥库生成证书（公钥），请对客户端/服务器端密钥库运行以下命令：

    ```java
    keytool -export -file clientStore.cert -keystore clientStore.jks -storepass clientPassword -alias client
    keytool -export -file serverStore.cert -keystore serverStore.jks -storepass serverPassword -alias server 

    ```

5.  要将发送方（客户端）公钥证书导入接收方（服务器）密钥库，请对服务器端密钥库运行以下命令（此证书将作为别名为*客户端的受信任证书条目存储在密钥库中）：*

    ```java
    keytool -import -file clientStore.cert -keystore serverStore.jks -storepass serverPassword -alias client
    Owner: CN=MyFirstName MyLastName, OU=Software, O=MyCompany, L=MyCity, ST=MyProvince, C=ME
    Issuer: CN=MyFirstName MyLastName, OU=Software, O=MyCompany, L=MyCity, ST=MyProvince, C=ME
    Serial number: 4e2ebf1e
    Valid from: Tue Jul 26 17:20:30 GST 2011 until: Mon Jul 26 17:20:30 GST 2021
    Certificate fingerprints:
    MD5: FD:BE:98:72:F0:C8:50:D5:4B:10:B0:80:3F:D4:43:E8
    SHA1: 91:FB:9D:1B:69:E9:5F:0B:97:8C:E2:FE:49:0E:D8:CD:25:FB:D8:18
    Signature algorithm name: SHA1withRSA
    Version: 3
    Trust this certificate? [no]: yes
    Certificate was added to keystore 

    ```

6.  要将接收方（服务器）公钥证书导入发送方（客户端）密钥库，请对发送方（客户端）密钥库运行以下命令（此证书将作为可信证书条目存储在别名为*服务器的密钥库中）：*

    ```java
    keytool -import -file serverStore.cert -keystore clientStore.jks -storepass clientPassword -alias server
    Owner: CN=MyFirstName MyLastName, OU=Software, O=MyCompany, L=MyCity, ST=MyProvince, C=ME
    Issuer: CN=MyFirstName MyLastName, OU=Software, O=MyCompany, L=MyCity, ST=MyProvince, C=ME
    Serial number: 4e2ebf1e
    Valid from: Tue Jul 26 17:20:30 GST 2011 until: Mon Jul 26 17:20:30 GST 2021
    Certificate fingerprints:
    MD5: FD:BE:98:72:F0:C8:50:D5:4B:10:B0:80:3F:D4:43:E8
    SHA1: 91:FB:9D:1B:69:E9:5F:0B:97:8C:E2:FE:49:0E:D8:CD:25:FB:D8:18
    Signature algorithm name: SHA1withRSA
    Version: 3
    Trust this certificate? [no]: yes
    Certificate was added to keystore 

    ```

7.  要在密钥库中查看服务器的私钥条目和受信任证书条目，请运行以下命令（请注意划线文本中的 `trustedCertEntry`和 privateKeyEntry）：

    ```java
    keytool -list -v -keystore serverStore.jks -storepass serverPassword
    Keystore type: JKS
    Keystore provider: SUN
    Your keystore contains 2 entries
    Alias name: client
    Creation date: 26-Jul-2011
    Entry type: trustedCertEntry
    Owner: CN=MyFirstName MyLastName, OU=Software, O=MyCompany, L=MyCity, ST=MyProvince, C=ME
    Issuer: CN=MyFirstName MyLastName, OU=Software, O=MyCompany, L=MyCity, ST=MyProvince, C=ME
    Serial number: 4e2ebf1e
    Valid from: Tue Jul 26 17:20:30 GST 2011 until: Mon Jul 26 17:20:30 GST 2021
    Certificate fingerprints:
    MD5: FD:BE:98:72:F0:C8:50:D5:4B:10:B0:80:3F:D4:43:E8
    SHA1: 91:FB:9D:1B:69:E9:5F:0B:97:8C:E2:FE:49:0E:D8:CD:25:FB:D8:18
    Signature algorithm name: SHA1withRSA
    Version: 3
    *******************************************
    *******************************************
    Alias name: server
    Creation date: 26-Jul-2011
    Entry type: PrivateKeyEntry
    Certificate chain length: 1
    Certificate[1]:
    Owner: CN=MyFirstName MyLastName, OU=Software, O=MyCompany, L=MyCity, ST=MyProvince, C=ME
    Issuer: CN=MyFirstName MyLastName, OU=Software, O=MyCompany, L=MyCity, ST=MyProvince, C=ME
    Serial number: 4e2ebd0c
    Valid from: Tue Jul 26 17:11:40 GST 2011 until: Mon Jul 26 17:11:40 GST 2021
    Certificate fingerprints:
    MD5: 9E:DF:5E:18:F5:F6:52:4A:B6:9F:67:04:39:C9:57:66
    SHA1: C5:0B:8C:E6:B6:02:BD:38:56:CD:BB:50:CC:C6:BA:74:86:27:6C:C7
    Signature algorithm name: SHA1withRSA
    Version: 3
    *******************************************
    ******************************************* 

    ```

8.  要在密钥库中查看客户端的私钥项和受信任证书项，请运行以下命令：

```java
keytool -list -v -keystore clientStore.jks -storepass clientPassword
Keystore type: JKS
Keystore provider: SUN
Your keystore contains 2 entries
Alias name: client
Creation date: 26-Jul-2011
Entry type: PrivateKeyEntry
Certificate chain length: 1
Certificate[1]:
Owner: CN=MyFirstName MyLastName, OU=Software, O=MyCompany, L=MyCity, ST=MyProvince, C=ME
Issuer: CN=MyFirstName MyLastName, OU=Software, O=MyCompany, L=MyCity, ST=MyProvince, C=ME
Serial number: 4e2ebf1e
Valid from: Tue Jul 26 17:20:30 GST 2011 until: Mon Jul 26 17:20:30 GST 2021
Certificate fingerprints:
MD5: FD:BE:98:72:F0:C8:50:D5:4B:10:B0:80:3F:D4:43:E8
SHA1: 91:FB:9D:1B:69:E9:5F:0B:97:8C:E2:FE:49:0E:D8:CD:25:FB:D8:18
Signature algorithm name: SHA1withRSA
Version: 3
*******************************************
******************************************
Alias name: server
Creation date: 26-Jul-2011
Entry type: trustedCertEntry
Owner: CN=MyFirstName MyLastName, OU=Software, O=MyCompany, L=MyCity, ST=MyProvince, C=ME
Issuer: CN=MyFirstName MyLastName, OU=Software, O=MyCompany, L=MyCity, ST=MyProvince, C=ME
Serial number: 4e2ebd0c
Valid from: Tue Jul 26 17:11:40 GST 2011 until: Mon Jul 26 17:11:40 GST 2021
Certificate fingerprints:
MD5: 9E:DF:5E:18:F5:F6:52:4A:B6:9F:67:04:39:C9:57:66
SHA1: C5:0B:8C:E6:B6:02:BD:38:56:CD:BB:50:CC:C6:BA:74:86:27:6C:C7
Signature algorithm name: SHA1withRSA
Version: 3
*******************************************
******************************************* 

```

## 它是如何工作的。。。

在开始时，会生成一个对称密钥存储，该密钥存储可由客户端和服务器共享以进行加密和解密。此命令生成对称密钥存储：

```java
keytool -genseckey -alias 'symmetric' -keyalg 'DESede' -keystore symmetricStore.jks -storepass 'symmetricPassword' -keypass 'keyPassword' -storetype "JCEKS" 

```

要生成具有私钥项和受信任证书项的密钥库，首先应生成客户端和服务器端的密钥对（私钥和公共证书）密钥库。

然后应该从客户机/服务器密钥库导出公钥证书。最后，客户端证书应导入到服务器密钥库中，服务器证书应导入到客户端密钥库中（此导入的证书称为**可信证书）**。

```java
keytool -genkey -alias aliasName -keyalg RSA -keystore keyStoreFileName.jks -validity 3653 

```

前面的命令生成具有私钥项的密钥库， `aliasName`是密钥库的标识符。Validity 是此密钥有效的天数。

```java
keytool -export -file clientStore.cert -keystore clientStore.jks -storepass clientPassword -alias client 

```

前面的命令导出嵌入密钥库中私钥项中的公钥证书。

```java
keytool -import -file clientStore.cert -keystore serverStore.jks -storepass serverPassword -alias client

```

前面的命令将生成的公钥证书从客户端密钥库导入服务器密钥库（此导入的证书称为受信任证书）。

有关加密和密钥库的更多信息，请访问以下 URL：

[http://docs.oracle.com/javase/1.5.0/docs/api/java/security/KeyStore.html](http://docs.oracle.com/javase/1.5.0/docs/api/java/security/KeyStore.html) 。

[http://en.wikipedia.org/wiki/Category:Public-密钥加密](http://en.wikipedia.org/wiki/Category:Public-key_cryptography)。

## 另见。。。

本章将讨论使用数字签名保护 SOAP 消息的方法*，使用 X509 证书*验证 Web 服务调用，以及对 SOAP 消息进行加密/解密的方法*。*

# 使用数字签名保护 SOAP 消息

**数字签名**的目的是验证收到的消息是否被更改，以证明发送者是他/她声称的人（身份验证），并证明特定发送者的行为。消息的数字签名意味着添加散列数据，即添加到 SOAP 信封中的一条信息（令牌）。接收方需要从传入消息中重新生成自己的散列，并将其与发送方的散列进行比较。如果接收方的散列与发送方的散列相匹配，则实现数据完整性，接收方将继续；否则，它将向发送方返回 SOAP 错误消息。

为了验证发送者，发送者应该使用他/她自己的私钥加密签名令牌。接收方应在接收方密钥库中拥有发送方的公钥证书（该证书称为受信任证书，位于受信任证书项下），以解密发送方的签名令牌，并重复已说明的步骤以检查消息完整性。现在，如果实现了消息完整性，那么发送方的身份验证将得到证明（因为只有嵌入接收方密钥库中的发送方证书才能解密发送方的加密签名）。此外，发送方发送消息的行为也得到了证明（因为接收方签名的成功解密表明发送方已经用自己的私钥对其进行了加密）。

在此配方中，发送方（客户端）对消息进行签名，并使用其自己的私钥（在客户端密钥库中）对签名进行加密。在接收方（服务器），服务器密钥库中的客户端公钥证书（该证书称为可信证书，位于密钥库中的可信证书项下）将用于令牌签名的解密；然后服务器验证签名令牌。

## 准备好了吗

在此配方中，项目名称为 `LiveRestaurant_R-7.4`（用于服务器端 Web 服务），具有以下 Maven 依赖项：

*   `spring-ws-security-2.0.1.RELEASE.jar`
*   `spring-expression-3.0.5.RELEASE.jar`
*   `log4j-1.2.9.jar`

`LiveRestaurant_R-7.4-Client`（用于客户端 Web 服务）具有以下 Maven 依赖项：

*   `spring-ws-security-2.0.1.RELEASE.jar`
*   `spring-ws-test-2.0.0.RELEASE.jar`
*   `spring-expression-3.0.5.RELEASE.jar`
*   `log4j-1.2.9.jar`
*   `junit-4.7.jar`

## 怎么做。。。

1.  将 `serverStore.jks`复制到服务器，将 `clientStore.jks`复制到客户端（这些密钥存储已经在本章讨论的*准备对和对称密钥存储*配方中生成）。
2.  在服务器端配置安全策略文件（`securityPolicy.xml`），以期望签名令牌与客户端的传入消息一起对传出消息进行签名。
3.  在服务器端应用程序上下文文件中注册 `keyStoreHAndler`（KeyStoreCallbackHandler）和 `trustStore`（KeystrefactoryBean）。
4.  在客户端应用程序上下文文件中注册 `keyStoreHAndler`（KeyStoreCallbackHandler）和 `keyStore`（KeystrefactoryBean）。
5.  从 `Liverestaurant_R-7.4:`

    ```java
    mvn clean package tomcat:run 

    ```

    运行以下命令
6.  从 `Liverestaurant_R-7.4-Client:`运行以下命令

```java
mvn clean package 

```

*   以下是带下划线文本中的客户端输出（注意标记`ds:Signature`：

```java
INFO: ==== Sending Message Start ====
....
<SOAP-ENV:Envelope.....>
<SOAP-ENV:Header>
<wsse:Security ....>
...
<ds:Signature ....>
<ds:SignedInfo>
.....
</ds:SignedInfo>
<ds:SignatureValue>....</ds:SignatureValue>
<ds:KeyInfo>
<wsse:SecurityTokenReference .........>
<wsse:Reference ..../>
</wsse:SecurityTokenReference>
</ds:KeyInfo>
</ds:Signature>
</wsse:Security>
</SOAP-ENV:Header>
<SOAP-ENV:Body....>
<tns:placeOrderRequest ...>
......
</tns:placeOrderRequest>
</SOAP-ENV:Body>
</SOAP-ENV:Envelope>
==== Sending Message End ====....
<SOAP-ENV:Header/>
<SOAP-ENV:Body>
<tns:placeOrderResponse ....>
<tns:refNumber>order-John_Smith_1234</tns:refNumber>
</tns:placeOrderResponse>
</SOAP-ENV:Body>
</SOAP-ENV:Envelope>
==== Received Message End ==== 

```

## 它是如何工作的。。。

服务器端的安全策略要求客户端在消息中包含二进制签名令牌。客户端策略文件中的设置包括传出消息中的签名令牌。客户端使用客户端密钥库中包含的自己的私钥来加密消息的签名令牌。在服务器端，服务器密钥库中包含的客户端公钥证书（该证书称为受信任证书，位于密钥库中的受信任证书项下）将用于解密传入的签名令牌。然后，服务器继续验证签名。

策略文件中的以下服务器端安全配置导致服务器期望从传入消息中获得安全令牌（用于验证传入消息）：

```java
<xwss:RequireSignature requireTimestamp="false" />
</xwss:SecurityConfiguration>

```

但是，在客户端，策略文件中的此安全配置会导致客户端在传出消息的 SOAP 消息中包含一个安全令牌：

```java
<xwss:Sign includeTimestamp="false">
</xwss:Sign>

```

客户端应用程序上下文中的以下设置导致客户端使用 `clientStore.jks`中的私钥加密消息的签名令牌。私钥密码为 `cliPkPassword`，私钥条目的别名为 `client`，通过读取密钥库密码为 `clientPassword:`的密钥库 `clientStore.jks`生成密钥库 bean

```java
<bean id="keyStore" class="org.springframework.ws.soap.security.support.KeyStoreFactoryBean">
<property name="password" value="clientPassword" />
<property name="location" value="/clientStore.jks" />
</bean>
<bean id="keyStoreHandler" class="org.springframework.ws.soap.security.xwss.callback.KeyStoreCallbackHandler">
<property name="keyStore" ref="keyStore" />
<property name="privateKeyPassword" value="cliPkPassword" />
<property name="defaultAlias" value="client" />
</bean>

```

在服务器端，服务器配置文件中的以下设置会导致服务器首先使用服务器密钥库中的客户端证书（该证书称为受信任证书）对签名令牌进行解密。然后验证传入消息的签名（以查看原始消息是否被更改）：

```java
<bean id="keyStoreHandler" class="org.springframework.ws.soap.security.xwss.callback.KeyStoreCallbackHandler">
<property name="trustStore" ref="trustStore"/>
</bean>
<bean id="trustStore" class="org.springframework.ws.soap.security.support.KeyStoreFactoryBean">
<property name="location" value="/WEB-INF/serverStore.jks" />
<property name="password" value="serverPassword" />
</bean>

```

## 另见。。。

本章讨论了使用 X509 证书对 Web 服务调用进行身份验证的方法*准备配对和对称密钥存储*和*。*

# 使用 X509 证书验证 Web 服务调用

在前面的方法中，*使用数字签名*保护 SOAP 消息，通过更改发送方（客户端）安全策略文件，发送方可以将客户端的证书与传出消息一起包括在内。然后，在接收方（服务器）上，在验证签名之前，服务器尝试通过将客户端证书和传入消息与嵌入服务器密钥库中的客户端证书（可信证书）进行比较来验证发送方。此外，在该配方中，客户端证书包含在发送方的传出消息中，并提取证书中包含的数据，以便在接收方进行身份验证和授权。

`SpringCertificateValidationCallbackHandler`可以从 XWSS 包中提取证书数据（如 `CN=MyFirstName MyLastName)`，该数据既可以用于认证，也可以用于授权。

在这个配方中，我们使用*使用数字签名保护 SOAP 消息*配方对签名进行签名和验证。然后使用 `SpringCertificateValidationCallbackHandler`进行身份验证，使用从 DAO 层获取的数据以及对该 Web 服务调用的授权。

## 准备好了吗

在此配方中，项目名称为 `LiveRestaurant_R-7.5`（用于服务器端 Web 服务），并且它具有以下 Maven 依赖项：

*   `spring-ws-security-2.0.1.RELEASE.jar`
*   `spring-expression-3.0.5.RELEASE.jar`
*   `log4j-1.2.9.jar`

`LiveRestaurant_R-7.5-Client`（用于客户端 Web 服务）具有以下 Maven 依赖项：

*   `spring-ws-security-2.0.1.RELEASE.jar`
*   `spring-ws-test-2.0.0.RELEASE.jar`
*   `spring-expression-3.0.5.RELEASE.jar`
*   `log4j-1.2.9.jar`
*   `junit-4.7.jar`

## 怎么做。。。

在该配方中，所有步骤与前一配方中相同，*使用数字签名*保护 SOAP 消息，除了修改客户端的策略文件，因为该更改包括客户端证书以及传出消息和服务器端应用程序上下文文件（`spring-ws.servlet.xml`更改，使用 DAO 层获取数据：

1.  在服务器端应用程序上下文文件（SpringWSServlet.xml）中注册 `springSecurityCertificateHandler`。
2.  修改客户端安全策略文件，使其包含客户端证书和传出消息。
3.  Add the DAO layer classes to fetch data.

    以下是带下划线文本中的客户端输出（请注意 X509 客户端认证）：

```java
INFO: ==== Sending Message Start ====
<?xml...>
<SOAP-ENV:Header>
<wsse:Security ...>
<wsse:BinarySecurityToken...wss-x509-token-..>.....</wsse:BinarySecurityToken>
<ds:Signature .....>
<ds:SignedInfo>
......
</ds:SignedInfo>
<ds:SignatureValue>.....</ds:SignatureValue>
<ds:KeyInfo>
<wsse:SecurityTokenReference...>
<wsse:Reference ...wss-x509-token-profile-1.0.../>
</wsse:SecurityTokenReference>
</ds:KeyInfo>
</ds:Signature>
</wsse:Security>
</SOAP-ENV:Header>
<SOAP-ENV:Body ....>
<tns:placeOrderRequest ...>
.....
</tns:placeOrderRequest>
</SOAP-ENV:Body>
</SOAP-ENV:Envelope>
==== Sending Message End ====
INFO: ==== Received Message Start ====
<?xml version="1.0" ....>
<SOAP-ENV:Header/>
<SOAP-ENV:Body>
<tns:placeOrderResponse xmlns:tns="http://www.packtpub.com/liverestaurant/OrderService/schema">
<tns:refNumber>order-John_Smith_1234</tns:refNumber>
</tns:placeOrderResponse>
</SOAP-ENV:Body>
</SOAP-ENV:Envelope>
==== Received Message End ==== 

```

## 它是如何工作的。。。

关于签名的所有内容都与使用数字签名保护 SOAP 消息的配方*中描述的内容相同*。此外，客户端证书包含在传出消息中，并在服务器端提取客户端证书数据以进行某些处理操作。

一旦提取了客户端的证书（即嵌入到传入消息中），就可以通过检索用户名或其他信息来完成身份验证。

在客户端策略文件中包含以下部分会导致客户端在传出消息中包含其自己的公钥证书：

```java
<xwss:X509Token certificateAlias="client" />

```

在对消息进行签名时，在调用方消息中嵌入客户端证书会导致服务器在签名验证之前使用服务器密钥库中包含的证书（发送方可信证书条目）验证此证书。此验证确认呼叫者是他/她声称的人。但是，如果需要检查帐户的激活/锁定或需要调用方访问特定资源的授权，则在服务器配置文件中配置的 `springSecurityCertificateHandler`将处理以下任务：

```java
<bean class="org.springframework.ws.soap.security.xwss.XwsSecurityInterceptor">
<property name="policyConfiguration" value="/WEB-INF/securityPolicy.xml"/>
<property name="secureResponse" value="false" />
<property name="callbackHandlers">
<list>
<ref bean="keyStoreHandler"/>
<ref bean="springSecurityCertificateHandler"/>
</list>
</property>
</bean>
</sws:interceptors>
<bean id="springSecurityCertificateHandler"
class="org.springframework.ws.soap.security.xwss.callback.SpringCertificateValidationCallbackHandler">
<property name="authenticationManager" ref="authenticationManager"/>
</bean>
<bean id="authenticationManager"
class="org.springframework.security.authentication.ProviderManager">
<property name="providers">
<bean class="org.springframework.ws.soap.security.x509.X509AuthenticationProvider">
<property name="x509AuthoritiesPopulator">
<bean class="org.springframework.ws.soap.security.x509.populator.DaoX509AuthoritiesPopulator">
<property name="userDetailsService" ref="userDetailsService"/>
</bean>
</property>
</bean>
</property>
</bean>
<bean id="userDetailsService" class="com.packtpub.liverestaurant.service.dao.MyUserDetailService" />

```

此处理程序使用调用 `DaoX509AuthoritiesPopulator`的身份验证管理器，该管理器应用自定义服务类 `MyUserDetailService`进行身份验证，并提取用户凭据进行授权：

```java
public class MyUserDetailService implements UserDetailsService {
@Override
public UserDetails loadUserByUsername(String username)
throws UsernameNotFoundException, DataAccessException {
return findUserDetailFromDAO(username);
}
private UserDetails findUserDetailFromDAO(String userName)throws UsernameNotFoundException{
MyUserDetail mydetail=null;
/**
*Real scenario: Find user-name from DAO layer, if user found, get data from the DAO and set MyUserDetail otherwise throw UsernameNotFoundException.
*/
if(! userName.equals("MyFirstName MyLastName")){
throw new UsernameNotFoundException("User name not found");
}
mydetail=new MyUserDetail(userName,"fetchedPassword",true,true,true,true,new GrantedAuthorityImpl("ROLE_GENERAL_OPERATOR"));
return mydetail;
}
}

```

## 另见。。。

本章讨论了使用数字签名和*准备对和对称密钥库*保护 SOAP 消息的方法*。*

# SOAP 消息的加密/解密

加密是使用特定算法将可读或纯文本数据格式转换为不可读的加密格式或密文的过程。这些算法称为加密算法，需要加密密钥。解密只是加密的反向操作；它使用解密密钥将密文转换回可读或纯文本数据格式。加密和解密密钥可以相同，也可以不同。如果加密和解密密钥相同，且发送方和接收方共享该密钥，则该密钥称为**对称**或**密钥**。加密和解密密钥可能不同，在这种情况下，该密钥称为**非对称**或**公钥**。

下图显示了用于加密/解密的对称密钥的用法。发送方和接收方可以共享同一个密钥，称为对称密钥。拥有此密钥的人可以解密/加密消息。例如，对称密钥用于发送方加密和接收方解密：

![Encrypting/decrypting of SOAP messages](img/5825_07_02.jpg)

下图显示了用于加密/解密的公钥/私钥的用法。Bob 作为发送者，获取 Alice 的公钥，加密消息并将其发送给 Alice。因为只有她是自己私钥的持有者，所以她可以解密消息：

![Encrypting/decrypting of SOAP messages](img/5825_07_01.jpg)

在此配方中，发送方（此处为客户端）对消息进行加密，并在三种不同情况下将其发送给接收方（此处为服务器）。在第一种情况下，对称密钥（位于存储区中，其密钥条目与客户端和服务器相同）用于客户端的加密和服务器端的解密。然后，在第二种情况下，发送方（客户机）密钥库（在接收方可信证书条目内）上的接收方（服务器）公钥证书用于数据加密，服务器端密钥库上的接收方（服务器）私钥用于解密。

由于 `annotation`端点映射（`PayloadRootAnnotationMethodEndpointMapping`中的整个有效负载的加密使得路由信息（例如，包含在有效负载中的 `localPart = "placeOrderRequest", namespace = "http://www.packtpub.com/liverestaurant/OrderService/schema`）与整个有效负载一起加密，因此 `annotation`端点映射不能使用。相反， `SoapActionAnnotationMethodEndpointMapping`寻址样式用于端点映射。在这种情况下，路由数据包含在 SOAP 标头中，而它包含在注释端点映射的有效负载中。虽然有效负载的一部分加密可以与有效负载注释端点映射一起使用，但为了一致性， `SoapActionAnnotationMethodEndpointMapping`寻址样式用于整个配方。

有关端点映射的更多信息，请参阅[第 1 章](01.html "Chapter 1. Building SOAP Web-Services")*构建 SOAP Web 服务中讨论的*通过注释有效负载根*来设置端点*和*设置与传输无关的 WS-Addressing 端点*。**

在前两种情况下，整个有效负载用于加密/解密。XWSS 策略配置文件可以对有效负载部分进行加密/解密。在第三种情况下，仅将有效负载的一部分设置为加密/解密的目标。

## 准备好了吗

在此配方中，项目名称为 `LiveRestaurant_R-7.6`（用于服务器端 Web 服务），并具有以下 Maven 依赖项：

*   `spring-ws-security-2.0.1.RELEASE.jar`
*   `spring-expression-3.0.5.RELEASE.jar`
*   `log4j-1.2.9.jar`
*   `mail-1.4.1.jar`
*   `saaj-api-1.3.jar`
*   `saaj-impl-1.3.2.jar`

`LiveRestaurant_R-7.6-Client`（用于客户端 Web 服务）具有以下 Maven 依赖项：

*   `spring-ws-security-2.0.1.RELEASE.jar`
*   `spring-ws-test-2.0.0.RELEASE.jar`
*   `spring-expression-3.0.5.RELEASE.jar`
*   `log4j-1.2.9.jar`
*   `junit-4.7.jar`

## 怎么做。。。

以下步骤使用共享对称密钥（`symmetricStore.jks`实现加密/解密：

1.  在服务器/客户端应用程序上下文中注册 `keyStoreHandler`和 `symmetricStore`。将对称密钥库（`symmetricStore.jks`复制到服务器/客户端文件夹中（此密钥库已在本章讨论的配方*准备对和对称密钥库*中生成）。
2.  在服务器端配置安全策略文件（`securityPolicy.xml`）以期望对来自其客户端的消息进行加密，在客户端配置安全策略文件（`securityPolicy.xml`）以加密传出的消息。
3.  从 `Liverestaurant_R-7.6:`

    ```java
    mvn clean package tomcat:run 

    ```

    运行以下命令
4.  从 `Liverestaurant_R-7.6-Client:`运行以下命令

```java
mvn clean package 

```

*   以下是客户端输出（请注意输出中带下划线的部分）：

```java
INFO: ==== Received Message Start ====
....
<SOAP-ENV:Envelope ....>
<SOAP-ENV:Header>
<wsse:Security ....>
.......
</wsse:Security>
</SOAP-ENV:Header>
<SOAP-ENV:Body>
<xenc:EncryptedData.....">
<xenc:EncryptionMethod ....>
<ds:KeyInfo ...xmldsig#">
<ds:KeyName>symmetric</ds:KeyName>
</ds:KeyInfo>
<xenc:CipherData>
<xenc:CipherValue>
3esI76ANNDEIZ5RWJt.....
</xenc:CipherValue>
</xenc:CipherData>
</xenc:EncryptedData>
</SOAP-ENV:Body>
</SOAP-ENV:Envelope>
==== Received Message End ====
Nov 7, 2011 11:48:46 PM com.sun.xml.wss.impl.filter.DumpFilter process
INFO: ==== Sending Message Start ====
<?xml version="1.0" ...
><SOAP-ENV:Envelope ...>
<SOAP-ENV:Header/>
<SOAP-ENV:Body>
<tns:placeOrderResponse xmlns:tns="http://www.packtpub.com/liverestaurant/OrderService/schema">
<tns:refNumber>order-John_Smith_1234</tns:refNumber>
</tns:placeOrderResponse>
</SOAP-ENV:Body>
</SOAP-ENV:Envelope>
==== Sending Message End ==== 

```

以下步骤在客户端密钥库（`clientStore.jks`上使用服务器可信证书（或公钥）实现加密，在服务器端密钥库（`serverStore.jks`上使用服务器私钥实现解密）：

1.  修改 `securityPolicy.xml`在客户端使用服务器可信证书加密消息（包含在 `clientStore.jks)`中），在服务器端使用服务器私钥解密消息（包含在 `serverStore.jks)`中）。
2.  在服务器端注册 `keyStoreHandler`和 `keyStore`，在客户端应用程序上下文注册 `keyStoreHandler`和 `trustStore`。将 `clientStore.jks`复制到客户端，并将 `serverStore.jks`复制到服务器文件夹（此密钥库已在本章讨论的配方*准备对和对称密钥库*中生成）。
3.  在服务器端配置安全策略文件（`securityPolicy.xml`）以期望对来自其客户端的消息进行加密，在客户端配置安全策略文件（`securityPolicy.xml`）以加密传出的消息。
4.  从 `Liverestaurant_R-7.6:`

    ```java
    mvn clean package tomcat:run 

    ```

    运行以下命令
5.  从 `Liverestaurant_R-7.6-Client:`运行以下命令

```java
mvn clean package 

```

*   以下是客户端输出（请注意输出中带下划线的部分）：

```java
INFO: ==== Sending Message Start ====
...
<SOAP-ENV:Envelope ....>
<SOAP-ENV:Header>
<wsse:Security ...>
........
</wsse:Security>
</SOAP-ENV:Header>
<SOAP-ENV:Body>
<xenc:EncryptedData....>
<xenc:EncryptionMethod .../>
<ds:KeyInfo xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
<wsse:SecurityTokenReference...>
<wsse:Reference ..../>
</wsse:SecurityTokenReference>
</ds:KeyInfo>
<xenc:CipherData>
...
</xenc:CipherValue>
</xenc:CipherData>
</xenc:EncryptedData>
</SOAP-ENV:Body>
</SOAP-ENV:Envelope>
==== Sending Message End ====
Nov 8, 2011 12:12:11 AM com.sun.xml.wss.impl.filter.DumpFilter process
INFO: ==== Received Message Start ====
<SOAP-ENV:Envelope ....>
<SOAP-ENV:Header/>
<SOAP-ENV:Body>
<tns:placeOrderResponse xmlns:tns="http://www.packtpub.com/liverestaurant/OrderService/schema">
<tns:refNumber>order-John_Smith_1234</tns:refNumber>
</tns:placeOrderResponse>
</SOAP-ENV:Body>
</SOAP-ENV:Envelope>
==== Received Message End ==== 

```

以下步骤对部分有效负载实施加密/解密：

1.  修改客户端/服务器端 `securityPolicy.xml`设置加密目标。
2.  从 `Liverestaurant_R-7.6:`

    ```java
    mvn clean package tomcat:run 

    ```

    运行以下命令
3.  从 `Liverestaurant_R-7.6-Client:`运行以下命令

```java
mvn clean package 

```

*   以下是客户端输出（注意输出中带下划线的部分）：

```java
INFO: ==== Sending Message Start ====
...
<SOAP-ENV:Envelope ....>
<SOAP-ENV:Header>
<wsse:Security ....>
........
</wsse:Security>
</SOAP-ENV:Header>
<SOAP-ENV:Body>
<tns:placeOrderRequest ...>
<xenc:EncryptedData .....>
..........
<xenc:CipherData>
<xenc:CipherValue>NEeTuduV....
..........
</xenc:CipherValue>
</xenc:CipherData>
</xenc:EncryptedData>
</tns:placeOrderRequest>
</SOAP-ENV:Body>
</SOAP-ENV:Envelope>
==== Sending Message End ====
Nov 8, 2011 12:18:39 AM com.sun.xml.wss.impl.filter.DumpFilter process
INFO: ==== Received Message Start ====
....
<SOAP-ENV:Envelope ...>
<SOAP-ENV:Header/>
<SOAP-ENV:Body>
<tns:placeOrderResponse ....>
<tns:refNumber>order-John_Smith_1234</tns:refNumber>
</tns:placeOrderResponse>
</SOAP-ENV:Body>
</SOAP-ENV:Envelope>
==== Received Message End ==== 

```

## 它是如何工作的。。。

在第一种情况下，客户端和服务器都共享对称密钥。客户端使用对称密钥加密整个有效负载，并将其发送到服务器。在服务器端，相同的密钥将用于解密有效负载。然而，在第二和第三种情况下，嵌入在客户机存储中的服务器证书用于有效负载的加密，服务器存储的服务器端私钥将用于解密。

服务器/客户端策略文件中的 `RequireEncryption/Encrypt`标记会导致客户端加密消息，服务器解密消息。 `keyAlias`是在生成对称密钥库时设置的别名。客户端和服务器端策略文件中的以下部分以要加密/解密的消息信封部分为目标。 `qname: {http://schemas.xmlsoap.org/soap/envelope/}Body`仅使 SOAP 信封的主体部分用于加密/解密。

```java
---server policy file
<xwss:RequireEncryption>
<xwss:SymmetricKey keyAlias="symmetric" />
<xwss:EncryptionTarget type="qname" value="{http://schemas.xmlsoap.org/soap/envelope/}Body" enforce="true"
contentOnly="true" />
</xwss:RequireEncryption>
---client policy file
<xwss:Encrypt>
<xwss:SymmetricKey keyAlias="symmetric" />
<xwss:Target type="qname">{http://schemas.xmlsoap.org/soap/envelope/}Body
</xwss:Target>
</xwss:Encrypt>

```

服务器和客户端配置文件中的这一部分会导致对称存储用于加密。 `callbackHandler`（`keyStoreHandlerBean`使用对称密钥库（`symmetricStore bean`，密钥密码为 `keyPassword`。 `KeyStore`bean 将通过读取密钥库位置（`symmetricStore.jks`）生成，密钥库密码为 `symmetricPassword`，类型设置为 JCEKS（密码和类型在对称密钥库生成时设置）。

```java
<bean id="keyStoreHandler" class="org.springframework.ws.soap.security.xwss.callback.KeyStoreCallbackHandler">
<property name="symmetricStore" ref="symmetricStore" />
<property name="symmetricKeyPassword" value="keyPassword" />
</bean>
<bean id="symmetricStore"
class="org.springframework.ws.soap.security.support.KeyStoreFactoryBean">
<property name="password" value="symmetricPassword" />
<property name="location" value="/WEB-INF/symmetricStore.jks" />
<property name="type" value="JCEKS" />
</bean>

```

在第二种情况下，几乎所有设置都相同，只是客户端使用服务器公钥进行加密，服务器使用服务器存储私钥进行解密。服务器端配置文件中的以下部分使服务器使用服务器端密钥库中的服务器私钥进行解密。私钥密码为 `serPkPasswords`，密钥库中私钥条目的别名为*服务器*。 `KeyStore`bean 将通过读取密码为 `serverPassword`的密钥库文件（`serverStore.jks`）生成（密码和别名在密钥库生成时设置）。

```java
---server configuration
<bean id="keyStoreHandler"
class="org.springframework.ws.soap.security.xwss.callback.KeyStoreCallbackHandler">
<property name="keyStore" ref="keyStore" />
<property name="privateKeyPassword" value="serPkPassword" />
<property name="defaultAlias" value="server" />
</bean>
<bean id="keyStore"
class="org.springframework.ws.soap.security.support.KeyStoreFactoryBean">
<property name="location" value="/WEB-INF/serverStore.jks" />
<property name="password" value="serverPassword" />
</bean>

```

客户端配置文件中的此部分将使客户端使用客户端信任存储中的服务器证书（公钥）进行加密。 `KeyStore`（此处信任存储）bean 将通过使用密码 `clientPAssword`读取 `clientStore.jks`生成。

```java
---client configuration
<bean id="keyStoreHandler"
class="org.springframework.ws.soap.security.xwss.callback.KeyStoreCallbackHandler">
<property name="trustStore" ref="trustStore"/>
</bean>
<bean id="trustStore"
class="org.springframework.ws.soap.security.support.KeyStoreFactoryBean">
<property name="location" value="/clientStore.jks" />
<property name="password" value="clientPassword" />
</bean>

```

在客户端和服务器端的策略文件中，以下行将使服务器公钥用于客户端加密，而服务器存储区中的私钥用于解密。

```java
<xwss:X509Token certificateAlias="server"/>

```

在第三种情况下，服务器和客户端的策略文件中的以下部分仅导致对有效负载的一部分进行加密：

```java
<xwss:Target type="qname">{http://www.packtpub.com/LiveRestaurant/placeOrderService/schema}OrderRequest</xwss:Target>

```

### 提示

当加密整个负载时，请使用 WS-Addressing，因为路由信息将包含在报头中。

### 注

密钥库、密钥管理、密钥的频繁更新和证书是独立的领域，不属于本书的一部分。选择最佳选项需要更多的研究，这是架构相关工作的一部分。

## 另见。。。

本章讨论了使用数字签名和*准备对和对称密钥库*保护 SOAP 消息的方法*。*

*为 WS-Addressing 端点*创建 Web 服务客户端的方法，在[第 2 章](02.html "Chapter 2. Building Clients for SOAP Web-Services")*为 SOAP Web 服务构建客户端中讨论。*