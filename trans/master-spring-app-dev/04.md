# 第四章、弹簧批作业

企业应用程序通常需要通过应用复杂的业务规则来处理批量信息。有些应用程序需要自动作业来运行，并提供大块数据作为进一步处理的输入。此类功能始终是基于时间的作业，不需要任何用户干预。批处理广泛应用于银行和保险领域，在这些领域中，大量数据在预定时间进行处理。**作业**是一个流程，**批处理作业**意味着一组在预定时间运行以执行任务的流程。

# 弹簧批简介

SpringBatch 本身就是一个批处理框架，用于开发应用程序来执行批处理作业。它支持批处理优化和作业划分，并且具有高度可扩展性，这促使我们在批处理应用程序开发中考虑它。

## 使用弹簧批的用例

让我们列出几个可以在应用程序中使用 Spring batch 的用例：

*   在预定时间向用户发送批量邮件
*   从队列中读取消息的步骤
*   在给定时间更新事务
*   在给定时间处理从用户接收的所有文件

## 批量加工的目标

批处理的关键目标是完成以下步骤，以完成批处理作业：

1.  找工作。
2.  识别输入。
3.  安排作业。
4.  开始工作。
5.  处理作业。
6.  进入步骤 2（新输入）。

# 批处理作业的体系结构

让我们描述一下批处理器的基本架构；我们还可以看到批处理中涉及的组件。从下图可以看出 Spring Batch 的主要组件：

![Architecture of a batch job](graphics/7320OS_04_01.jpg)

现在，让我们分别来看看这些组件。

*   `JobRepository`：这个容器是我们需要注册作业或流程的地方。
*   `JobOperator`：触发注册作业的作业。它还提供用于访问寄存器的 API。这是一个接口。
*   `Job`：是`jobRepository`中的流程或任务。这还包括一个步骤。
*   `Step`：实际包含需要执行的逻辑。每个步骤由一个`ItemReader`、`ItemProcessor`和`ItemWriter`接口组成。首先，`ItemReader`接口一次读取作业中的一个步骤，并将其交给`ItemProcessor`处理作业。例如，它可能会收集一些所需的数据。然后，`ItemWriter`接口将数据写入数据库，或者执行事务或记录消息。有两种步骤：
    *   `ChunkStyle`：一个`ChunkStyle`步骤正好有一个`ItemReader`、一个`ItemProcessor`和一个`ItemWriter`。
    *   `BatchLet`：在春天，`BatchLet`被称为`TaskLetStep`。`BatchLet`是一个定制步骤，可用于发送批量邮件或短信。

现在我们已经了解了批处理的基础知识，在下一节中，我们将了解如何实现或使用批处理。

## 使用企业批次

我们有以下两种选择来实施批次：

*   为每个作业运行使用 JVM 并启动 JVM
*   在 J2EE 容器中部署批处理作业管理应用程序

JSR-352 是可用于实施批处理的标准规范。Spring 框架在很大程度上支持该规范。大多数 JEE 容器，如**Glassfish**、**Jboss-JMX**和 Web Sphere 都必须支持 JSR-352 规范。作为开发人员，我们可以选择 Spring 框架并将批处理部署在 J2EE 容器上。

您还可以使用 restful API 将数据汇集到批处理应用程序中或从中取出。在下一节中，让我们使用 Spring 批处理框架来创建作业。我们首先来看依赖关系。

# 对弹簧批次的依赖性

要开始使用 Spring 批处理，我们需要查看依赖项。假设用户熟悉 Maven 应用程序，我们可以查看需要添加到`pom.xml`文件以使用 Spring Batch 的以下依赖项：

```
<dependency>
  <groupId>org.springframework.batch</groupId>
  <artifactId>spring-batch-core</artifactId>
  <version>3.0.0.RELEASE</version>
</dependency>
<dependency>
  <groupId>org.springframework</groupId>
  <artifactId>spring-core</artifactId>
  <version>${spring.version}</version>
</dependency>

<dependency>
  <groupId>org.springframework</groupId>
  <artifactId>spring-context</artifactId>
  <version>${spring.version}</version>
</dependency>
```

## 弹簧批关键部件

您可以看到 SpringBatch 的关键组件与 Java 中用于批处理的 JSR 规范非常相似。

*   `JobRepository`: This is again a repository for jobs. But, in the Spring Batch framework, the core API has `JobRepository`. It provides the `create`, `update`, `read`, and `delete` methods for `JobLauncher`, `JobReader`, `ItemProcessor`, and `ItemWriter`. The class responsible for `JobRepository` in the Spring framework is `SimpleJobRepository`. There are two ways of storing the jobs: one in the database and another in memory (which will have to make use of `HashMaps`).

    `SimpleJobRepositoryConstructor`看起来像这样：

    ```
    public SimpleJobRepository(JobInstanceDao jobInstanceDao,
      JobExecutionDao jobExecutionDao,
      StepExecutionDao stepExecutionDao,
      ExecutionContextDao ecDao) 
    ```

*   `JobLauncher`: `JobLauncher` is just a simple interface used for launching jobs. Jobs are registered at the `jobRepository`.

    ```
    public interface JobLauncher {
      public JobExecution run(Job job, JobParameters jobParameters)
      throws JobExecutionAlreadyRunningException, JobRestartException;
    }
    ```

    `SimpleJobLauncher`类实现`JobLauncher`接口。这个类有一个`setJobRepository`方法。

    ```
    public void setJobRepository(JobRepository jobRepository)
    ```

*   `ItemReader`: It is an interface in `org.springframework.batch.item package`. ItemReader is used for providing data. The data can be from a database, XML, or from a flat file.

    实现类应该是有状态的，每个批都会被多次调用，每次对`read()`的调用都会返回不同的值，最后在所有输入数据耗尽时返回 null。实现类不需要是线程安全的，`ItemReader`接口的客户端需要意识到这一点。

    ```
    public interface ItemReader<T> {
      T read() throws Exception, UnexpectedInputException, ParseException;
    }
    ```

*   `ItemProcessor`: This is an interface that can be used for processing data and does the intermediate processing of data. Before it is given to `ItemWriter`, `ItemProcessor` can be used for implementing certain business logic.

    ```
    public interface ItemProcessor<I, O> {
      O process(I item) throws Exception;
    }
    public class ProductBean {}

    public class RelatedProductsBean {
      public RelatedProductsBean(ProductBean productBean) {}
    }
    public class ProductBeanProcessor implements ItemProcessor<ProductBean, RelatedProductsBean >{
      public RelatedProductsBean process(ProductBean productBean) throws Exception {
        //Perform simple transformation, convert a ProductBean to a RelatedProductsBean
        return new RelatedProductsBean(productBean);
      }
    }
    public class ProductBeanWriter implements ItemWriter<ProductBean>{
      public void write(List<? extends ProductBean> productBeans) throws Exception {
        //write productBeans
      }
    }
    ```

    假设一个`ItemReader`接口提供了一个`ProductBean`类型的类，该类需要转换为`RelatedProductsBea`n 类型后才能被写出。可以写入一个`ItemProcessor`来执行转换。在这个非常简单的示例中，有一个类`ProductBean`、一个类`RelatedProductsBean`和一个类`ProductBeanProcessor` 与`ItemProcessor`接口相连。转换很简单，但任何类型的转换都可以在这里完成。`RelatedProductsBean`编写器将用于写出`RelatedProductsBean`对象，如果提供了任何其他类型，则抛出异常。类似地，`ProductBeanProcessor`如果提供了除`ProductBean`之外的任何内容，将抛出异常。

    然后可将`ProductBeanProcessor`注入步骤：

    ```
    <job id="ioSampleJob">
      <step name="step1">
      <tasklet>
      <chunk reader="ProductReader" processor="ProductProcessor" writer="RelatedProductsWriter" commit-interval="2"/>
      </tasklet>
      </step>
    </job>
    ```

*   `Item Writer`: This is an interface and here are its frequently used implementation classes.

    `write`方法定义了 ItemWriter 接口最基本的契约。只要打开，它就会尝试写出传入的项目列表。由于预期项目将被批处理成一个块，然后输出给定的结果，因此接口接受一个项目列表，而不是一个项目本身。一旦项目被写出来，在从`write`方法返回之前，可以进行任何必要的冲洗。例如，如果写入 Hibernate DAO，则可以对`write`进行多个调用，每个项调用一个。

    然后，编写器可以在返回之前在 hibernate 会话上调用 close。

    以下是`ItemWriter`的一个常用实现：

*   `FlatFileItemWriter`：此将数据写入文件或流。它使用缓冲写入程序来提高性能。

    ```
    StaxEventItemWriter: This is an implementation of ItemWriter that uses StAX and Marshaller for serializing objects to XML.
    ```

# 开发样本批量应用程序

既然已经介绍了批处理的基本知识和春季批处理的组成部分，那么让我们开发一个简单的示例，其中以`$$`开头的名称被认为是非素食食品，以`##`开头的名称被认为是素食食品。不以这两个字符开头的名称需要忽略。我们的工作必须生成一个 HTML 字符串，非素食食谱的字体颜色为红色，素食食谱的字体颜色为绿色。

您需要使用前面提到的依赖项创建一个名为`recipeMarker`的 Maven 项目。还要添加所有 Spring 框架核心依赖项。我们将处理`context.xml`文件。我们需要配置作业存储库和作业启动器。

查看`applicationContext.xml`文件：

```
<?xml version="1.0" encoding="UTF-8"?>
<beans 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:context="http://www.springframework.org/schema/context"
  xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
  http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd">
  <bean id="transactionManager" class="org.springframework.batch.support.transaction.ResourcelessTransactionManager"/>
  <bean id="jobLauncher" class="org.springframework.batch.core.launch.support.SimpleJobLauncher">
    <property name="jobRepository" ref="jobRepository"/>
  </bean>
  <bean id="jobRepository" class="org.springframework.batch.core.repository.support.MapJobRepositoryFactoryBean">
    <property name="transactionManager" ref="transactionManager"/>
  </bean>
  <bean id="simpleJob" class="org.springframework.batch.core.job.SimpleJob" abstract="true">
    <property name="jobRepository" ref="jobRepository" />
  </bean>
</beans>
```

您可以看到，我们已经使用`MapJobRepositoryFactoryBean`创建了一个作业存储库。它是一个使用非持久性内存**数据访问对象**（**DAO**实现自动创建`SimpleJobRepository`的`FactoryBean`。此存储库仅真正用于测试和快速原型制作。在这样的设置中，您可能会发现`ResourcelessTransactionManager`很有用（只要您的业务逻辑不使用关系数据库）。它不适合在具有拆分的多线程作业中使用，尽管在多线程步骤中使用它应该是安全的。

接下来，我们将使用`ItemReader`和`ItemWriter` 接口创建实现类。

1.  下面是`ItemReader`实现类。它读取重写的`read()`方法中的数据，该方法返回一个对象。

    ```
    package com.packt.batchjob;
    import java.util.List;
    import org.springframework.batch.item.ItemReader;
    import org.springframework.batch.item.ParseException;
    import org.springframework.batch.item.UnexpectedInputException;
    public class CustomItemReader implements ItemReader {
      private int index = 0;
      private List<String> itemList;
      public Object read() throws Exception, UnexpectedInputException,
        ParseException {
        if (index < itemList.size()) {
          String str = itemList.get(index++);
          System.out.println("Read[ " + index + " ] = " + str);
          return str;
        } else {return null;}
      }
      public List<String> getItemList() {
        return itemList;
      }
      public void setItemList(List<String> itemList) {
        this.itemList = itemList;}
    }
    ```

2.  这里有`ItemProcessor`。它应用了用红色和绿色标记配方列表的逻辑。

    ```
    package com.packt.batchjob;
    import org.springframework.batch.item.ItemProcessor;
    public class CustomItemProcessor implements ItemProcessor {
      public Object process(Object arg0) throws Exception {
        String input = (String) arg0;
        if (input.contains("$$")) {
          input = input.substring(3, input.length());
          input = "<font colour="red">(.Non-Veg)</font> " + input;
        } else if (input.contains("##")) {
        input = input.substring(3, input.length());
        input = "<font colour="green">(.Veg)</font> " + input;
        } else
        return null;
        System.out.println("Process : " + input);
        return input;
      }
    }
    ```

3.  最后，让我们编写实现类，用于从`ItemProcessor`读取修改后的数据并编写它。

    ```
    import java.util.List;
    import org.springframework.batch.item.ItemWriter;
    public class CustomItemWriter implements ItemWriter {
      public void write(List arg0) throws Exception {
        System.out.println("Write   : " + arg0 + "\n");
      }
    }
    ```

在下一步中，我们将把`ItemReader`、`ItemProcessor`和`ItemWriter`组合成一个作业。

让我们创建一个`itemreaderprocessorwriter.xml`文件。我们将传递 XML 文件中的配方列表。我们已经包括了`applicationContext.xml`文件。提交间隔被定义为写入程序在一次写入两个元素后应该提交。您还可以观察到该步骤由`reader`、`writer`和`jobRepository`组成。

```
<?xml version="1.0" encoding="UTF-8"?>
<beans 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:context="http://www.springframework.org/schema/context"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
  http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
  http://www.springframework.org/schema/context
  http://www.springframework.org/schema/context/spring-context-2.5.xsd">
  <import resource="applicationContext.xml"/>
  <bean id="customReader" class="com.packt.batchjob.CustomItemReader" >
    <property name="itemList" >
    <list>
    <value>$$Chicken65</value>
    <value>$$ChickenTikkaMasala</value>
    <value>$$GingerChicken</value>
    <value>$$GarlicChicken</value>
    <value>##Dal Makani</value>
    <value>##Stuffed Capsicum</value>
    <value>##Bendi Fry</value>
    <value>##Alo Bartha</value>
    </list>
    </property>
  </bean>
  <bean id="customProcessor" class="com.packt.batchjob.CustomItemProcessor" />
  <bean id="customWriter" class="com.packt.batchjob.CustomItemWriter" />    
  <bean id="simpleStep" class="org.springframework.batch.core.step.item.SimpleStepFactoryBean">
    <property name="transactionManager" ref="transactionManager" />
    <property name="jobRepository" ref="jobRepository" />
    <property name="itemReader" ref="customReader"/>
    <property name="itemProcessor" ref="customProcessor"/>
    <property name="itemWriter" ref="customWriter"/>
    <property name="commitInterval" value="2" />
  </bean>
  <bean id="readerWriterJob" parent="simpleJob">
    <property name="steps">
    <list>
    <ref bean="simpleStep"/>
    </list>
    </property>
  </bean>
</beans>
```

下一步是使用 SpringBatch 框架提供的命令行界面启动作业。

```
D:\SpringBatch\receipeMarker>java -classpath "lib\*;src"
org.springframework.batch.core.launch.support.CommandLineJobRunner
  itemReaderWriter.xml readerWriterJob
```

让我们创建一个名为`itemreaderprocessorwriter.xml`的文件。我们将传递 XML 文件中的配方列表。我们已包含`applicationContext.xml`文件。提交间隔被定义为写入程序在一次写入两个元素后应该提交。您还可以观察到该步骤由`reader`、`writer`和`jobRepository`组成。

```
OUTPUT:
Read[ 1 ] = $$Chicken65
Read[ 2 ] = $$ChickenTikkaMasala
Process : "<font colour="red">(.Non-Veg)</font> $$Chicken65
Process : "<font colour="red">(.Non-Veg)</font>$$ChickenTikkaMasala
Write   : [<font colour="red">(.Non-Veg)</font>$$Chicken65 , <font colour="red">(.Non-Veg)</font> $$ChickenTikkaMasala
Read[ 3 ] = $$GingerChicken
Read[ 4 ] = $$GarlicChicken
Process : "<font colour="red">(.Non-Veg)</font> $$GingerChicken
Process : "<font colour="red">(.Non-Veg)</font>$$GarlicChicken
Write   : [<font colour="red">(.Non-Veg)</font>$$GingerChicken , <font colour="red">(.Non-Veg)</font> $$GarlicChicken
Read[ 5 ] = ##Dal Makani
Read[ 6 ] = ##Stuffed Capsicum
Process : "<font colour="green">(. Veg)</font> ##Dal Makani
Process : "<font colour=" green ">(.Non-Veg)</font>##Stuffed Capsicum
Write   : [<font colour=" green ">(.Veg)</font>##Dal Makani , <font colour=" green ">(. Veg)</font> ##Stuffed Capsicum
Read[ 7 ] = ##Bendi Fry
Read[ 8 ] = ##Alo Bartha
Process : "<font colour=" green ">(. Veg)</font> ##Bendi Fry
Process : "<font colour=" green ">(. Veg)</font>##Alo Bartha
Write   : [<font colour=" green ">(. Veg)</font>##Bendi Fry , <font colour="red">(.Non-Veg)</font> ##Alo Bartha
```

## 使用 Tasklet 接口创建示例批处理应用程序

让我们创建另一个在命令行上运行的批处理应用程序。此批处理应用程序打印消息。我们在本章的开头已经谈到了 Tasklet。作业包括步骤和步骤，步骤可以是两种类型之一：块样式步骤和小任务。

本例中我们使用的是`Tasklet`接口。在 SpringBatch 中，`Tasklet`是一个被调用来执行单个任务的接口，比如在步骤执行之前或之后清理或设置资源。此接口附带一个名为`executeStatus`的方法，该方法应由实现它的类重写。

```
RepeatStatus execute(StepContribution contribution,
                     ChunkContext chunkContext)
              throws java.lang.Exception
RepeatStatus: CONTINUABLE and FINISHED
```

在下面的示例中，`TaskLetImpl`实现了`Tasklet`接口。我们还使用了`TaskLetStep`类来配置配置文件中的`JobRepository`。公共类`TaskletStep`扩展了`AbstractStep`。

`TaskletStep`是一个简单的实现，将该步骤作为对`Tasklet`的调用执行，可能会重复，并且每个调用都被一个事务包围。因此，该结构是一个循环的结构，循环内有一个事务边界。循环由步进操作（`setStepOperations(RepeatOperations)`控制。

客户端可以在步骤操作中使用拦截器在步骤范围内拦截或侦听迭代，例如，在步骤完成时获取回调。那些希望在单个任务级别进行回调的人可以为区块操作指定拦截器。

让我们通过下图来了解流程：

![Creating a sample batch application using the Tasklet interface](graphics/7320OS_04_02.jpg)

让我们创建一个名为`Chapter4-SpringBatchCommandLine`的简单 Java 批处理应用程序项目

1.  为`Chapter4-SpringBatchCommandLine`创建一个 Maven 文件夹结构，如下所示：
    *   `src`/`main`/`java`
    *   `src`/`main`/`resources`
    *   `src`/`pom.xml`
2.  创建一个名为`com.packt.example`的包。
3.  创建一个名为`TaskletImpl`的类。此类实现`Tasklet`接口并重写`execute()`方法。

    ```
    import org.springframework.batch.core.step.tasklet.Tasklet;
    import org.springframework.batch.repeat.ExitStatus;
    public class TaskletImpl implements Tasklet{
      private String message;
      public void setMessage(String message) {
        this.message = message;
      }
      public ExitStatus execute() throws Exception {
        System.out.print(message);
        return ExitStatus.FINISHED;
      }
    }
    ```

4.  配置的`simpleJob.xml`文件。
5.  将此文件放入`resources`文件夹中。
6.  您可以看到，我们已经创建了`TaskletImpl`类的三个实例：`object1`、`object2`和`object3`。
7.  在每个实例中，我们都在设置 message 属性。我们正在将对象实例传递给`TaskletStep`。

    ```
    <?xml version="1.0" encoding="UTF-8"?>
    <beans 
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://www.springframework.org/schema/beans
      http://www.springframework.org/schema/beans/spring-beans-4.0.xsd">
      <import resource="applicationContext.xml"/>

      <bean id="object1" class="com.packt.example.TaskletImpl">
        <property name="message" value="Dad not well"/>
      </bean>

      <bean id="object2" class="com.packt.example.TaskletImpl">
        <property name="message" value="Call the doctor"/>
      </bean>

      <bean id="object3" class="com.packt.example.TaskletImpl">
        <property name="message" value="He is sweating"/>
      </bean>

      <bean id="taskletStep" abstract="true" class="org.springframework.batch.core.step.tasklet.TaskletStep">
        <property name="jobRepository" ref="jobRepository"/>
      </bean>

      <bean id="simpleJob" class="org.springframework.batch.core.job.SimpleJob">
        <property name="name" value="simpleJob" />
        <property name="steps">
        <list>
        <bean parent="taskletStep">
        <property name="tasklet" ref="object1"/>
        </bean>
        <bean parent="taskletStep">
        <property name="tasklet" ref="object2"/>
        </bean>
        <bean parent="taskletStep">
        <property name="tasklet" ref="object3"/>
        </bean>
        </list>
        </property>
        <property name="jobRepository" ref="jobRepository"/>
      </bean>
    </beans>
    ```

8.  配置`jobLauncher`和`JobRepository`。

    ```
      <bean id="jobLauncher" class="org.springframework.batch.core.launch.support.SimpleJobLauncher">
        <property name="jobRepository" ref="jobRepository"/>
      </bean>
      <bean id="jobRepository" class="org.springframework.batch.core.repository.support.SimpleJobRepository">
        <constructor-arg>
          <bean class="org.springframework.batch.core.repository.dao.MapJobInstanceDao"/>
        </constructor-arg>
        <constructor-arg>
          <bean class="org.springframework.batch.core.repository.dao.MapJobExecutionDao" />
        </constructor-arg>
        <constructor-arg>
          <bean class="org.springframework.batch.core.repository.dao.MapStepExecutionDao"/>
        </constructor-arg>
      </bean>
    ```

9.  您可以使用 MVN 编译运行项目，如下所示：

    ```
    mvn clean compile exec:java -Dexec.mainClass=org.springframework.batch.core.launch.support.CommandLineJobRunner -Dexec.args="simpleJob.xml simpleJob"
    OUTPUT:
    Dad not well
    Call the Doctor
    He is sweating

    ```

## 使用 Spring 批处理读取 CSV 文件

让我们创建另一个批处理应用程序，从目录中读取 CSV 文件，并使用`commandlinerunner`运行作业。输出同样是一个 CSV 文件，可在`output`文件夹中使用。

这个例子展示了 Spring 批处理框架中可用的`ItemWriter`和`ItemReader`实现的各种选项。我们在这里使用了 Spring 框架中可用的`flatFileItemReader`和`flatFileItemWriter`实现。

我们将从应用程序开发开始，并检查这些`ItemReader`实现类是如何使用的。

1.  使用 Maven 创建 SpringJava 应用程序，并将其命名为`SpringBatchCommandLine-Chapter4Example2`。
2.  创建一个域类`Employee`，其中包含两个实例变量`empId`和`name`，其中包含 getter 和 setter:

    ```
    package com.packt;
    public class Employee {

      int empId;
      String name;
      public int getEmpId() {
        return empId;
      }
      public void setEmpId(int empId) {
        this.empId = empId;
      }
      public String getName() {
        return name;
      }
      public void setName(String name) {
        this.name = name;
      }
    }
    ```

3.  使用`ItemWriter`接口，实现`CustomeItemWriter`类。此类重写在`ItemWriter`接口中定义的`write`方法。
4.  您将观察到`write`方法接受`List`作为输入。在`write`方法中，我们只是解析列表并将列表索引值类型转换为`Employee`对象并打印它。

    ```
    package com.packt;
    import java.util.List;
    import org.springframework.batch.item.ItemWriter;
    public class CustomItemWriter<T> implements ItemWriter<T> {
      @Override
      public void write(List<? extends T> items) throws Exception {
        for (int i = 0; items.size() > i; i++) {
          Employee obj = (Employee) items.get(i);
          System.out.println(obj.getEmpId() + ":" + obj.getName());
        }

      }

    }
    ```

5.  使用`jobrun()`方法

    ```
    public class Main {
      public static void main(String[] args) {
        Main obj = new Main();
        obj.run();
      }

      private void run() {
        /*config files are present in the resource folder*/
        String[] springConfig = { "spring/batch/config/context.xml", "spring/batch/jobs/job-read-files.xml" };

        ApplicationContext context = new ClassPathXmlApplicationContext(springConfig);

        JobLauncher jobLauncher = (JobLauncher) context.getBean("jobLauncher");
        Job job = (Job) context.getBean("readMultiFileJob");
        try {
          JobExecution execution = jobLauncher.run(job, new JobParameters());
          System.out.println("Exit Status : " + execution.getStatus());
          System.out.println("Exit Status : " + execution.getAllFailureExceptions());

        } catch (Exception e) {
          e.printStackTrace();

        }

        System.out.println("COMPLETED");

      }
    }
    /*config files are present in the resource folder*/
    ```

    创建一个具有`public static void main()`的`Main`类
6.  让我们将`context.xml`文件中的`bean id`设置为`JobRepository`：

    ```
    <bean id="jobRepository" class="org.springframework.batch.core.repository.support.MapJobRepositoryFactoryBean">
      <property name="transactionManager" ref="transactionManager" />
    </bean>

    <bean id="transactionManager" class="org.springframework.batch.support.transaction.ResourcelessTransactionManager" />

    <bean id="jobLauncher" class="org.springframework.batch.core.launch.support.SimpleJobLauncher">
    <property name="jobRepository" ref="jobRepository" />
    </bean>

    /*
    ```

资源文件夹`*/Job Read files.xml`中存在 `Job Read files.xml`文件。

我们使用了`flatfileItemReader`和`FlatFileItemWriter`。这些类读取输入并重新创建`output`文件夹中的文件。

让我们看看`FlatFileItemReader`的原型，了解它在应用程序中的作用：

```
public class FlatFileItemReader<T> extends AbstractItemCountingItemStreamItemReader<T>
implements ResourceAwareItemReaderItemStream<T>, org.springframework.beans.factory.InitializingBean
```

可重启`ItemReader`从输入`setResource(Resource)`读取行。行由`setRecordSeparatorPolicy(RecordSeparatorPolicy)`定义，并使用`setLineMapper(LineMapper)`映射到项目。

如果在行映射过程中抛出了一个异常，它将作为`FlatFileParseException`重新抛出，并添加有关问题行及其行号的信息。

```
public class FlatFileItemWriter<T>
extends AbstractItemStreamItemWriter<T>
implements ResourceAwareItemWriterItemStream<T>, org.springframework.beans.factory.InitializingBean
```

此类是将数据写入文件或流的项目编写器。写入程序还提供重新启动。输出文件的位置由资源定义，必须表示可写文件，并使用缓冲写入器提高性能。该实现不是线程安全的。

在该文件中，我们完成了以下操作：

*   我们已使用名称`readMultiFileJob`配置作业
*   我们必须注意到`tasklet`有一个配置了`ItemReader`和`ItemWriter`类的步骤
*   我们再次使用了`tasklet`，但我们将 step 用作接受`MultiResourceReader`的块读取器

为了理解`MultiResourceReader`，我们将看看原型：

```
public class MultiResourceItemReader<T>extends AbstractItemStreamItemReader<T>
```

`MultiResourceReader`按顺序从多个资源中读取项目。资源列表由`setResources(Resource[])`给出，实际读取委托给`setDelegate(ResourceAwareItemReaderItemStream)`。使用`setComparator(Comparator)`对输入资源进行排序，以确保在重启场景中作业运行之间保持资源排序。

现在，让我们看看 chunk 类型的步骤是关于什么的。在块中，读写器是必需的！但是，`ItemProcessor`是可选的。

```
<import resource="../config/context.xml"/>
  <bean id="employee" class="com.packt.Employee" />
  <job id="readMultiFileJob" >

    <step id="step1">
    <tasklet>
    <chunk reader="multiResourceReader" writer="flatFileItemWriter" commit-interval="1" />
    </tasklet>
    </step>

  </job>
<! --create folder structure in the project root csv/inputsand add the csv files-->
  <bean id="multiResourceReader"class=" org.springframework.batch.item.file.MultiResourceItemReader">
    <property name="resources" value="file:csv/inputs/employee-*.csv" /> 
    <property name="delegate" ref="flatFileItemReader" />
  </bean>

  <bean id="flatFileItemReader" class="org.springframework.batch.item.file.FlatFileItemReader">

    <property name="lineMapper">
    <bean class="org.springframework.batch.item.file.mapping.DefaultLineMapper">

      <property name="lineTokenizer">
      <bean class="org.springframework.batch.item.file.transform.DelimitedLineTokenizer">
        <property name="names" value="id, name" />
      </bean>
      </property>
      <property name="fieldSetMapper">
      <bean class="org.springframework.batch.item.file.mapping.BeanWrapperFieldSetMapper">
        <property name="prototypeBeanName" value="domain" />
      </bean>
      </property>
    </bean>
    </property>

  </bean>

  <bean id="flatFileItemWriter" class="org.springframework.batch.item.file.FlatFileItemWriter" >
    <!--create folder structure in the project root csv/outputs -->

    <property name="resource" value="file:csv/outputs/employee.all.csv" /> 
    <property name="appendAllowed" value="true" />
    <property name="lineAggregator">
    <bean class="org.springframework.batch.item.file.transform.DelimitedLineAggregator">
      <property name="delimiter" value="," />
      <property name="fieldExtractor">
      <bean class="org.springframework.batch.item.file.transform.BeanWrapperFieldExtractor">
        <property name="names" value="id, domain" />
      </bean>
      </property>
    </bean>
    </property>

  </bean> 
```

创建一个名为`employee*.csv`的几个 CSV 文件，用不同的编号替换的`*`。每个文件将有两个值：`employeeId`和`name`。

CSV 文件中的分隔符也可以在 XML 中配置，如以下代码所示：

```
<bean class="org.springframework.batch.item.file.transform.DelimitedLineAggregator">
  <property name="delimiter" value="," />
  <property name="fieldExtractor">
  <bean class="org.springframework.batch.item.file.transform.BeanWrapperFieldExtractor">
    <property name="names" value="id, domain" />
  </bean>
  </property>
```

这些值将映射到一个**普通旧 java 对象**（**Pojo**）、`Employee.java`，并处理输出。文件位置作为输入传递给`MultiResourceItemReader`类。

在下一节中，我们将了解如何在春季安排批处理作业。

## 带 Spring 调度程序的 Spring 批处理

在部分中，让我们看看如何在 Spring 批处理框架中安排批处理。我们将看看如何配置调度程序。这是一个样本`jobproduct.xml`文件，需要在类路径中可用。如果您正在处理 Maven 项目，请将其放在资源文件夹中。您需要在`joblauncher`中注入间隔和方法名称`run()`，以便在计划的时间运行作业。

要使用调度程序，我们需要配置`job-product.xml`文件。在下一节中，还将使用此文件配置外部计划程序，并提供计划程序详细信息。

要计划每 600 秒运行一次任务，请执行以下操作：

```
<task:scheduled-tasks>
  <task:scheduled ref="MyJobScheduler" method="run" cron="*/600 * * * * *" />
</task:scheduled-tasks>
```

让我们将`@Component`和`@Autowired`注释与`MyJobScheduler.class`一起使用。

```
@Component
public class MyJobScheduler {
  @Autowired
  private JobLauncher jobLauncher;
  @Autowired
  private Job job;
  public void run() {
    try {
      String dateParam = new Date().toString();
      JobParameters param = new JobParametersBuilder().addString("date", dateParam).toJobParameters();
      JobExecution execution = jobLauncher.run(job, param);
      System.out.println("Exit Status  of the Job: " + execution.getStatus());

    } catch (Exception e) {
    e.printStackTrace();
    }

  }
}
```

## 使用石英调度器配置 Spring 批处理

Spring 批处理框架提供了一个选项，用于在应用程序中配置外部调度程序。

让我们将 Quartz 调度器与 Spring 批处理应用程序集成。Quartz 是一个基于 Java 的开源调度器。我们将使此应用程序读取文件，但我们将集成 Quartz 调度程序来执行调度。

1.  创建一个名为`SpringBatchQuartzExample`的简单 Maven 应用程序。
2.  使用与上一个应用程序中相同的`pom.xml`文件。
3.  将 Quartz JAR 文件添加到`pom.xml`文件中的依赖项中。
4.  添加这些属性：

    ```
    <quartz.version>1.8.6</quartz.version>
    ```

5.  然后，添加这些依赖项：

    ```
    <dependency>
      <groupId>org.quartz-scheduler</groupId>
      <artifactId>quartz</artifactId>
      <version>${quartz.version}</version>
    </dependency>
    ```

让我们创建一个名为`quartz-job.xml`的文件。这应该存在于 Maven 项目的资源文件夹中。要将批处理配置为每分钟运行，请在代码中使用以下配置：

```
<bean class="org.springframework.scheduling.quartz.SchedulerFactoryBean">
  <property name="triggers">
  <bean id="cronTrigger" class="org.springframework.scheduling.quartz.CronTriggerBean">
  <property name="jobDetail" ref="jobDetail" />
  <property name="cronExpression" value="*/60 * * * * ?" />
  </bean>
  </property>
</bean>
```

要将 Spring Batch 与 Quartz Scheduler 集成，请使用以下代码：

```
<bean id="jobDetailBean" class="org.springframework.scheduling.quartz.JobDetailBean">
  <property name=" jobQuartzLauncherDetails " value="com.packt.quartz.JobQuartzLauncherDetails" />
  <property name="group" value="quartz-batch" />
  <property name="jobDataAsMap">
  <map>
    <entry key="jobName" value="reportJob" />
    <entry key="jobLocator" value-ref="jobRegistry" />
    <entry key="jobLauncher" value-ref="jobLauncher" />
    <entry key="param1" value="anjana" />
    <entry key="param2" value="raghu" />
  </map>
  </property>
</bean>
```

`JobQuartzLauncherDetails`是一个扩展`QuartzJobBean`的 bean。

### 提示

`QuartzJobBean`在包装中提供，可在`org.springframework.scheduling.quartz.QuartzJobBean`找到。

类有`JobLauncher`和`JobLocator`的设置器：

```
public class JobQuartzLauncherDetails extends QuartzJobBean {
  static final String JOB_NAME = "jobName";
  private JobLocator jobLocator;
  private JobLauncher jobLauncher;
  public void setJobLocator(JobLocator jobLocator) {
    this.jobLocator = jobLocator;
  }
  public void setJobLauncher(JobLauncher jobLauncher) {
    this.jobLauncher = jobLauncher;
  }
```

为了从配置中读取`JobMapDetails`，我们创建了另一个方法，如下代码所示。我们可以看到，根据从映射中读取的值在这里处理不同的数据类型，并创建了`JobParametersBuilder`。

```
private JobParameters getJobParametersFromJobMap(Map<String, Object> jobDataMap) {
  JobParametersBuilder builder = new JobParametersBuilder();
  for (Entry<String, Object> entry : jobDataMap.entrySet()) {
    String key = entry.getKey();
    Object value = entry.getValue();
    if (value instanceof String && !key.equals(JOB_NAME)) {
      builder.addString(key, (String) value);
    } else if (value instanceof Float || value instanceof Double){
      builder.addDouble(key, ((Number) value).doubleValue());
    } else if (value instanceof Integer || value instanceof Long){
      builder.addLong(key, ((Number) value).longValue());
    } else if (value instanceof Date) {
      builder.addDate(key, (Date) value);
    } else {

    }
  }

  builder.addDate("run date", new Date());
  return builder.toJobParameters();
}
```

我们知道，`JobName`和`JobParamters`是`JobLauncher`运行作业所需的输入。在前面的代码片段中，我们得到了`JobParameters`。接下来，我们将使用`JobExecutionContext`获得`JobName`和的以下代码片段：

```
protected void executeInternal(JobExecutionContext context) {
  Map<String, Object> jobDataMap = context.getMergedJobDataMap();
  String jobName = (String) jobDataMap.get(JOB_NAME);
  JobParameters jobParameters = getJobParametersFromJobMap(jobDataMap);

  try {
    jobLauncher.run(jobLocator.getJob(jobName), jobParameters);
  } catch (JobExecutionException e) {
    e.printStackTrace();
  }
}
```

`Product.java`是映射到`.csv`文件中的值的域类。

```
public class Product {
  private int id;
  private String name;
  public int getId() {
    return id;
  }
  public void setId(int id) {
    this.id = id;
  }
  public String getName() {
    return name;
  }
  public void setName(String name) {
    name = name;
  }
  @Override
  public String toString() {
    return "Product [id=" + id + ", name=" + name + "]";
  }
}
```

以下是写入产品 Pojo 对象值的`CustomeItemWriter`代码。

```
public class CustomItemWriter implements ItemWriter<Product> {
  @Override
  public void write(List<? extends Product> items) throws Exception {
    System.out.println("writer..." + items.size());
    for(Product item : items){
      System.out.println(item);
    }
  }
}
```

接下来，我们创建`Main`类来加载`job-quartz.xml`文件，并每 60 秒运行一次批处理作业，以读取 CSV 文件并使用`CustomItemWriter`写入。

```
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class Main {
  public static void main(String[] args) {
    String springConfig = "spring/batch/jobs/job-quartz.xml";
    ApplicationContext context = new ClassPathXmlApplicationContext(springConfig);
  }
}
```

Spring 批处理框架使用 Quartz Scheduler 运行批处理作业，读取文件，将 CSV 值映射到产品 Pojo，然后使用`CustomeItemWriter`写入。

在下一节中，让我们创建一个批处理来读取文件并更新数据库。

## 使用 Spring 批处理读取文件并更新 MongoDB 数据库

在部分中，让我们创建一个批处理作业，读取 XML 文件并写入 MongoDB 数据库。设想这样一个场景：我们不断从源代码获取一个 XML 文件，该文件需要读取并更新到数据库。

1.  XML 文件结构如下图所示：

    ```
    <?xml version="1.0" encoding="UTF-8" ?>
    <Products>
      <product id="1">
        <categoryId>3</categoryId>
        <brandId>1</brandId>
        <name>computer</name>
        <price>15000</price>
      </product>
      <product id="2">
      <categoryId>4</categoryId>
      <brandId>1</brandId>
      <name>mouse</name>
      <price>250</price>
      </record>
      </ product>
      < product id="3">
        <categoryId>5</categoryId>
        <brandId>1</brandId>
        <name>mouse</name>
        <price>23000</price>
      </ product>
    </Products>
    ```

2.  创建一个基于 Java 的 Maven 项目。在的`com.packt.model`包装中，添加相应的产品 Pojo。

    ```
    public class Product {
      private int id;
      private int categoryId;
      private int brandId;
      private String name;
      private int price;
      public int getId() {
        return id;
      }
      public void setId(int id) {
        this.id = id;
      }
      public int getCategoryId() {
        return categoryId;
      }
      public void setCategoryId(int categoryId) {
        this.categoryId = categoryId;
      }
      public int getBrandId() {
        return brandId;
      }
      public void setBrandId(int brandId) {
        this.brandId = brandId;
      }
      public String getName() {
        return name;
      }
      public void setName(String name) {
        this.name = name;
      }
      public int getPrice() {
        return price;
      }
      public void setPrice(int price) {
        this.price = price;
      }

    }
    ```

3.  添加与上一节中显示的相同的依赖项。
4.  更新`pom.xml`文件。
5.  添加 ORM 和 MongoDB 数据库依赖项：

    ```
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-oxm</artifactId>
      <version>${spring.version}</version>
    </dependency>
    <dependency>
      <groupId>org.mongodb</groupId>
      <artifactId>mongo-java-driver</artifactId>
      <version>${mongodb.driver.version}</version>
    </dependency>

      <!-- Spring data mongodb -->
    <dependency>
      <groupId>org.springframework.data</groupId>
      <artifactId>spring-data-mongodb</artifactId>
      <version>${spring.data.version}</version>
    </dependency>
    ```

6.  创建一个名为`mongodatabase.xml`的文件，并添加以下配置：

    ```
      <mongo:mongo host="127.0.0.1" port="27017" />
      <mongo:db-factory dbname="eshopdb" />

      <bean id="mongoTemplate" class="org.springframework.data.mongodb.core.MongoTemplate">
      <constructor-arg name="mongoDbFactory" ref="mongoDbFactory" />
      </bean>
    ```

7.  将以下配置添加到`job-product.xml`文件中。
    *   `StaxEventItemReader`：这是一个读取`products.xml`文件的类。我们需要为这个类提供`rootElemenent`名称。
    *   `fragmentRootElementName`：此属性接受字符串参数，该参数是提供的 XML 文件中的根元素。

我们还需要提供 XML 文件名作为资源属性的值。需要传递的第三个属性是`unmarshaller`引用。该类在 Spring OXM 框架中可用，该框架用于编组和解编组 XML 文件。

```
<bean id="xmlItemReader" class="org.springframework.batch.item.xml.StaxEventItemReader">
  <property name="fragmentRootElementName" value="product" />
  <property name="resource" value="classpath:xml/product.xml" />
  <property name="unmarshaller" ref="productUnmarshaller" />
</bean>
```

`XstreamMarshaller`接受三个属性来执行解组过程。它接受一个带有 entry key 和 product Pojo 作为值的映射，因此在 XML 中，每个产品记录都转换为一个`Product`对象并存储在映射中。第二个属性也是一个创建的 bean，用于将 XML 转换为 POJO。这被命名为`ProductXMLConverter`。

```
<bean id="productUnmarshaller" class="org.springframework.oxm.xstream.XStreamMarshaller">

  <property name="aliases">
  <util:map id="aliases">
  <entry key="product" value="com.packt.model.Product" />
  </util:map>
  </property>
  <property name="converters">
  <array>
  <ref bean="productXMLConverter" />
  </array>
  </property>
</bean>

<bean id="productXMLConverter" class="com.packt.converter. ProductXMLConverter>	
```

让我们看看`ProductXMLConverter`课程。此类实现了`com.thoughtworks.xstream.converters.converter`包中提供的`converter`接口。该类重写接口中定义的三个方法：

*   `public boolean canConvert(Class type)`
*   `public void marshal(Object source, HierarchicalStreamWriter writer, MarshallingContext context)`
*   `public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context)`

1.  由于我们将在这里进行解组，因此我们将明确实施`unmarshall`方法。

    ```
    @Override
    public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) {
      Product obj = new Product();
      obj.setId(Integer.valueOf(reader.getAttribute("id")));
      reader.moveDown(); //get id
      obj.setCategoryId(Integer.valueOf(reader.getAttribute("categoryId")));
      reader.moveDown(); //get categoryId
      obj.setBrandId(Integer.valueOf(reader.getAttribute("brandId")));
      reader.moveDown(); //get brandId
      obj.setName(String.valueOf(reader.getAttribute("name")));
      reader.moveDown(); //get name
      obj.setPrice(Integer.valueOf(reader.getAttribute("price")));
      reader.moveDown(); //get name
      return obj;
    }
    ```

2.  配置`MongoDBItemWriter`写入`job-product.xml`：

    ```
    <bean id="mongodbItemWriter" class="org.springframework.batch.item.data.MongoItemWriter">
      <property name="template" ref="mongoTemplate" />
      <property name="collection" value="product" />
    </bean>
    ```

    中 MongoDB 数据库中的 Pojo 对象
3.  在`job-product.xml`文件

    ```
    <batch:job id="productJob">
      <batch:step id="step1">
      <batch:tasklet>
      <batch:chunk reader="xmlItemReader" writer="mongodbItemWriter" commit-interval="1">
      </batch:chunk>
      </batch:tasklet>
      </batch:step>
    </batch:job>
    ```

    中配置批量作业
4.  编写`Main`类来运行批处理作业。
5.  加载`Main`类中的所有配置文件：

    ```
    public class Main {
      public static void main(String[] args) {
        String[] springConfig  = {"spring/batch/config/mongodatabase.xml", "spring/batch/config/context.xml", "spring/batch/jobs/job-product.xml" 
      };

      ApplicationContext context = new ClassPathXmlApplicationContext(springConfig);

      JobLauncher jobLauncher = (JobLauncher) context.getBean("jobLauncher");
      Job job = (Job) context.getBean("productJob");

      try {

        JobExecution execution = jobLauncher.run(job, new JobParameters());
        System.out.println("Exit Status of the ProductJOB: " + execution.getStatus());

        } catch (Exception e) {
          e.printStackTrace();
        }

        System.out.println("YES COMPLETED");

      }
    }
    ```

因此，当我们运行`Main`类时，作业将被实例化，并将每 60 秒运行一次。作业将读取 XML 并将其转换为 Pojo`product.java`，然后将其插入 MongoDB 数据库。配置在 MongoDB 数据库 XML 文件中给出。

在下一节中，我们将看到如何创建一个多线程环境来处理多个作业。

## 使用带线程的 Spring 批处理对作业进行分区

在 Spring 批处理过程中，单个线程按顺序处理请求。如果我们想并行执行批处理作业，我们就使用多线程环境。

想象一下这样一个场景：我们正在处理一个用`Employee`Pojo 映射的 employee 表中的 1000 条记录。我们需要一次读取 1000 条记录并写入 CSV 文件。

一个作业实际上被分成多个子对象，并分配一个单独的线程来处理每个子对象。因此，如果您要读取 1000 条记录，那么使用单个线程执行此操作将花费更多时间。当我们将 1000 条记录划分为 100 个子记录时，我们可以使用同时运行的 10 个不同线程来处理它们。

我们可以通过实现`Partitioner`接口来创建一个简单的分区器类。此分区器将 1000 个作业划分为 100 个子对象。您将看到，我们在分区范围中提供了`start_range`和`end_range`变量。

```
public class MyJobPartioner implements Partitioner {
  @Override
  public Map<String, ExecutionContext> partition(int gridSize) {
    Map<String, ExecutionContext> result = new HashMap<String, ExecutionContext>();
    int range = 100;
    int start_range = 1;
    int end_range = range;
    for (int i = 1; i <= gridSize; i++) {
      ExecutionContext execution_context = new ExecutionContext();
      System.out.println("\Name: Thread" + i+"start_range : " + start_range+"end_range", end_range);
      execution_context.putInt("start_range", start_range);
      execution_context.putInt("end_range", end_range);
      execution_context.putString("name", "Thread" + i);
      result.put("partition" + i, execution_context);
      start_range = end_range + 1;
      end_range += range;
    }
    return result;
  }

}
```

`Partitioner`类中使用的`ExecutionContext`对象与`ItemStream`一起工作，就像是地图的包装器。我们可以在 SpringBatch 中获得两种执行上下文对象。一个执行对象在作业级别工作，另一个在步骤级别工作。作业级执行上下文用于在步骤之间共享数据或信息。

让我们实现一个处理分区记录的`ItemProcess`类。还要注意，我们在下面的代码中使用了步骤执行上下文。该类重写了`process`方法。

1.  此类用于数据块处理。

    ```
    @Component("itemProcessor")
    @Scope(value = "step")
    public class EmployeeProcessor implements ItemProcessor<Employee, Employee> {
      @Value("#{stepExecutionContext[name]}")
      private String threadName;
      @Override
      public Employee process(Employee emp) throws Exception {
        System.out.println(threadName + " processing : " + emp.getId() + " : " + emp.getName());
        return emp;
      }
      public String getThreadName() {
        return threadName;
      }
      public void setThreadName(String threadName) {
        this.threadName = threadName;
      }

    }
    ```

2.  Let's configure the `job-partioner.xml` file.

    ```
    <job id="partitionJob" >
      <step id="masterStep">
      <partition step="slave" partitioner="myJobPartioner">
      <handler grid-size="100" task-executor="taskExecutor" />
      </partition>
      </step>

    </job>
    <step id="slave" >
      <tasklet>
      <chunk reader="pagingItemReader" writer="flatFileItemWriter"
      processor="itemProcessor" commit-interval="1" />
      </tasklet>
    </step>

    <!—below is the configuration of MyJobPartioner bean-->

    <bean id="myJobPartioner" class="com.packt.partition.MyJobPartioner" />
    <bean id="taskExecutor" class="org.springframework.core.task.SimpleAsyncTaskExecutor" />

    <!—below is the configuration of EmployeeProcesser bean-->

    <bean id="itemProcessor" class="com.packt.processor.EmployeeProcessor" scope="step">
      <property name="threadName" value="#{stepExecutionContext[name]}" />
    </bean>
    ```

    接下来，让我们配置`pagingItemReader`，其作用与分页相同。它每页获取 100 条记录；这还使用提供的 JDBC 信息连接到数据源，并执行查询以获取指定的记录范围。它还将根据`emp_id`列对数据进行排序。

    ```
    <bean id="pagingItemReader" class="org.springframework.batch.item.database.JdbcPagingItemReader"scope="step">
      <property name="dataSource" ref="dataSource" />
      <property name="queryProvider">
      <bean class="org.springframework.batch.item.database.support.SqlPagingQueryProviderFactoryBean">
        <property name="dataSource" ref="dataSource" />
        <property name="selectClause" value="select emp_id, emp_name, emp_pass, emp_salary" />
        <property name="fromClause" value="from users" />
        <property name="whereClause" value="where emp_id &gt;= :fromId and id &lt;= :toId" />
        <property name="sortKey" value="emp_id" />
      </bean>
      </property>
     <!-- Inject via the ExecutionContext in MyJobPartioner -->
      <property name="parameterValues">
      <map>
        <entry key="fromId" value="#{stepExecutionContext[start_range]}" />
        <entry key="toId" value="#{stepExecutionContext[end_range]}" />
      </map>
      </property>
      <property name="pageSize" value="100" />
      <property name="rowMapper">
      <bean class="com.packt.EmployeeRowMapper" />
      </property>
      </bean>

    <!--After reading it writes to  csv file using FlatfileItemwriter class-->

      <bean id="flatFileItemWriter" class="org.springframework.batch.item.file.FlatFileItemWriter" scope="step" >
        <property name="resource"
        value="file:csv/outputs/employee.processed#{stepExecutionContext[fromId]}-#{stepExecutionContext[toId]}.csv" />
        <property name="appendAllowed" value="false" />
        <property name="lineAggregator">
        <bean class="org.springframework.batch.item.file.transform.DelimitedLineAggregator">
          <property name="delimiter" value="," />
          <property name="fieldExtractor">
          <bean class="org.springframework.batch.item.file.transform.BeanWrapperFieldExtractor">
            <property name="names" value="emp_id, emp_name, emp_pass, emp_salary" />
          </bean>
          </property>
        </bean>
        </property>
      </bean>
    <!--Configuring FlatfileItemwriter class- ends-->
    ```

3.  让我们编写`Main`类，它将加载配置文件，然后运行作业。

    ```
    public class Main {
      public static void main(String[] args) {
        Main obj = new Main();
        obj.run();
      }
      private void run() {
        String[] springConfig = { "spring/batch/jobs/job-partitioner.xml" };
        ApplicationContext context = new ClassPathXmlApplicationContext(springConfig);
        JobLauncher jobLauncher = (JobLauncher) context.getBean("jobLauncher");
        Job job = (Job) context.getBean("partitionJob");
        try {
          JobExecution execution = jobLauncher.run(job, new JobParameters());
          System.out.println("Exit Status : " + execution.getStatus());
          System.out.println("Exit Status : " + execution.getAllFailureExceptions());
        } catch (Exception e) {
          e.printStackTrace();
        }
        System.out.println("COMPLETED");
      }

    }
    ```

因此，通过前面的配置和类，可以创建多个线程，每个线程处理 100 条记录。记录从数据库中读取并写入 CSV 文件。

在下一节中，我们将在 Spring 批处理中使用事件侦听器。

# 使用侦听器拦截 Spring 批处理作业

Spring 批次随听众而来。它们拦截作业执行以执行某些任务。`StepListener`是一门`super`课程，供下列听众使用：

*   `SkipListener`：`SkipListener`最常见的用例之一是注销跳过的项目，以便使用另一个批处理过程，甚至是人工过程来评估和修复导致跳过的问题。因为在许多情况下原始事务可能会回滚，Spring Batch 提供了两个保证：
    *   每个项目只调用一次相应的`skip`方法（取决于错误发生的时间）。
    *   `SkipListener`总是在事务提交之前被调用。这是为了确保侦听器调用的任何事务性资源不会因`ItemWriter`内的故障而回滚。
*   `ChunkListener`：这些监听器可以配置一个步骤，如果步骤类型为 chunk-styled-step，则该步骤将同时具有`ItemReader`和`ItemWriter`。当`ItemReader`完成阅读任务后，听者会与`ItemWriter`亲密接触。

    ```
    public interface ChunkListener extends StepListener {
      void beforeChunk();
      void afterChunk();
    }
    <step id="step1">
      <tasklet>
      <chunk reader="reader" writer="writer" commit-interval="10"/>
      <listeners>
        <listener ref="chunkListener"/>
      </listeners>
      </tasklet>
    </step>
    ```

*   `ItemWriterListener`
*   `ItemReaderListener`
*   `ItemProcessListener`
*   `StepExecutionListener`：代表步骤执行最通用的监听器。它允许在步骤开始之前和结束之后发出通知，无论步骤是否正常结束。

您将看到为`ItemReader`、`ItemWriter`、`ItemProcess`和`StepExecution`接口和类中的每一个配置了侦听器。

现在我们可以看看如何在 spring`batch.xml`文件中配置侦听器。请看一看：

1.  创建实现侦听器并重写其方法的类。

    ```
    <bean id="packtStepListener" class="com.packt.listeners.PacktStepListener" />
    <bean id="packtItemReaderListener" class="com.packt.listeners.PacktItemReaderListener" />
    <bean id="packtItemWriterListener" class="com.packt.listeners.PacktItemWriterListener" />

    <job id="readFileJob" >
      <step id="step1">
      <tasklet>
      <chunk reader="multiResourceReader" writer="flatFileItemWriter" commit-interval="1" />
      <listeners>
        <listener ref="packtStepListener" />
        <listener ref="packtItemReaderListener" />
        <listener ref="packtItemWriterListener" />
      </listeners>
      </tasklet>
      </step>
    </job>
    ```

2.  让我们看看`PacktItemReaderListener`和`PacktItemWriterListner` 的听众。`IteamReadListener`接口有三种实现方式：
    *   `beforeRead()`
    *   `afterRead()`
    *   `onReadError()`

        ```
        public class PacktItemReaderListener implements ItemReadListener<Product> {

          @Override
          public void beforeRead() {
            System.out.println("ItemReadListener - beforeRead");
          }

          @Override
          public void afterRead(Product product) {
            System.out.println("ItemReadListener - afterRead");
          }

          @Override
          public void onReadError(Exception ex) {
            System.out.println("ItemReadListener - onReadError");
          }

        }
        ```

3.  下面我们来看一节`PackItemWriterListener`。`ItemWriter`接口有三种`abstract`方式：
    *   `beforeWrite`
    *   `afterWrite`
    *   `onWriteError`

        ```
        public class PacktItemWriterListener implements ItemWriteListener<Product> {
          @Override
          public void beforeWrite(List<? extends Product> products) {
            System.out.println("ItemWriteListener - beforeWrite");
          }
          @Override
          public void afterWrite(List<? extends Product> products) {
            System.out.println("ItemWriteListener - afterWrite");
          }
          @Override
          public void onWriteError(Exception exception, List<? extends Product> products) {
            System.out.println("ItemWriteListener - onWriteError");
          }
        }
        ```

到目前为止，我们已经看到了如何在`spring-job`文件中创建自定义侦听器和侦听器配置。

现在，让我们尝试将其与一个场景结合起来，在这个场景中，我们正在读取目录中的多个文件并删除这些文件。

1.  我们将再次考虑产品波霍，以 AutoT0 和 Ty1 T1 作为实例变量与吸气剂和定位器。

    ```
    public class Product {
      int id;
      String name;
      public int getId() {
        return id;
      }
      public void setId(int id) {
        this.id = id;
      }
      public String getName() {
        return name;
      }
      public void setName(String Name) {
        this.name = name;
      }
    }
    ```

2.  我们需要将 XML 中的 Pojo 定义为 bean。

    ```
      <bean id="product" class="com.packt.Product" />
    ```

3.  接下来是文件删除任务类文件。读取文件后，需要将其从目录中删除。

    ```
    <bean id="fileDeletingTasklet" class="com.packt.tasklet.FileDeletingTasklet" >
      <property name="directory" value="file:csv/inputs/" />
    </bean>
    ```

4.  让我们看看`FileDeletingTasklet`课程。此类实现了`TaskLet`接口。这将根据指定目录删除文件。

    ```
    public class FileDeletingTasklet implements Tasklet, InitializingBean {
      private Resource directory;
      @Override
      public void afterPropertiesSet() throws Exception {
        Assert.notNull(directory, "directory must be set");
      }

      @Override
      public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {
        File dir = directory.getFile();
        Assert.state(dir.isDirectory());
        File[] files = dir.listFiles();
        for (int i = 0; i < files.length; i++) {
          boolean deleted = files[i].delete();
          if (!deleted) {
            throw new UnexpectedJobExecutionException("Could not delete file " + files[i].getPath());
          } else {
            System.out.println(files[i].getPath() + " is deleted!");
          }
        }
        return RepeatStatus.FINISHED;
      }
      public Resource getDirectory() {
        return directory;
      }
      public void setDirectory(Resource directory) {
        this.directory = directory;
      }
    }
    ```

5.  需要在创建的作业配置文件中设置 bean 属性。

    ```
    <bean id="fileDeletingTasklet" class="com.packt.tasklet.FileDeletingTasklet" >
      <property name="directory" value="file:csv/inputs/" />
    </bean>
    ```

下一个任务是读取目录中的多个可用文件。由于需要读取多个资源，我们将在 bean 中使用`MultiResourceReader`配置。

```
<bean id="multiResourceReader" class=" org.springframework.batch.item.file.MultiResourceItemReader">
  <property name="resources" value="file:csv/inputs/product-*.csv" />
  <property name="delegate" ref="flatFileItemReader" />
</bean>
```

`flatfileItemReader`将 CSV 值映射到产品 Pojo。因此，为`jobs.xml`文件提供以下配置：

```
<bean id="flatFileItemReader" class="org.springframework.batch.item.file.FlatFileItemReader">
  <property name="lineMapper">
  <bean class="org.springframework.batch.item.file.mapping.DefaultLineMapper">
    <property name="lineTokenizer">
    <bean class="org.springframework.batch.item.file.transform.DelimitedLineTokenizer">
      <property name="names" value="id, name" />
    </bean>
    </property>
    <property name="fieldSetMapper">
    <bean class="org.springframework.batch.item.file.mapping.BeanWrapperFieldSetMapper">
      <property name="prototypeBeanName" value="product" />
    </bean>
    </property>
  </bean>
  </property>

</bean>
```

然后，在读取 CSV 值并将它们从不同的 CSV 文件映射到 Pojo 后，如果需要合并到单个 CSV 文件中，我们可以添加`writterListener`。

```
<bean id="flatFileItemWriter" class="org.springframework.batch.item.file.FlatFileItemWriter">
  <property name="resource" value="file:csv/outputs/product.all.csv" />
  <property name="appendAllowed" value="true" />
  <property name="lineAggregator">
  <bean class="org.springframework.batch.item.file.transform.DelimitedLineAggregator">
    <property name="delimiter" value="," />
    <property name="fieldExtractor">
    <bean class="org.springframework.batch.item.file.transform.BeanWrapperFieldExtractor">
      <property name="names" value="id, name" />
    </bean>
    </property>
  </bean>
  </property>

</bean>
```

在类中，为运行`Main`的所有作业配置了【XML】bean。作业使用`ItemReader`和`Writer`执行区块，如这里`Main`类的配置所示：

```
public class Main {
  public static void main(String[] args) {
    Main obj = new Main();
    obj.run();

  }

  private void run() {
    String[] springConfig = { "spring/batch/jobs/job-read-files.xml" };
    ApplicationContext context = new ClassPathXmlApplicationContext(springConfig);
    JobLauncher jobLauncher = (JobLauncher) context.getBean("jobLauncher");
    Job job = (Job) context.getBean("readMultiFileJob");

    try {
      JobExecution execution = jobLauncher.run(job, new JobParameters());
      System.out.println("Exit Status : " + execution.getStatus());
      System.out.println("Exit Status : " + execution.getAllFailureExceptions());
    } catch (Exception e) {
      e.printStackTrace();
    }
    System.out.println("COMPLTED CHECK THE OUTPUT DIRECTORY");
  }
}
```

在本节中，我们了解了侦听器以及如何使用作业配置侦听器。

在下一节中，我们将了解如何对 Spring 批处理应用程序进行一些单元测试。

# 单元测试弹簧批量应用

让我们演示如何为 Spring Batch 应用程序编写测试用例：

```
<dependency>
  <groupId>org.springframework.batch</groupId>
  <artifactId>spring-batch-test</artifactId>
  <version>2.2.0.RELEASE</version>
</dependency>

<!-- Junit -->
<dependency>
  <groupId>junit</groupId>
  <artifactId>junit</artifactId>
  <version>4.11</version>
  <scope>test</scope>
</dependency>
```

让我们创建一个名为`mport static org.junit.Assert.assertEquals`的简单`Test`类：

```
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.batch.core.BatchStatus;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.test.JobLauncherTestUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = {
  "classpath:spring/batch/jobs/job-report.xml",
  "classpath:spring/batch/config/context.xml",
  "classpath:spring/batch/config/database.xml",
  "classpath:spring/batch/config/test-context.xml"})
public class MainTest {
  @Autowired
  private JobLauncherTestUtils jobLauncherTestUtils;

  @Test
  public void launchJob() throws Exception {
    JobExecution jobExecution = jobLauncherTestUtils.launchStep("step1");

    assertEquals(BatchStatus.COMPLETED, jobExecution.getStatus());

  }
}
```

我们必须创建一个名为`text-context.xml`的文件以在批处理中可用，并将`JobLauncher`配置为在 XML 文件中可用，并用于测试包。在`Test`类中，使用`@Test annotation`方法并调用`JobLauncher`执行步骤。我们需要使用`assertEquals`对照`jobExecution`状态检查批处理作业的状态。

# 总结

在本章中，我们学习了如何创建基于 Spring 的批处理应用程序来读取 CSV 文件。我们还演示了如何使用 SpringBatch 读取 XML 文件。最高级的主题是对作业进行分区，并将作业运行到单独的线程中。我们还集成了 SpringBatch 和 Quartz 调度程序。

我们已经演示了使用 SpringBatch 编写简单的测试用例。我们还使用侦听器拦截定义为执行某些操作的作业，并演示了某些配置。