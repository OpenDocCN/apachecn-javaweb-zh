## 第 6 章探索 Spring MVC

到目前为止，我们已经讨论了 Spring 框架来处理、初始化和使用数据，并将控制台作为我们的输出。我们没有在它的演示或任何用户交互上做任何努力。在当今世界，使用老式的基于窗口的、非常平淡的演示文稿似乎非常无聊。我们想要更有趣、更刺激的东西。互联网是使世界比以往任何时候都更接近的东西，也是有趣的东西。今天的世界是网络世界，我们怎么能与之分离呢？让我们深入到一个令人惊叹的互联网世界，借助以下几点来探索春天的力量：

*   为什么有必要学习使用 Spring 开发 web 应用程序？
*   如何使用 springmvc 开发 web 应用程序
*   SpringMVC 的不同组件是什么？
*   如何预填充表单并将数据绑定到对象？
*   我们还将讨论如何在 spring 中执行验证

20 世纪 90 年代，互联网世界为我们打开了一个全新世界的大门。这是前所未有的数据海洋。在互联网出现之前，数据只能通过硬拷贝获得；主要是书籍和杂志。早期，互联网只是用来共享静态数据，但多年来，互联网的规模、意义和用途发生了很大变化。现在有一天，我们无法想象没有互联网的世界。这几乎是不可能的。它已经成为我们今天生活的一部分，也是我们商业行业的一个重要来源。作为一名开发人员，了解 web 应用程序、其开发、挑战以及如何克服这些挑战也非常重要。

在 Java 中，可以使用 Servlet 和 JSP 创建基本的 web 应用程序，但随后发生了许多变化。这些演变主要是由于在较短的时间内改变世界的要求很高。使用 HTML5、CSS、JavaScript、AJAX、Jquery 和许多类似技术，不仅表现形式，而且整个 web 体验都发生了变化。servlet 处理 web 请求，并使用请求参数中的数据为动态 web 应用程序提取数据。

在使用 servlet 和 JSP 时，开发人员必须花费大量精力来执行数据转换并将数据绑定到对象。除了它们在执行业务逻辑中的主要角色外，现在它们还必须处理请求和响应表示的额外负担。

开发人员主要在 web 应用程序中处理从请求中提取的数据。他们根据执行任务的规则开发复杂、较长的业务逻辑。但是，如果从请求参数中提取的数据不正确，这一切都将是无用的。这显然不是开发人员的错，但他们的业务逻辑仍然受到影响，使用这些数据值执行业务逻辑是没有意义的。在执行业务逻辑之前，开发人员现在必须首先查明从请求中提取的数据是否正确。开发人员还必须广泛参与响应数据的表示。为了首先呈现数据，开发人员需要将数据绑定到响应，然后进一步了解如何在呈现端提取数据。

上述每一项任务都会在有限的时间内为开发端添加额外的 Bordon。Spring 框架通过以下特性为开发人员提供了方便，使其能够轻松、快速地进行开发：

*   Spring 框架支持 MVC 架构，该架构将模型、视图和控制器明确分离。
*   该框架通过将请求参数绑定到命令对象，使具有 bean 功能的开发人员能够轻松处理数据。
*   它提供了对请求参数的简单验证，可以使用 Validator 接口或注释执行验证。它还可以支持自定义验证规则。
*   它提供了@RequestParam、@RequestHeader 等注释，这有助于将请求数据绑定到方法参数，而无需涉及 Servlet API。
*   它支持范围广泛的视图模板，如 JSTL、Freemarker、Velocity 和许多其他模板。
*   通过使用 ModelMap 对象，可以轻松地将数据从控制器传输到视图。
*   它可以很容易地插入到其他框架，如 ApacheStruts2.0、JSF 等。

通常，web 应用程序部署在 web 服务器上。应用程序中的每个资源都映射有 URL，用户使用这些 URL 访问资源。Servlet 或 JSP 从请求对象读取数据，对其执行业务逻辑，然后作为结果返回响应。我们都很清楚这种通用流程发生在任何 web 应用程序中。在这个流程中，第一个也是最值得关注的是，这些 web 应用程序没有任何 Servlet 或控制器来管理整个应用程序的流程。是的，该申请的第一位获得者缺席。整个应用程序及其流程必须由开发方维护。这就是 servlet 和 Spring 的主要区别所在。

* * *

Spring 框架采用 MVC 设计模式，它提供了一个前端控制器来处理或实现应用程序的每个请求。下图显示了 Spring MVC 如何处理请求，所有组件都是 Spring MVC 的一部分：

![](https://www.packtpub.com/graphics/9781787120341/graphics/image_06_001.jpg)

以下步骤为我们提供了 Spring MVC web 应用程序流程的方向：

*   每个传入的请求都将首先命中前端控制器，它是应用程序的核心。前端控制器将请求分派给处理程序，并允许开发人员使用框架的不同功能。
*   前端控制器有自己的 WebApplicationContext，它是从根 WebApplicationContext 继承的。根应用程序中配置的 bean 可以在应用程序的上下文和 Servlet 实例之间访问和共享。适用于所有 servlet 的前端控制器在第一次请求时初始化。
*   前端控制器初始化后，它会在 WEB-INF 文件夹下进一步查找名为 servlet_name-servlet.XML 的 XML 文件。它包含 MVC 特定的组件。
*   此配置文件默认命名为 WEB-INF 文件夹下的 XXX-servlet.xml。此文件包含 URL 到可处理传入请求的控制器的映射信息。在 Spring2.5 之前，映射是发现处理程序所必需的，而现在我们不需要。现在，我们可以直接使用基于注释的控制器。
*   RequestMappingHandlerMapping 搜索所有控制器以在@Controller 下查找@RequestMapping 注释。这些处理程序可以通过自定义诸如拦截器、defaultHandler、order、AlwaySuseFillPath、urlDecode 等属性来自定义 URL 的搜索方式。
*   扫描所有用户定义的控制器后，将根据 URL 映射选择适当的控制器，并调用适当的方法。方法选择基于 URL 映射和它支持的 HTTP 方法。
*   在执行控制器方法中编写的业务逻辑时，现在是生成响应的时候了。这与我们通常的 HTTPResponse 不同，因为它不会直接提供给用户。相反，响应将发送到前端控制器。在这里，响应包含视图的逻辑名称、模型数据的逻辑名称和要绑定的实际数据。通常，ModelAndView 的实例会返回到 FrontController。
*   逻辑视图名称与 Front Controller 一起使用，但它不提供任何有关要返回给用户的实际视图页面的信息。XXX-servlet.xml 文件中配置的视图解析器 bean 将是将视图名称映射到实际页面的中介。该框架支持各种各样的视图解析器，我们将很快讨论它们。
*   ViewResolver 有助于获取前端控制器可以作为响应返回的实际视图。FrontController 将通过从有界模型数据中提取值进行渲染，并将其返回给用户。

在流程讨论中，我们使用了许多名称，如 Front Contrller、ModelAndView、ViewResolver、ModelMap 等。让我们深入讨论它们。

### 调度员服务

DispacherServlet 在 SpringMVC 应用程序中充当前端控制器，在该应用程序中，首先会命中所有传入请求。它基本上用于处理 HTTP 请求，因为它是从 HTTPServlet 继承的。它将请求委托给控制器，决定将哪个视图作为响应发送回。以下配置显示 web.xml（部署描述符）中的 Dispatcher 映射，

```
<servlet>
  <servlet-name>books</servlet-name>
    <servlet-class>
      org.springframework.web.servlet.DispatcherServlet
    </servlet-class>
</servlet>
<servlet-mapping>
  <servlet-name>books</servlet-name>
  <url-pattern>*.htm</url-pattern>
</servlet-mapping>
```

上面的配置说明所有以*.htm 作为 URL 模式的请求都将由名为“books”的 Servlet 处理。

有时应用程序需要多个配置文件，其中很少在根 WebApplicationContext 中处理数据库 bean，很少在 Servlet 应用程序上下文中包含定义在控制器中使用的 bean。以下配置可用于从多个 WebApplicationContexts 初始化 bean。以下配置可用于从上下文加载多个配置文件：，

```
<servlet>
  <servlet-name>books</servlet-name>
    <servlet-class>
      org.springframework.web.servlet.DispatcherServlet
    </servlet-class>
</servlet>
<servlet-mapping>
  <servlet-name>books</servlet-name>
  <url-pattern>*.htm</url-pattern>
</servlet-mapping>
```

### 控制器

Spring 控制器处理执行业务逻辑的请求，这些控制器也可以称为“处理程序”，它们的方法称为处理程序方法。Spring 在作为控制器之前提供了 AbstractUrlviewController、ParameterableViewController、ServletForwardingConroller、ServletWrappingController。其中一个控制器需要子类化，以便在基于 Spring2.5 的 web 应用程序中自定义控制器。但现在，Spring 支持@Controller annotation 驱动的注释控制器。以下配置启用基于注释的控制器：

```
<mvc:annotation-driven />
```

需要发现基于注释的控制器以执行处理程序方法。以下配置向框架提供有关扫描哪些包以发现控制器的信息：

```
<context:component-scan base-package="com.packt.*">
</context:component-scan>
```

@RequestMapping 注释用于注释类或方法，以声明它可以处理的特定 URL。有时，可以为支持不同 HTTP 方法的 URL 的相同值注释多个方法。@RequestMapping 的'method=RequestMethod.GET'属性用于指定该方法将处理哪个 HTTP 方法。

### 模型与视图

ModelAndView 在响应生成中起着至关重要的作用。ModelAndView 的实例有助于将模型数据绑定到其逻辑名称逻辑视图名称。保存视图中要使用的数据的对象通常称为模型数据。下面的代码片段说明了绑定是如何发生的：

```
new ModelAndView(logical_name_of_view,logical_name_of_model_data,
  actual_value_of_model_data);
```

我们甚至可以使用以下代码片段：

```
ModelAndView mv=new ModelAndView();
mv.setViewName("name_of_the_view");
mv.setAttribute(object_to_add);
```

### 模型图

ModelMap 接口是 LinkedHashMap 的子类，用于使用键和值对构建模型数据。它有 addAttribute（）方法，提供模型的绑定和模型的逻辑名称。ModelMap 中设置的属性可由视图用于表单提交时的表单数据绑定。我们不久将对此进行深入讨论。

### 视图分解器

用户定义的控制器返回给前端控制器的逻辑视图名称和其他详细信息。视图名称是需要由 ViewResolver 解析的字符串。

以下是几个可用于渲染视图的 ViewResolver：

*   **XmlViewResolver**：XmlViewResolver 帮助查看用 XML 编写的文件。它使用 WEB-INF/views.xml 中的默认配置，其中包含与 SpringBeans 配置文件具有相同 DTD 的视图 bean。可以按如下所示编写配置：

```
      <bean id="myHome"  
        class="org.springframework.web.servlet.view.JstlView"> 
        <property name="url" value="WEB-INF/jsp/home.jsp"/> 
      <bean> 

```

*   逻辑视图名称“`myHome`”映射到实际视图“`WEB-INF/jsp/home.jsp`”。
*   一个 bean 也可以引用为其他 bean 映射的视图，如下所示：

```
      <bean id="logout"  
        class="org.springframework.web.servlet.view.RenderView"> 
        <property name="url" value="myHome"/> 
      <bean> 

```

*   “`logout`”bean 没有映射到任何实际视图文件，但它使用 bean“`myHome'`给出实际视图文件。

*   **UrlBasedViewResolver:**它提供 URL 到逻辑视图名称的直接映射。在逻辑名称与视图资源匹配的情况下，它将是首选。它有前缀和后缀，因为它的属性有助于获取实际视图名称及其位置。该类无法解析基于当前区域设置的视图。要启用 URLBasedViewResolver，可以将以下配置编写为：

```
      <bean id="viewResolver" 
  class="org.springframework.web.servlet.view.UrlBasedViewResolver"> 
        <property name="viewClass" value=   
          "org.springframework.web.servlet.view.JstlView"/> 
        <property name="prefix" value="WEB-INF/jsp/"/> 
        <property name="suffix" value=".jsp"/> 
      <bean> 

```

*   `JstlView`用于呈现视图页面。页面名称和位置是“前缀+视图\u 名称\u 来自\u 控制器+后缀”。

*   **InternalResourceViewResolver:**InternalResourceViewResolver 是 UrlBasedViewResolver 的子类，用于解析内部资源，该资源可以用作视图，使用类似于其父类的前缀和后缀等属性。始终包括 ExposeContextBeanSatributes、ExposeContextBeanNames 都是该类的一些额外属性，增加了比其父类更频繁地使用它的优势。以下配置与我们在上一示例中配置 UrlBasedViewResolver 的方式类似：

```
      <bean id="viewResolver" class=  
  "org.springframework.web.servlet.view.InternalResourceViewResolver"> 
        <property name="viewClass" value=                
          "org.springframework.web.servlet.view.JstlView"/> 
        <property name="prefix" value="WEB-INF/jsp/"/> 
        <property name="suffix" value=".jsp"/> 
      <bean> 

```

*   它只能在到达页面时验证页面是否存在，而不能在此之前进行验证。

*   **ResourceBundleView 解算器：**ResourceBundleView 解算器使用配置中指定的 ResourceBundle 中的定义。默认文件用于定义配置为 views.properties。配置如下：，

```
      <bean id="viewResolver" class= 
  "org.springframework.web.servlet.view.ResourceViewResolver"> 
        <property name="base" value="web_view"/> 
      </bean> 

```

*   view.properties 将指定要使用的视图类的详细信息以及到实际视图的 url 映射，如下所示：

```
      home.(class)= org.springframework.wev.servlet.view.JstlView 

```

*   下一行说明名为 homepage 的视图的映射：

```
       homepage.url= /WEB-INF/page/welcome.jsp 

```

*   **TilesViewResolver:**TilesViewResolver 框架用于定义可重用的页面布局模板，以保持应用程序的一致外观。“tiles.def”文件中定义为 tile、页眉、页脚和菜单的页面定义，这些定义将作为运行时在页面中组装。控制器返回的逻辑名称与将由视图解析器呈现的平铺模板的名称匹配。

除了上面讨论的视图解析器之外，Spring 还有 FreeMarkServiceWresolver、TileViewWresolver、VelocityLayoutViewResolver、VelocityViewWresolver、XSLTViewWresolver。

在继续前面的讨论之前，让我们首先开发一个示例演示，以详细了解应用程序的流程，通过以下步骤为上述讨论提供方向，

1.  创建 Ch06_Demo_SpringMVC 作为动态 web 应用程序。
2.  复制 spring 核心、spring 上下文、commons 日志、spring web 和 spring webmvc 的 JAR，如以下项目大纲所示：

![](https://www.packtpub.com/graphics/9781787120341/graphics/image_06_002.png)

3.  在作为主页的**`WebContent`**文件夹中创建 index.jsp。可以按照您的要求定制名称，就像我们在任何 Servlet 应用程序中所做的那样。
4.  在`index.jsp`中添加一个链接，为控制器提供导航，如下所示：

```
      <center> 
        <img alt="bookshelf" src="img/img1.png" height="180" 
          width="350"> 
        <br> 
      </center> 
      <a href="welcomeController.htm">Show welcome message</a> 

```

5.  每当用户单击链接时，将生成 URL 为“welcomeCointroller.htm”的请求，前端控制器将参与该请求。
6.  是时候在`web.xml`中配置前端控制器了，如下所示：

```
      <servlet> 
        <servlet-name>books</servlet-name> 
        <servlet-class>    
          org.springframework.web.servlet.DispatcherServlet 
        </servlet-class> 
      </servlet> 
      <servlet-mapping> 
        <servlet-name>books</servlet-name> 
        <url-pattern>*.htm</url-pattern> 
      </servlet-mapping> 

```

7.  用于查找和调用控制器方法的信息前控制器将在 WEB-INF 中查找名为`servlet_name-servlet.xml`的文件。在本例中，`books'`是 Servlet 的名称。因此，让我们在 WEB-INF 文件夹下创建名为“`books-servlet.xml`”的文件。
8.  该文件应具有 Spring 容器将扫描哪个包以查找控制器的配置。配置如下所示：

```
      <context:component-scan base-package=     
        "com.packt.*"></context:component-scan> 

```

上面的配置说明将从“`com.packt`包扫描所有控制器。

9.  在包 com.packt.ch06.controllers 中创建一个类`MyMVCController`。
10.  用`@Controller`注释该类。注释类有助于它使用处理请求的功能。
11.  我们添加`welome()`方法来处理请求，用`@RequestMapping`进行注释，如下图：

```
      @Controller 
      public class MyMVCController { 
        @RequestMapping(value="welcomeController.htm") 
        public ModelAndView welcome() 
        { 
          String welcome_message="Welcome to the wonderful  
          world of Books"; 
          return new ModelAndView("welcome","message",welcome_message); 
        } 
      } 

```

控制器可以有多个方法，这些方法将根据 URL 映射进行调用。在这里，我们声明将为“`welcomeController.htm'`URL 调用的方法。

该方法执行生成欢迎消息的业务逻辑，并借助`ModelAndView`生成响应，如下图：，

```
      new ModelAndView("welcome","message",welcome_message); 
      The ModelAndView instance is specifying, 
      Logical name of the view -  welcome 
      Logical name of the model data -  message  
      Actual value of the model data - welcome_message 

```

除上述代码外，您还可以使用以下代码：

```
      ModelAndView mv=new ModelAndView(); 
      mv.setViewName("welcome"); 
      mv.addObject("message", welcome_message); 
      return mv; 

```

我们可以将多个方法映射到同一 URL，支持不同的 HTTP 方法，如下所示：

```
      @RequestMapping(value="welcomeController.htm", 
        method=RequestMethod.GET) 
      public ModelAndView welcome(){ 
        //business logic  
      } 
      @RequestMapping(value="welcomeController.htm", 
        method=RequestMethod.POST) 
      public ModelAndView welcome_new()  { 
        //business logic 
      } 

```

12.  在`books-servlet.xml`中为 ViewResolver 配置 bean，如下所示：

```
      <bean id="viewResolver" class=
   "org.springframework.web.servlet.view.InternalResourceViewResolver"> 
        <property name="prefix" value="/WEB-INF/jsps/"></property> 
        <property name="suffix" value=".jsp"></property> 
      </bean> 

```

ViewResolver 帮助前控制器获取实际视图名称和位置。字体控制器返回到浏览器的响应页面在我们的情况下是：

![](https://www.packtpub.com/graphics/9781787120341/graphics/image_06_003.png)

13.  在 WebContent 中创建一个名为 jsps 的文件夹。
14.  在 jsps 文件夹中创建 welcome.jsp 页面，该页面将使用表达式语言显示欢迎消息，如下所示：

```
      <body> 
        <center> 
          <img alt="bookshelf" src="img/img1.png" height="180" 
            width="350"> 
          <br> 
        </center> 
        <center> 
          <font color="green" size="12"> ${message } </font> 
        </center> 
      </body>
```

属性“`message'`用于 EL，因为它是我们在绑定到`ModelAndView`对象的控制器方法中使用的逻辑模型名称。

15.  配置 tomcat 服务器并运行应用程序。该链接将显示在浏览器上。单击链接，我们将获得如下屏幕截图所示的输出：

![](https://www.packtpub.com/graphics/9781787120341/graphics/image_06_004.png)

演示向我们介绍了 Spring MVC 流。现在，让我们逐步开发 book 应用程序，涵盖以下情况：

*   读取请求参数
*   处理表格提交

### 案例 1：读取请求参数

让我们通过以下步骤从读取请求参数开始：

1.  创建 ReadMyBooks 作为动态 web 应用程序，并像前面一样向其中添加所有必需的 JAR。
2.  每个应用程序都有主页。因此，让我们添加 index.jsp 作为早期应用程序的主页。您可以直接复制和粘贴它。
3.  从早期应用程序复制图像文件夹。
4.  如下图所示，再添加一个关于作者姓名的搜索书链接，

```
      <a href="searchByAuthor.jsp">Search Book By Author</a> 

```

5.  让我们添加 searchByAuthor.jsp 页面，以便用户通过输入作者姓名请求图书列表，如下所示：

```
      <body> 
        <center> 
          <img alt="bookshelf" src="img/img1.png" height="180"  
            width="350"> 
          <br> 

          <h3>Add the Author name to search the book List</h3> 

          <form action="/searchBooks.htm"> 
            Author Name:<input type="text" name="author"> 
            <br>  
            <input  type="submit" value="Search Books"> 
          </form> 
        </center> 
      </body>
```

6.  与前面一样，在 web.xml 中添加 dispatchetservlet 作为前端控制器的配置。将 servlet 命名为“books”。
7.  创建或复制用于从早期应用程序配置处理程序映射和其他 web 组件映射的 servlet.xml。
8.  添加使用“上下文”命名空间扫描控制器的配置。
9.  我们需要 Bookbean 来处理往返于控制器的数据。因此，在开发控制器代码之前，将 Book.java 添加到 com.packt.ch06.beans 包中，该包来自我们的早期应用程序，其数据成员如下所示：

```
      public class Book { 
        private String bookName; 
        private long ISBN; 
        private String publication; 
        private int price; 
        private String description; 
        private String author; 
        //getters and setters 
      } 

```

10.  现在在 com.packt.ch06.controllers 包中创建一个类 SearchBookController 作为控制器，并用@controller 对其进行注释。
11.  要搜索图书，请添加名为 searchBookByAuthor（）的方法，并通过@RequestMapping 为 URL“searchBooks.htm”添加注释。我们可以使用 ServletAPI 或 SpringAPI，但这里我们将使用 SpringAPI。
12.  现在我们将代码添加到`searchBookByAuthor()`中，用于：

*   *读取请求参数
*   *图书检索表

13.  正在创建 ModelAndView 实例以将图书列表作为模型数据、逻辑模型名称和逻辑视图名称绑定在一起。

代码如下所示：

```
      @Controller 
      public class SearchBookController { 
        @RequestMapping(value = "searchBooks.htm") 
        public ModelAndView searchBookByAuthor( 
          @RequestParam("author") String author_name)  
        { 
          // the elements to list generated below will be added by      
          business logic  
          List<Book> books = new ArrayList<Book>(); 
          books.add(new Book("Learning Modular Java Programming",  
            9781235, "packt pub publication", 800, 
            "Explore the Power of Modular Programming ",  
            "T.M.Jog")); 
          books.add(new Book("Learning Modular Java Programming",  
            9781235, "packt pub publication", 800, 
            "Explore the Power of Modular Programming ",   
            "T.M.Jog")); 
          mv.addObject("auth_name",author); 
          return new ModelAndView("display", "book_list", books); 
        } 
      } 

```

`@RequestParam`用于读取请求参数并将其绑定到方法参数。“author”属性的值绑定到 author\u name 参数，而不公开 servlet API。

在这里，我们添加了一个虚拟列表。稍后，它可以被实际代码替换，以从持久性层获取数据。

14.  现在是在 servlet.xml 中配置 ViewResolver 和包扫描的时候了，就像我们在前面的应用程序中所做的那样。我们可以从早期应用程序复制 WEB-INF 中的 paste books-sevlet.xml。
15.  在 WebContent 下创建包含 jsp 页面的 jsp 文件夹。
16.  在 jsps 文件夹中创建 display.jsp，以使用 JSTL 标记显示书籍列表，如下所示：

```
      <%@ taglib prefix="jstl"  
        uri="http://java.sun.com/jsp/jstl/core"%> 
      <html> 
        <head> 
          <meta http-equiv="Content-Type" content="text/html; 
            charset=ISO-8859-1"> 
          <title>Book List</title> 
        </head> 
        <body> 
          <center> 
            <img alt="bookshelf" src="img/img1.png"   
              height="180" width="350"> 
            <br> 
          </center> 
          <jstl:if test="${not empty book_list }"> 
            <h1 align="center"> 
              <font color="green"> 
                Book List of ${auth_name } 
              </font> 
            </h1> 
            <table align="center" border="1"> 
            <tr> 
              <th>Book Name</th> 
              <th>ISBN</th> 
              <th>Publication</th> 
              <th>Price</th> 
              <th>Description</th> 
            </tr> 
            <jstl:forEach var="book_data"  
              items="${book_list}" varStatus="st"> 
              <tr> 
                <td> 
                  <jstl:out value="${ book_data.bookName }"> 
                  </jstl:out> 
                </td> 
                <td> 
                  <jstl:out value="${ book_data.ISBN }"> 
                  </jstl:out> 
                </td> 
                <td> 
                  <jstl:out value="${ book_data.publication }"> 
                  </jstl:out> 
                </td> 
                <td> 
                  <jstl:out value="${ book_data.price }"> 
                  </jstl:out></td> 
                <td> 
                  <jstl:out value="${ book_data.description }"> 
                  </jstl:out> 
                </td> 
              </tr> 
            </jstl:forEach> 
          </table> 
        </jstl:if> 
        <jstl:if test="${empty book_list }"> 
          <jstl:out value="No Book Found"></jstl:out> 
        </jstl:if> 
      </body>
```

如果列表中没有元素，则没有必要显示此类列表。jstl:if 标记用于决定是否显示列表，jstl:forEach 用于通过迭代列表来显示图书信息。

17.  运行应用程序并单击主页上的链接以获取表单以输入作者姓名。如果存在作者姓名，在提交表格时，我们将获得如下所示的书籍列表：

![](https://www.packtpub.com/graphics/9781787120341/graphics/image_06_005.png)

这里，我们使用`@RequestParam`将各个请求参数绑定到方法参数。但是，如果请求参数的名称和方法参数的名称匹配，则无需使用注释。更新代码可以按如下所示编写：

```
@RequestMapping(value = "searchBooks.htm") 
public ModelAndView searchBookByAuthor( String author) { 
  List<Book> books = new ArrayList<Book>(); 
  books.add(new Book("Learning Modular Java Programming",  
    9781235, "packt pub publication", 800, 
    "explore the power of modular Programming ",    
    author)); 
  books.add(new Book("Learning Modular Java Programming",  
    9781235, "packt pub publication", 800, 
    "explore the power of modular Programming ",  
    author)); 
  ModelAndView mv= 
    new ModelAndView("display", "book_list", books); 
    mv.addObject("auth_name",author); 
    return mv; 
} 

```

一个接一个地读取单个请求参数，然后将它们绑定到 bean 的对象，这会变得笨拙且不必要地冗长。框架通过处理“表单支持对象”提供了一个更好的选项。

### 案例二：提交处理单

表单提交是应用程序开发中非常常见的任务。每次提交表单时，开发人员都需要执行以下步骤：

1.  读取请求参数
2.  根据所需的数据类型转换请求参数值
3.  将值设置为 bean 的对象。

可以绕过上述步骤，直接在表单提交中获取 bean 的实例。我们将在以下两种情况下讨论表格处理：

*   提交表格
*   表单预处理

#### 表格提交

在普通 web 应用程序中，用户单击链接时将加载表单，然后手动执行上述步骤。由于该过程需要自动化，而不是直接显示表单，因此应该从已经有 bean 实例的控制器加载它。在表单提交时，用户输入的值将绑定到此实例。这个实例现在可以在控制器中使用，以执行业务逻辑。Spring2.0 以后的版本提供了一组标签，这些标签在视图中的表单处理中可以感知数据绑定，从而简化了开发。

让我们向 ReadMyBooks 应用程序添加一个表单，以便使用 Spring 提供的表单标记理解表单提交。我们将分两个步骤来完成这项工作：第一步显示表单，第二步对提交的表单进行后期处理。

##### 显示表单

由于表单必须从控制器加载，因此让我们使用以下步骤添加代码，

1.  在主页上添加链接以加载表单。获取表单的代码如下所示：

```
      <a href="showBookForm.htm">Show Form to add new Book</a> 

```

2.  在`AddBookController`中添加`showBookForm()`方法，点击步骤 1 中编写的链接将调用该方法。该方法将返回一个表单页面，方便使用 Book 对象，其中输入的数据将被绑定。该方法具有以下代码，

```
      @RequestMapping("/showBookForm.htm") 
      public ModelAndView showBookForm(ModelMap map)  
      throws Exception { 
        Book book=new Book(); 
        map.addAttribute(book); 
        return new ModelAndView("bookForm"); 
      } 

```

该方法应将`ModelMap`作为其参数之一，以添加可由视图使用的 bean 实例。在这里，我们添加了具有值的“book”属性作为 book 的实例。默认情况下，引用名称将用作属性名称。“book”实例也可以称为“formbacking”对象。为了自定义要在视图中使用的表单支持对象的名称，我们可以使用以下代码：

```
      map.addAttribute("myBook",book); 

```

3.  由于控制器返回了视图名“`bookForm'`，在 jsps 文件夹中添加`bookForm.jsp`，该文件夹中有要显示的表单。
4.  用户输入的值需要绑定到表单。Spring 框架提供了强大的标记来处理用户输入。要禁用 Spring 标记，我们需要添加“taglib”指令，如下所示：

```
      <%@ taglib prefix="form"  
        uri="http://www.springframework.org/tags/form"%> 

```

5.  Spring 提供了与 html 类似的标记来处理表单、输入、复选框、按钮等，它们的值与 bean 数据成员的隐式绑定有很大区别。以下代码将允许用户输入图书名称，并在提交表单时将其绑定到图书 bean 的“bookName”数据成员：

```
      <form:input path="bookName" size="30" /> 

```

“path”属性将输入的值映射到 bean 数据成员。必须根据数据成员的名称指定值。

6.  让我们在 bookForm.jsp 中添加表单，如下所示，以方便用户输入新书的值：

```
      <form:form modelAttribute="book" method="POST"  
        action="addBook.htm"> 
        <h2> 
          <center>Enter the Book Details</center> 
        </h2> 

        <table width="100%" height="150" align="center" border="0"> 
         <tr> 
           <td width="50%" align="right">Name of the Book</td> 
           <td width="50%" align="left"> 
             <form:input path="bookName" size="30" /> 
           </td> 
         </tr> 
         <tr> 
           <td width="50%" align="right">ISBN number</td> 
           <td width="50%" align="left"> 
             <form:input path="ISBN" size="30" /> 
           </td> 
         </tr> 
         <tr> 
           <td width="50%" align="right">Name of the Author</td> 
           <td width="50%" align="left"> 
             <form:input path="author" size="30" /> 
           </td> 
         </tr> 
         <tr> 
           <td width="50%" align="right">Price of the Book</td> 
           <td width="50%" align="left"> 
             <form:select path="price"> 
               <!- 
                 We will add the code to have  
                 predefined values here  
               -->             
             </form:select> 
           </td> 
         </tr> 
         <tr> 
           <td width="50%" align="right">Description of the  
             Book</td> 
           <td width="50%" align="left"> 
             <form:input path="description"  size="30" /> 
           </td> 
         </tr> 
         <tr> 
           <td width="50%" align="right">Publication of the  
             Book</td> 
           <td width="50%" align="left"> 
             <form:input path="publication"  size="30" /> 
           </td> 
         </tr> 
         <tr> 
           <td colspan="2" align="center"><input type="submit"  
             value="Add Book"></td> 
          </tr> 
        </table> 
      </form:form>
```

属性“modelAttribute”采用控制器设置的 ModelMap 属性的逻辑名称的值。

7.  运行应用程序并单击“**`Show Form to add new book`【T2]”。**
8.  您将被导航到 bookForm.jsp 页面，在那里您可以输入自己的值。提交时，您将收到 404 错误，因为我们尚未编写任何资源来处理请求。别担心！！在以下步骤中，我们将处理表单。

##### 表格后处理

1.  让我们在 AddController 中添加一个方法，该方法将在 url“addBook.htm”的表单提交时调用，如下所示：

```
      @RequestMapping("/addBook.htm") 
      public ModelAndView addBook(@ModelAttribute("book") Book book) 
      throws Exception { 
          ModelAndView modelAndView = new ModelAndView(); 
          modelAndView.setViewName("display"); 
          //later on the list will be fetched from the table 
          List<Book>books=new ArrayList(); 
          books.add(book); 
          modelAndView.addObject("book_list",books); 
          return modelAndView; 
      } 

```

当用户提交表单时，他输入的值将绑定到提供 Bookbean 实例的 bean 数据成员。通过@modeldattribute 注释'book'参数有助于开发人员使用绑定了值的 bean 实例。现在，不需要读取单个参数和其他内容来获取和设置 Book 的实例。

因为我们已经有 display.jsp 页面来显示书籍，所以我们只是在这里重用它。用户输入的图书详细信息可以稍后添加到图书表中。

2.  运行应用程序，单击链接以获取表单。填写表格并提交以获得以下输出：

![](https://www.packtpub.com/graphics/9781787120341/graphics/image_06_006.png)

输出列表显示书籍的详细信息，但不显示输出中的价格。因为我们没有设定价格，所以价格没有价值。我们希望价格表中有一些预定义的值。让我们继续讨论表单的预处理。

#### 表单预处理

在某些情况下，表单中包含的预定义值很少，例如国家名称或下拉菜单中的图书类别、可供选择颜色的单选按钮等等。这些值可以硬编码，导致频繁更改为显示更改的值。可以呈现这些值，并在表单中填充这些值，而不是使用常量值。这通常称为表单预处理。预处理可以分两步完成。

##### 使用要添加到视图中的值定义属性

@ModelAttribute 用于将模型数据的实例添加到模型的实例中。由@modeldattribute 注释的每个方法将在控制器的任何其他方法之前被调用，并且在其执行时，模型数据将被添加到 Spring 模型中。使用注释的语法如下所示：

```
@ModelAttribute("name_of_the_attribute") 
access_specifier return_type name_of_method(argument_list) {  // code   } 

```

以下代码添加了可在视图中使用的“嗜好”属性：

```
@ModelAttribute("hobbies") 
public List<Hobby> addAttribute() { 
  List<Hobby> hobbies=new ArrayList<Hobby>(); 
  hobbies.add(new Hobby("reading",1)); 
  hobbies.add(new Hobby("swimming",2)); 
  hobbies.add(new Hobby("dancing",3)); 
  hobbies.add(new Hobby("paining",4)); 
  return hobbies; 
} 

```

Hobby 是以 hobbyName 和 hobbyId 作为数据成员的用户定义类。

##### 在表单中填充属性的值

表单可以使用复选框、下拉菜单或单选按钮向用户显示可用的选项列表。可以使用下拉菜单、复选框或单选按钮的值的列表、映射或数组填充视图中的值。

标签的一般语法如下所示：

```
<form:name-of_tag path="name_of_data_memeber_of_bean"  
  items="name_of_attribute" itemLable="value_to display"  
  itemValue="value_it_holds"> 

```

以下代码可用于在复选框中显示用户的爱好，使用“爱好”作为 modelattribute，将值绑定到 bean 的爱好数据成员：

```
<form:checkboxes path="hobby" items="${hobbies}"    
  itemLabel="hobbyName" itemValue="hobbyId"/>                 

```

同样，我们可以在运行时为 select 标记生成下拉菜单和选项。

### 注

在处理字符串值时，可以跳过`itemLabel`和`itemValue`属性。

完整示例可参考申请`Ch06_Form_PrePopulation`。

让我们通过以下步骤更新`ReadMyBooks`应用程序，在`bookForm.jsp`中使用“`ModelAttribute'`预定义一些价格值，以讨论表单预处理：

1.  由于表单被`AddController`重新调谐到前面的 Conotroller，我们想在那里设置预定义的值，所以在表单中使用 ass`addPrices()` 方法。用`@ModelAttribute`注释方法，如下图：

```
      @ModelAttribute("priceList") 
      public List<Integer> addPrices() { 
        List<Integer> prices=new ArrayList<Integer>(); 
        prices.add(300); 
        prices.add(350); 
        prices.add(400); 
        prices.add(500); 
        prices.add(550); 
        prices.add(600); 
        return prices; 
      } 

```

上面的代码正在创建一个属性'`pricelist'`，该属性可供视图使用。

2.  现在可以在视图中使用`pricelist`属性来显示预定义的值。在我们的例子中，这是一个用于添加新书的表单，请更新`bookForm.jsp`以显示价格表，如下所示：

```
      <form:select path="price"> 
        <form:options items="${priceList}" />   
      </form:select>
```

3.  运行应用程序并单击链接，您可以看到预定义的价格将显示在下拉列表中，如下所示：

![](https://www.packtpub.com/graphics/9781787120341/graphics/image_06_007.png)

用户将在表单中输入值并提交。

这些值可以在 handler 方法中获得。但是，我们仍然不能确定是否只会输入和提交有效的值。对错误的值执行的业务逻辑总是会失败。此外，用户输入的数据类型值有可能出错，从而导致异常。让我们以电子邮件 ID 为例。电子邮件 id 始终遵循特定的格式，如果格式错误，业务逻辑最终会失败。无论情况如何，我们必须确保只提交其数据类型、范围或格式的有效值。验证是否提交正确的数据是“表单验证”过程。表单验证在确保正确提交数据方面起着关键作用。表单验证可以在客户端和服务器端完成。Java 脚本用于执行客户端验证，但也可以禁用它。在这种情况下，服务器端验证总是更可取的。

* * *

Spring 具有灵活的验证机制，可扩展为根据应用程序需求编写自定义验证程序。SpringMVC 框架默认支持在应用程序中添加 JSR303 实现依赖项的 JSR303 规范。以下两种方法可用于验证 Spring MVC 中的表单字段，

*   JSR303 基于规范的验证
*   使用验证器接口的基于 Spring 的实现。

### 基于 Spring validator 接口的定制验证器

Spring 提供了验证器接口，验证器接口具有用于检查验证规则的验证方法。该接口不仅支持 web 层的验证，还可以在任何层中使用它来验证数据。如果验证规则失败，必须通过显示适当的信息性消息让用户知道。BindingResult 是错误的子级，在 validate（）方法中对模型执行验证时，它保存由错误限定的验证结果。错误的有界消息将在视图中使用<errors>标记显示，以使用户意识到它们。</errors>

让我们通过以下步骤在 ReadMyBooks 应用程序中添加一个自定义验证器：

1.  在应用程序的 lib 文件夹中添加 validation-api-1.1.0.final.api.jar 文件。
2.  在 com.packt.ch06.validators 包中创建 BookValidator 类。
3.  该类实现 org.springframework.validation.Validator 接口。
4.  重写 supports（）方法，如下面的代码所示，

```
      public class BookValidator implements Validator { 
        public boolean supports(Class<?> book_class) { 
          return book_class.equals(Book.class); 
        } 
      } 

```

支持方法确保对象与验证方法验证的对象匹配

5.  现在重写 validate（）方法，其中根据规则检查数据成员。我们将分为三个步骤：
    1.  设置验证规则

我们将交叉检查以下规则：

*   书名的长度必须大于 5。
*   作者的姓名不能为空。
*   说明不能为空。
*   描述长度必须至少为 10 个字符，最多为 40 个字符。
*   国际标准书号不应少于 150。
*   价格不应低于 0。
*   发布内容不能为空。
    2.  写入条件以检查验证规则。
    3.  如果验证失败，则使用 rejectValue（）方法将消息添加到错误实例中

使用上述步骤的方法可以写成如下所示：

```
      public void validate(Object obj, Errors errors) { 
        // TODO Auto-generated method stub 
        Book book=(Book) obj; 
        if (book.getBookName().length() < 5) { 
          errors.rejectValue("bookName", "bookName.required", 
          "Please Enter the book Name"); 
        } 
        if (book.getAuthor().length() <=0) { 
          errors.rejectValue("author", "authorName.required", 
          "Please Enter Author's Name"); 
        } 
        if (book.getDescription().length() <= 0) 
        { 
          errors.rejectValue("description",  
            "description.required", 
            "Please enter book description"); 
        } 
        else if (book.getDescription().length() < 10 ||  
          book.getDescription().length() <  40) { 
            errors.rejectValue("description", "description.length", 
            Please enter description within 40 charaters only"); 
         } 
         if (book.getISBN()<=150l) { 
           errors.rejectValue("ISBN", "ISBN.required", 
           "Please Enter Correct ISBN number"); 
         }   
         if (book.getPrice()<=0 ) { 
           errors.rejectValue("price", "price.incorrect",  "Please  
           enter a Correct correct price"); 
         } 
        if (book.getPublication().length() <=0) { 
          errors.rejectValue("publication",  
            "publication.required", 
            "Please enter publication "); 
        } 
      } 

```

Errors 接口用于存储有关数据验证的绑定信息。`errors.rejectValue()`是 it 提供的非常有用的方法之一，它可以注册对象的错误及其错误消息。以下是 Error 接口中 rejectValue（）方法的可用签名，

```
      void rejectValue(String field_name, String error_code); 
      void rejectValue(String field_name, String error_code, String  
        default_message); 
      void rejectValue(String field_name, String error_code, 
        Object[] error_Args,String default_message); 

```

4.  在 AddBookController 中添加类型为 org.springframework.validation.Validator 的数据成员，并用`@Autowired`注释，如下图：

```
      @Autowired 
      Validator validator; 

```

5.  更新`AddController`的`addBook()`方法调用 validate 方法，检查是否发生验证错误。更新后的代码如下所示：

```
      public ModelAndView addBook(@ModelAttribute("book") Book book,   
        BindingResult bindingResult)   throws Exception { 
        validator.validate(book, bindingResult); 
      if(bindingResult.hasErrors()) 
      { 
        return new ModelAndView("bookForm"); 
      } 
      ModelAndView modelAndView = new ModelAndView(); 
      modelAndView.setViewName("display"); 
      //later on the list will be fetched from the table 
      List<Book>books=new ArrayList(); 
      books.add(book); 
      modelAndView.addObject("book_list",books); 
      modelAndView.addObject("auth_name",book.getAuthor()); 
      return modelAndView; 
    } 

```

`addBook ()`的方法签名应将 BindingResult 作为其参数之一。BindingResult 实例包含执行验证时发生的错误列表。如果对数据成员的验证失败，`hasErrors()`方法返回 true。如果`hasErrors()`返回 true，我们将返回“`bookForm'`视图，方便用户输入正确的值。如果没有验证冲突，“显示”视图将返回到前端控制器。

6.  在 books-servlet.xml 中将`BookValdator`注册为 bean，如下所示：

```
      <bean id="validator"  
        class="com.packt.ch06.validators.BookValidator" /> 

```

您也可以使用`@Component`代替上述配置。

7.  必须通过更新 bookForm.jsp 向用户显示验证冲突消息，如下代码所示：

```
      <tr> 
        <td width="50%" align="right">Name of the Book</td> 
        <td width="50%" align="left"> 
          <form:input path="bookName" size="30" /> 
          <font color="red"> 
            <form:errors path="bookName" /> 
          </font> 
        </td> 
      </tr> 

```

只有在 bookForm.jsp 中添加下划线代码才能以红色显示消息。

如果验证失败，<errors>用于显示消息。它采用如下所示的语法：</errors>

```
      <form:errors path="name of the data_member" /> 

```

8.  通过将数据成员的名称指定为 path 属性的值，为所有输入更新 bookForm.jsp。
9.  运行应用程序。单击“显示表单”链接以添加新书。
10.  无需在文本字段中输入任何数据即可提交表单。我们将获得显示消息的表单，该表单表示违反了哪些验证规则，如下所示：

![](https://www.packtpub.com/graphics/9781787120341/graphics/image_06_008.png)

尽管上面为验证编写的代码运行良好，但我们并没有完全利用 Spring 框架。validate 方法的调用是显式的，因为框架不知道隐式执行验证。@Valid 注释向框架提供信息，以便使用自定义验证器隐式执行验证。该框架有助于将自定义验证器绑定到 WebDataBinder，从而使框架了解如何使用 validate（）方法。

#### 使用@InitBinder 和@Valid 进行验证

让我们一步一步地更新 AddController.java 的代码，如下所示：

1.  添加一个将 validator 绑定到 WebDataBinder 的方法，并用`@InitBinder`进行注释，如下图：

```
      @InitBinder 
      private void initBinder(WebDataBinder webDataBinder) 
      { 
        webDataBinder.setValidator(validator); 
      } 

```

`@InitBinder`注释有助于识别执行 WebDataBinder 初始化的方法。

2.  为了使框架能够考虑注释，book-servelt.xml 必须更新如下：，
3.  添加 mvc 命名空间，如下面的配置所示：

```
      <beans  
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
        xmlns:context="http://www.springframework.org/schema/context" 
        xmlns:mvc="http://www.springframework.org/schema/mvc" 
        xsi:schemaLocation="http://www.springframework.org/schema/beans 
          http://www.springframework.org/schema/beans/spring-beans.xsd  
          http://www.springframework.org/schema/context  
          http://www.springframework.org/schema/context/
      spring-context.xsd 
          http://www.springframework.org/schema/mvc 
          http://www.springframework.org/schema/mvc/spring-mvc.xsd"> 

```

您只能复制现有代码中带下划线的语句。

4.  添加如下所示的配置：

```
      <mvc:annotation-driven/> 

```

5.  更新`addBook()`方法，向 perfom Book validation 添加`@Valid`注释，并删除 validator.validate（）调用，因为它将隐式执行。更新后的代码如下所示：

```
      @RequestMapping("/addBook.htm") 
      public ModelAndView addBook(@Valid @ModelAttribute("book")  
      Book book,BindingResult bindingResult) 
      throws Exception { 
        //validator.validate(book, bindingResult); 
        if(bindingResult.hasErrors()) 
        { 
          return new ModelAndView("bookForm"); 
        } 
        ModelAndView modelAndView = new ModelAndView(); 
        modelAndView.setViewName("display"); 
        //later on the list will be fetched from the table 
        // rest of the code is same as the earlier implemenation 
      } 

```

6.  当您提交空白表单时，运行应用程序以获得类似的结果。消息将显示在视图中，该视图已通过`rejectValue()`方法硬编码。该框架支持将属性文件中的消息外部化。让我们更新验证程序以实现消息的外部化。

##### 信息外化

我们将使用消息的外部化，而无需通过以下步骤更改验证逻辑：

1.  在 com.packt.ch06.validators 包中添加一个新的类 BookValidator1，实现 Validator 接口。
2.  像在早期应用程序中那样重写 supports 方法。
3.  重写我们不提供默认错误消息的验证方法。我们将只提供 bean 属性的名称和与之关联的错误代码，如下所示：

```
      public void validate(Object obj, Errors errors) { 
        Book book=(Book) obj; 
        if (book.getBookName().length() < 5) { 
          errors.rejectValue("bookName", "bookName.required"); 
        } 

        if (book.getAuthor().length() <=0) { 
          errors.rejectValue("author", "authorName.required");           
        } 

        if (book.getDescription().length() <= 0){ 
          errors.rejectValue("description","description.required");             } 

        if (book.getDescription().length() < 10 ||   
          book.getDescription().length() <  40) { 
          errors.rejectValue("description", "description.length");               } 

        if (book.getISBN()<=150l) { 
          errors.rejectValue("ISBN", "ISBN.required"); 
        } 

        if (book.getPrice()<=0 ) { 
          errors.rejectValue("price", "price.incorrect"); 
        } 

        if (book.getPublication().length() <=0) { 
          errors.rejectValue("publication", "publication.required");             } 
      } 

```

4.  让我们在 WEB-INF 中添加 messages\u book\u validation.properties 文件，以将错误代码映射到其关联的消息，如下所示：

```
      bookName.required=Please enter book name 
      authorName.required=Please enter name of the author 
      publication.required=Please enter publication 
      description.required=Please enter description 
      description.length=Please enter description of minimum 10 and        maximum 40 characters 
      ISBN.required=Please enter ISBN code 
      price.incorrect= Please enter correct price 

```

将属性文件写入映射键值对的语法为，

```
      name_of_Validation_Class . name_of_model_to_validate   
        .name_of_data_memeber  = message_to_display 

```

5.  将 books-servlet.xml 更新为，
6.  注释为 BookValidator 编写的 bean，因为我们不使用它
7.  为 BookValidator1 添加一个新 bean，如下所示：

```
      <bean id="validator"  
        class="com.packt.ch06.validators.BookValidator1" /> 

```

8.  为 MessagSource 添加一个 bean，以从属性文件加载消息，如下所示：

```
      <bean id="messageSource" 
        class="org.springframework.context.support. 
        ReloadableResourceBundleMessageSource"> 
        <property name="basename"  
          value="/WEB-INF/messages_book_validation" /> 
      </bean> 

```

9.  无需更改 AddController.java。运行应用程序时，从提交的空白消息中提取的属性文件将被显示出来。

我们成功地将信息具体化，恭喜！！！

但是您不认为验证代码不必要地执行了这里的基本验证吗。该框架将 ValidationUtils 作为一个实用程序类提供，方便开发人员执行诸如空值或空值之类的基本验证。

##### 使用 ValidationUtils

让我们添加 BookValidator2，它将使用 ValidationUtils，如下所示：

1.  在 com.packt.ch06.validators 包中添加 BookValidator2 作为一个类，该包正在 ReadMyBooks 应用程序中实现 Validator。
2.  重写与前面一样支持（）方法。
3.  重写 validate（），它将使用 ValidationUtils 类执行验证，如下所示：

```
      public void validate(Object obj, Errors errors) { 
        Book book = (Book) obj; 
        ValidationUtils.rejectIfEmptyOrWhitespace(errors,  
          "bookName", "bookName.required"); 
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "author",  
          "authorName.required"); 
        ValidationUtils.rejectIfEmptyOrWhitespace(errors,  
          "description", "description.required"); 
        if (book.getDescription().length() < 10 ||  
          book.getDescription().length() < 40) { 
          errors.rejectValue("description", "description.length", 
            "Please enter description within 40 charaters only"); 
        } 
        if (book.getISBN() <= 150l) { 
          errors.rejectValue("ISBN", "ISBN.required", "Please 
          Enter Correct ISBN number"); 
        } 
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "price",  
          "price.incorrect"); 
        ValidationUtils.rejectIfEmptyOrWhitespace(errors,  
          "publication", "publication.required"); 
      } 

```

4.  由于我们正在重用相同的错误代码，因此无需在属性文件中再次添加它们。
5.  注释 BookVlidator1 的 bean，并在 books-servlet.xml 中添加 BookVlidator2 的 bean，如下所示：

```
      <bean id="validator"  
        class="com.packt.ch06.validators.BookValidator2" /> 

```

6.  执行应用程序并提交空白表单以获得从属性文件中显示的验证消息。

### 基于 JSR 注释的验证

JSR303 是一个 bean 规范，它定义元数据和 API 来验证 J2EE 应用程序中的 bean。最新的市场是 JSR 349，它是 JSR 303 的扩展，提供开放性、密度注入和 CDI、方法验证、组转换、与其他规范的集成等功能。Hibernate 验证器是一个众所周知的可用参考实现。validation.*包提供了用于验证的 API。

以下是验证中使用的几个常见注释：

*   @NotNull：检查带注释的值是否为非 null，但不能检查空字符串。
*   @Null：检查带注释的值是否为 Null
*   @模式：它检查带注释的字符串是否与给定的正则表达式匹配。
*   @过去：检查注释值是否为过去的日期。
*   @Future：检查注释值是否为将来的日期。
*   @Min：它确保带注释的元素是一个数字，其值等于或大于指定值。
*   @Max：它确保带注释的元素是一个数字，其值等于或小于指定值。
*   @AssertFalse：它确保带注释的元素为 false。
*   @AssertTrue：它确保带注释的元素为 true。
*   @大小：它确保注释的元素位于最大值和最小值之间。

除了上述由 Bean 验证 API 定义的注释外，Hibernate Validator 还提供了以下附加注释：

*   @CreditCardNumber：它检查带注释的值是否遵循传递给它的字符序列。
*   @电子邮件：用于根据指定的表达式检查指定字符跟在有效电子邮件地址后面
*   @长度：它检查注释元素的字符数是否受注释指定的“最小”和“最大”属性的限制。
*   @NotBlank：它检查带注释的元素是否不为 null，并且长度是否大于零。
*   @NotEmpty：它确保带注释的元素既不是 null 也不是空的。

让我们通过以下步骤创建 ReadMyBooks 应用程序的副本，以实现基于 JSR 的验证：

#### 第 1 部分：创建基础应用程序

1.  将 ReadMyBooks\u JSR\u 验证创建为动态 web 应用程序。
2.  添加我们在早期应用程序中添加的所有必需的 jar。
3.  除了这些 jar，还添加了 hibernate-validator-5.0.1.final.jar、classmate-0.5.4.jar、jboss-logging-3.1.0.GA.jar 和 validation-api-1.1.0.final.jar
4.  复制 com.packt.ch06.beans 和 com.packt.ch06.controllers 包及其内容。
5.  在 WebContent 中复制 index.jsp 和 searchByAuthor.jsp。
6.  在 web.xml 文件中添加 DispatcherServlet 映射。
7.  在 WEB-INF 中复制 books-servlet.xml
8.  复制 WEB-INF 中 WebContent 和 jsps 文件夹中的图像及其内容。

#### 第二部分：应用验证

1.  让我们在 Book.java 上应用 hibernate validator API 提供的验证，如下所示：

```
      public class Book { 
        @NotEmpty 
        @Size(min = 2, max = 30) 
        private String bookName; 

        @Min(150) 
        private long ISBN; 

        @NotEmpty 
        @Size(min = 2, max = 30) 
        private String publication; 

        @NotNull 
        private int price; 

        @NotEmpty 
        @Size(min = 10, max = 50) 
        private String description; 

        @NotEmpty 
        private String author; 

        //default and parameterized constructor 
        //getters and setters 
      } 

```

2.  让我们更新`AddBookController`为，
3.  删除验证程序数据成员。
4.  删除 initBinderMethod。
5.  保持`addBook()`方法的书本参数上应用的`@Valid`注释不变。
6.  从 books-servlet.xml 中删除 bean for validator，因为不再需要它。
7.  XML 中 messageResource 的注释 bean 我们稍后将使用它。
8.  请确保在 BooServ.L.xml 中输入 AutoT0.条目以不能在控制器中考虑注释。
9.  运行应用程序。提交空白表单时，您将收到以下响应，显示默认验证消息：

![](https://www.packtpub.com/graphics/9781787120341/graphics/image_06_009.png)

消息的定制可以通过使用“message”属性来完成，也可以使用 properties 文件将消息外部化。让我们一个接一个地做。

##### 使用“消息”属性

bean 类中用于验证数据的每个注释都具有“message”属性。开发人员可以使用它传递适当的消息，如下代码所示：

```
public class Book { 
  @NotEmpty(message="The book name should be entered") 
  private String bookName; 

  @Min(value=150,message="ISBN should be greater than 150") 
  private long ISBN; 

  @Size(min = 2, max = 30, message="Enter Publication between   
    limit of 2 to 30 only") 
  private String publication; 

  @NotNull(message="Enter the price") 
  private int price; 
  @Size(min = 10, max = 50,message="Enter Publication between limit of
    10 to 50 only") 
  private String description; 

  @NotEmpty(message="Enter the price") 
  private String author; 
  /default and parameterized constructor 
  //getters and setters 
} 

```

保持所有其他代码不变并更改 Book.java（如上所示），运行应用程序。如果发生任何违反验证规则的情况，将显示为“消息”属性配置的消息。

##### 使用属性文件

开发人员可以将属性文件中的消息外部化，在违反验证的情况下从该文件加载消息，就像我们在前面的应用程序中所做的那样。

让我们在应用程序中使用以下步骤添加属性文件：

1.  在 WEB-INF 中创建一个文件 messages\u book\u validation.properties，并添加到要显示的违规规则和消息的映射中，如下所示：

```
      NotEmpty.book.bookName=Please enter the book name F1\. 
      NotEmpty.book.author=Please enter book author F1\. 
      Min.book.ISBN= Entered ISBN must be greater than 150 F1 
      Size.book.description=Please enter book description having  
        minimum 2 and maximum 30charatcters only F1\. 
      NotNull.book.price=Please enter book price F1\. 

```

在每个文件的末尾特意添加了 F1，以了解消息是从 bean 类还是从属性文件中提取的。您不必将它们添加到实际文件中。我们特意没有为“publication”数据成员添加任何消息来理解消息的提取。

写入属性文件的语法如下所示：

```
      Name_of_validator_class.name_of_model_attribute_to_validate. 
        name_of_data_member= message_to_display 

```

2.  取消对 book-servlet.xml 中的 bean“`messageResource'`的注释，如果没有，则添加一个，如下所示：

```
      <bean id="messageSource" 
        class="org.springframework.context.support. 
        ReloadableResourceBundleMessageSource"> 
        <property name="basename"  
          value="/WEB-INF/messages_book_validation" /> 
      </bean> 

```

3.  运行应用程序，在提交空白表单时，属性文件中的消息将被加载到“发布”中，如下所示：

![](https://www.packtpub.com/graphics/9781787120341/graphics/image_06_010.png)

## 总结

* * *

我们在此应用程序中讨论了 web 层。我们讨论了 SpringMVC 框架声明用户定义控制器的工作。我们讨论了使用 ModelAndView 中的模型对象显示值时使用的视图。我们还讨论了框架如何发现视图，以及如何使用 ViewResolver 从 ModelAndView 中设置的逻辑名称呈现视图。讨论继续到表单处理，我们深入讨论了表单提交以使用表单支持对象和使用@modeldattribute 注释预填充表单。由于包含不正确的值，可能导致业务逻辑中出现异常或失败。这个问题的解决方案是表单验证。我们在 Spring 自定义验证器和 hibernate 验证器提供的基于注释的验证的帮助下讨论了表单验证。我们还发现了如何使用 MessageResourceBundle 实现消息的外部化。在下一章中，我们将继续讨论如何对应用程序进行测试，以最大限度地降低应用程序上线时出现故障的风险。