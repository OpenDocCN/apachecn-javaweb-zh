## 第二章依赖注入

上一章介绍了什么是 Spring 框架，以及它如何帮助开发人员使开发更快、更容易。但“如何使用该框架？”这个问题仍然没有答案。在本章中，我们将从各个角度讨论答案，并试图找出所有可能的答案。本章充满了配置和配置的备选方案。这完全取决于开发人员在应用程序的可用条件和环境设置下对这些解决方案的期望。我们的目标是深入讨论以下几点。

*   我们将从 Bean 生命周期管理开始，在 Bean 生命周期中使用自定义初始化、初始化 Bean、DisposableBean 和 Aware 接口，以及@PostConstruct 和@PreDestroy 等注释
*   依赖注入
*   Setter 和构造函数依赖项注入
*   用于引用、内部 bean、继承和集合的 DI
*   Bean 作用域和将作用域配置为单例或原型
*   自动布线及实现自动布线的方法
*   自动布线时出现的问题及解决方法

有很多事情要讲，所以让我们从第一个“豆子的生活”开始。

## 豆子的生命

* * *

SpringIOC 容器隐藏了容器和 bean 之间的复杂通信。下图给出了容器维护每个 bean 生命周期所遵循的步骤：

![](https://www.packtpub.com/graphics/9781787120341/graphics/image_02_001.png)

大豆生命周期

### 加载配置

这是豆子生命周期中最重要的阶段，它启动了生命周期过程。容器从 bean 配置文件加载和读取元数据信息，并开始下一阶段的“实例化”。

### 对象创建

Spring 容器使用 Java 反射 API 创建 bean 的实例。

### 设置 bean 名称

每个 bean 都包含在配置中配置的唯一名称。此名称可通过`setBeanName()`提供给 bean 类。如果 bean 类实现了`BeanNameAware`接口，则会调用其`setBeanName()`方法来设置 bean 名称。

### 立豆厂

有时，bean 类可能需要获取有关加载它的工厂的信息。如果 bean 类实现了`BeanFactoryAware`，则会调用其`setBeanFactory()`方法，并将`BeanFactory`的实例传递给它，该实例可能是`ApplicationContext`、`WebApplicationContext`等的实例。

### 初始化前带有后处理的 Bean 后处理

在某些场景中，在填充对象的值之前，需要进行一些预初始化，这在配置文件中无法完成。在这种情况下，如果 BeanPostProcessor 的对象执行此任务。BeanPostProcessor 是一种特殊的 bean，它在实例化任何其他 bean 之前先得到实例化。这些 BeanPostProcessorbean 与容器创建的新实例交互。但是，它将分两步完成，一步是在设置属性之前，另一步是在设置属性之后。在此阶段，将调用与 BeanFactory 关联的 BeanPostProcessor 的后处理器预初始化，以执行预初始化。

### 物业人口

可以使用一些 bean 属性指定 bean 配置。在此阶段中，所有值都将与前一阶段中初始化的实例相关联。

### 初始化带有

#### AfterPropertieSet（）方法

在配置中配置的 bean 可能没有设置所有属性的值。一旦填充了属性，就需要使用一些业务逻辑或以其他方式设置其余属性。`InitializingBean`界面帮助完成任务。如果类实现了`InitializingBean`接口，将调用其`afterPropertiesSet()`方法来设置这些属性。

#### 自定义 init（）方法

尽管`afterProperties()`有助于基于某些逻辑进行属性初始化，但代码与 SpringAPI 紧密耦合。为了克服这个缺点，有一种使用自定义初始化方法初始化 bean 的方法。如果开发人员编写了自定义的`init`方法，并在 bean 配置中将其配置为“`init-method`属性，则容器将调用该方法。

### 带 postProcessAfterInitialization 的 Bean 后处理

初始化属性后，将调用 BeanPostProcessor 的`postProcessAfterInitialization()`来执行`postProcessing`。

### 使用豆子

感谢上帝！！！！是的，现在该对象已完全准备好使用，其状态已定义。

### 用

开发人员使用了这些对象，这些对象已经完成了他们的任务。现在我们不再需要它们了。要释放 bean 占用的内存，可以通过，

#### 用 destroy（）处理豆子

如果 bean 类实现了 DisposableBean 接口，那么将调用其 destroy（）方法来释放内存。它与初始化 bean 有相同的缺点。为了克服这个问题，我们有定制的销毁方法。

#### 自定义销毁的销毁（）

也可以编写自定义方法来释放内存。当在 bean 配置定义中配置了属性“destroy method”时，将调用它。

*   在了解了生命周期之后，现在让我们做一些实现来了解实现透视图。

### 案例 1：使用自定义初始化销毁方式

正如我们在 bean 生命周期中已经讨论过的，这两种方法将利用开发人员编写自己的初始化和销毁方法。由于开发人员没有与 SpringAPI 耦合，他们可以利用选择自己的方法签名的优势。

让我们看看如何一步一步地钩住这些方法以便 Spring 容器使用：

1.  创建一个 Java 应用程序作为 Ch02_Bean_Life_Cycle，并将其添加到我们在上一个项目中所做的 jar 中。
2.  在包 com.ch02.beans 下创建一个类 Demo_Custom_Init，如下所示：

```
      public class Demo_Custom_Init { 
        private String message; 
        private String name; 

        public Demo_Custom_Init() { 
          // TODO Auto-generated constructor stub 
          System.out.println(""constructor gets called for  
            initializing data members in Custom init""); 
          message=""welcome!!!""; 
          name=""no name""; 
        } 

        @Override 
        public String toString() { 
          // TODO Auto-generated method stub 
          return message+""\t""+name; 
        } 
      } 

```

3.  使用以下代码添加类 a 方法 myInit（）以进行初始化。这里我们将“名称”转换为大写：

```
        public void myInit() 
        { 
          name=name.toUpperCase(); 
          System.out.println(""myInit() get called""); 
        } 

```

4.  在类路径中创建 bean_lifecycle.xml，以类似于上一个项目配置 bean（请参阅 Ch01_Container_initization 中的 bean_classpath.xml）
5.  添加到 it bean 定义中，如下所示：

```
      <?xml version=""1.0"" encoding=""UTF-8""?> 
      <beans " 
        xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" 
        xsi:schemaLocation= 
          "http://www.springframework.org/schema/beans 
          http://www.springframework.org/schema/beans/
          spring-beans.xsd"> 

        <bean id="obj" class="com.ch02.beans.demo_Custom_Init"></bean> 
      </beans> 

```

*每个 bean 必须在<bean>标记中配置。</bean>

*<bean>标记包含许多属性，我们需要配置其中至少两个属性，如下所示：</bean>

*   A.id：指定容器识别其管理对象的引用名称。'id'在容器中必须是唯一的。命名“id”类似于 Java 应用程序中的引用。

*   B 类：指定正在创建和管理的对象容器。class 属性的值必须是完全限定的类名，正如我们在上面的配置中所做的那样。

*   在 XML 中配置 bean 定义的语法如下所示：

```
      <bean id="id_to_use" class="fully_qualified_class_name"></bean>
```

*   XML 配置相当于 Java 代码，如下所示：，

```
      Demo_Custom_Init obj= new  com.ch02.beans.Demo_Custom_Init();
```

### 注

开发人员可以在配置中使用的属性很少。我们将在接下来的章节中根据场景逐一看到它们。

6.  步骤 5 中显示的配置是非常基本的配置，没有向容器提供关于如何初始化属性“name”的任何信息。让我们通过添加属性“init method”来修改配置，以指定方法名称，该名称将在实例化后被调用以初始化属性。修改后的代码如下所示：

```
      <bean id="obj" class="com.ch02.beans.demo_Custom_Init"
        init- method=""myInit""> 
      </bean> 

```

7.  我们执行初始化的方式，与释放资源的方式相同。要使用自定义析构函数方法发布，我们需要首先将其添加到代码中，如下所示：

```
      public void destroy() 
      { 
        name=null; 
        System.out.println(""destroy called""); 
      } 

```

8.  通过指定 destroy method，在 bean 配置中配置 destroct 方法，如下代码所示：

```
      <bean id="obj" class="com.ch02.beans.demo_Custom_Init"
        init-method="myInit" destroy-method="destroy"> 
      </bean> 

```

9.  使用主功能创建`Test_Demo_Custom_Init`。正如我们在第 1 章前面所做的那样初始化容器。并使用`getBean()`获取`Demo_Custom_Init`实例，如下图：

```
      public static void main(String[] args) { 
        // TODO Auto-generated method stub 
        ApplicationContext context=new
        ClassPathXmlApplicationContext("beans_lifecycle.xml");
        Demo_Custom_Init obj=(Demo_Custom_Init)context.getBean("obj"); 
        System.out.println(obj); 
      } 

```

10.  代码的执行会产生以下输出：

```
      INFO: Loading XML bean definitions from class path resource 
      [beans_lifecycle.xml] 
      constructor gets called for initializing data members 
      myInit() get called 
      welcome!!!  NO NAME 

```

输出清楚地显示了生命周期的各个阶段，如 bean 的构建、初始化、使用和销毁。

如果没有“销毁调用”语句，不要感到惊讶。我们可以使用以下代码优雅地关闭容器：

```
((AbstractApplicationContext)context).registerShutdownHook(); 

```

在主函数中添加上述行时，甚至“destroy called”也将被视为控制台输出。

### 案例 2：使用 InitializingBean 提供初始化

我们将使用案例 1 中开发的相同项目 Ch02\u Bean\u 生命周期。

按照以下步骤操作：

1.  在 com.ch02.beans 包中添加一个类 Demo_InitializingBean，该包正在实现 InitializingBean 接口，如下所示：

```
      public class Demo_InitializingBean implements InitializingBean { 
         private String message; 
        private String name; 

        public Demo_InitializingBean() { 
          // TODO Auto-generated constructor stub 
          System.out.println(""constructor gets called for   
            initializing data members in demo Initializing bean""); 
          message=""welcome!!!""; 
          name=""no name""; 
        } 
        @Override 
        public String toString() { 
          // TODO Auto-generated method stub 
          return message+""\t""+name; 
        } 
      } 

```

2.  重写 AfterPropertieSet（）方法以处理属性，如下所示：

```
      @Override 
      public void afterPropertiesSet() throws Exception { 
        // TODO Auto-generated method stub 
        name=""Mr.""+name.toUpperCase(); 
        System.out.println(""after propertiesSet got called""); 
      } 

```

3.  向 bean_lifecycle.xml 中再添加一个 bean，如下所示：

```
      <bean id="obj_Initializing"  
        class="com.ch02.beans.Demo_InitializingBean"/> 

```

您可以观察到，在这里我们不必像在案例 1 中那样重写任何 init method 属性，因为 afterPropertieSet（）在设置属性后通过回调机制获取调用。

4.  使用 main 方法创建一个类 Test_initializebean，如下代码所示：

```
      public static void main(String[] args) { 
        // TODO Auto-generated method stub 
        ApplicationContext context=new  
        ClassPathXmlApplicationContext(""beans_lifecycle.xml""); 

        Demo_InitializingBean obj=    
          (Demo_InitializingBean)context.getBean(""obj_Initializing""); 
        System.out.println(obj);  
      } 

```

5.  输出的执行如下图所示：

```
      INFO: Loading XML bean definitions from class path resource 
      [beans_lifecycle.xml] 
      constructor gets called for initializing data members in Custom
        init 
      myInit() get called 
      constructor gets called for initializing data members in demo        initializing bean 
      after propertiesSet got called 
      welcome!!!  Mr.NO NAME 

```

从上面的输出来看，带下划线的语句与新配置的 bean 无关。但当容器初始化所有配置的 bean 时，它也会初始化`Demo_Custom_Init`bean。

### 案例 3：使用 DisposableBean 提供内存释放

我们将使用案例 1 中开发的相同项目 Ch02\u Bean\u 生命周期。

按照以下步骤操作：

1.  在 com.ch02.beans 包中添加一个类 Demo_DisposableBean.in，该类实现 DisposableBean 接口，如下所示：

```
      public class Demo_DisposableBean implements DisposableBean { 
         private String message; 
        private String name; 

        public Demo_DisposableBean() { 
          // TODO Auto-generated constructor stub 
          System.out.println("constructor gets called for  
            initializing data members in Disposable Bean"); 
          message="welcome!!!"; 
          name="no name"; 
        } 

        @Override 
        public String toString() { 
          // TODO Auto-generated method stub 
          return message+""\t""+name; 
        } 
      } 

```

2.  重写内存释放的 destroy（）方法，如下所示：

```
      @Override 
      public void destroy() throws Exception { 
        // TODO Auto-generated method stub 
        System.out.println("destroy from disposable bean get called"); 
        name=null; 
      } 

```

3.  向 bean_lifecycle.xml 中再添加一个 bean，如下所示：

```
      <bean id="obj_Disposable"    
        class="com.ch02.beans.Demo_DisposableBean"/> 

```

您可以看到，我们不必像在案例 1 中那样重写任何 destroy 方法属性。当包含 bean 的容器关闭后，`destroy()`将获得回调。

4.  使用以下代码创建类测试\u DisposableBean：

```
      public static void main(String[] args) { 
        // TODO Auto-generated method stub 
        ApplicationContext context=new  
          ClassPathXmlApplicationContext(""beans_lifecycle.xml""); 

        Demo_DisposableBean obj=  
          (Demo_DisposableBean)context.getBean("obj_Disposable"); 
        System.out.println(obj);         
        ((AbstractApplicationContext)context).registerShutdownHook(); 
      } 

```

5.  我们将在执行 main 时获得以下代码：

```
      INFO: Loading XML bean definitions from class path resource 
      [beans_lifecycle.xml] 
      constructor gets called for initializing data members in Custom
        init 
      myInit() get called 
      constructor gets called for initializing data members in demo         initializing bean 
      after propertiesSet got called 
      constructor gets called for initializing data members in 
        Disposable Bean 
      welcome!!!  no name 
      Sep 09, 2016 10:54:55 AM 
      org.springframework.context.support.
      ClassPathXmlApplicationContext doClose 
      INFO: Closing
      org.springframework.context.support.
      ClassPathXmlApplicationContext@1405ef7: startup date
      [Fri Sep 09  10:54:54 IST 2016]; root of context hierarchy 
      destroy from disposable bean get called destroy called 

```

带下划线的行来自一次性演示中的 destroy（），但因为`Demo_Custom_Init`类也有自定义的`destroy()`方法。

### 案例四：让豆子意识到容器

我们将使用案例 1 中开发的相同项目 Ch02\u Bean\u 生命周期。

按照以下步骤操作：

1.  在 com.ch02.contextaware 包中添加一个类 MyBean，该包正在实现 ApplicationContextAware 接口。
2.  将数据成员添加到 ApplicationContext 类型的 bean 类中。
3.  重写方法 setApplicationContext（）方法。
4.  添加 display（）以获取一个 bean 并显示其属性。课程将如下所示：

```
      public class MyBean implements ApplicationContextAware { 
        private ApplicationContext context; 

        @Override 
        public void setApplicationContext(ApplicationContext ctx)  
          throws BeansException { 
          // TODO Auto-generated method stub 
          System.out.println(""context set""); 
          this.context=ctx; 
        } 
        public void display() 
        { 
          System.out.println((Demo_InitializingBean) 
            context.getBean(""obj_Initializing"")); 
        } 
      } 

```

这里我们访问的是另一个 bean，它不是类的数据成员，也不是注入的。但是代码显示我们仍然可以访问它们的属性。

5.  在`bean_lifecycle.xml`中再添加一个 bean，如下所示：

```
      <bean id=""obj_myBean"" class=""com.ch02.contextAware.MyBean""/> 

```

6.  使用 main 方法创建一个类 Test_MyBean，如下所示：

```
      public static void main(String[] args) { 
        // TODO Auto-generated method stub 
        ApplicationContext context=new  
          ClassPathXmlApplicationContext(""beans_lifecycle.xml""); 

        MyBean obj=(MyBean)context.getBean(""obj_myBean""); 
        obj.display(); 
      } 

```

7.  执行时，我们将获得如下输出：

```
      constructor gets called for initializing data members in Custom
      init 
      myInit() get called 
      constructor gets called for initializing data members in demo        initializing bean 
      after propertiesSet got called 
      constructor gets called for initializing data members in
      Disposable Bean 
      context set 
      welcome!!!  Mr.NO NAME 

```

### 案例四：使用 BeanPostProcessor。

我们将使用案例 1 中开发的相同项目 Ch02\u Bean\u 生命周期。

按照以下步骤操作：

1.  在实现 BeanpostProcessor 的 com.ch02.bean 包中添加一个 bean 类 Demo_BeanpostProcessor。
2.  重写方法 postProcessBeforeInitialization（）方法。
3.  重写方法 postProcessAfterInitialization（）方法。
4.  完整的类定义如下所示，

```
      public class Demo_BeanPostProcessor implements BeanPostProcessor
      { 
        @Override 
        public Object postProcessBeforeInitialization(Object bean,  
          String beanName) throws BeansException { 
          // TODO Auto-generated method stub 
          System.out.println("initializing bean before init:-    
            "+beanName); 
          return bean; 
        } 

        @Override 
        public Object postProcessAfterInitialization(Object bean,  
          String beanName) throws BeansException { 
          // TODO Auto-generated method stub 
          System.out.println("initializing bean after init:- 
            "+beanName); 
          return bean; 
        } 
      } 

```

5.  向 bean_lifecycle.xml 中再添加一个 bean，如下所示：

```
      <bean id=""beanPostProcessor""  
        class=""com.ch02.processor.Demo_BeanPostProcessor""/> 

```

6.  用 main 方法创建一个类`TestBeanPostProcessor`。我们不必向 bean 请求“`beanPostProcessor''`，因为它的方法是在容器中每个 bean 的 init 方法之前和之后调用的。
7.  编写测试代码，查找初始化过程中调用方法的顺序，如下所示：

```
      public class Test_BeanPostProcessor { 
        public static void main(String[] args) { 
          // TODO Auto-generated method stub 
          ApplicationContext context=new  
            ClassPathXmlApplicationContext("beans_lifecycle.xml"); 

          Demo_Custom_Init  
            obj=(Demo_Custom_Init)context.getBean(""obj""); 
          System.out.println(obj); 
        } 
      } 

```

8.  输出如下图所示：

```
      INFO: Loading XML bean definitions from class path resource
        [beans_lifecycle.xml] 
      initializing bean before init:-
      org.springframework.context.event.
      internalEventListenerProcessor 
      initializing bean after init:-
      org.springframework.context.event.internalEventListenerProcessor 
      initializing bean before init:- 
      org.springframework.context.event.internalEventListenerFactory 
      initializing bean after init:-
      org.springframework.context.event.internalEventListenerFactory 
      constructor gets called for initializing data members in Custom
      init 
      initializing bean before init:- obj 
      myInit() get called 
      initializing bean after init:-obj 
      constructor gets called for initializing data members in demo           initializing bean 
      initializing bean before init:- obj_Initializing 
      after propertiesSet got called 
      initializing bean after init:-obj_Initializing 
      constructor gets called for initializing data members in              Disposable Bean 
      initializing bean before init:- obj_Disposable 
      initializing bean after init:-obj_Disposable 
      context set 
      initializing bean before init:- obj_myBean 
      initializing bean after init:-obj_myBean 
      welcome!!!  NO NAME 

```

带下划线的语句用于我们从容器中请求的 bean。但是找到构造函数、`postProcessBeforeInitialization`方法、自定义初始化方法、`postProcessAfterInitialization`所遵循的顺序。

### 注

在一个应用程序中，可以配置多个`BeanPostProcessors`。如果 bean 实现了有序接口，则可以通过设置“order”属性来管理它们的执行顺序。每个`PostBeanProcessor`的范围是每个容器。

## 对 bean 生命周期使用 JSR-250 注释

* * *

JSR-250 注释在 bean 生命周期中起着至关重要的作用，但我们不会直接跳转并发现它们。这样做可能会导致我们跳过一些非常重要的概念。因此，我们将在基于 JSR 的注释时讨论它们。但是，如果您已经了解 Spring，在 Spring 中使用注释，并且非常渴望使用@PreDestroy 或@PostConstruct，那么您可以直接转到主题 JSR 注释。

在 Java 的巨大开发中，企业应用程序通过编写较小的代码单元（通常是类）来简化。然后，开发人员通过调用彼此的方法重用它们。这是一个非常复杂且难以维护的体系结构。为了调用另一个类的方法，它的知识很重要。保存另一个类的对象的类称为容器。容器持有的对象称为包含对象。现在容器很清楚地知道所包含的对象。开发人员将非常高兴，因为现在他们可以轻松地重用包含的对象，从而简化了他们的开发。但是现在在设计上有一个很大的缺陷。这可以用以下两个非常著名的术语很好地解释：

*   **松耦合**：即使包含的对象发生了变化，容器类也不会受到影响。这种场景中的容器称为松散耦合对象。开发人员总是试图写下遵循松耦合的代码。在 Java 中，通过接口编程可以很好地实现松散耦合。接口说明了合同是什么？但它没有具体说明合同将由谁和如何执行。容器类对依赖关系的了解将更少，从而使其更加灵活。
*   **紧耦合**：只要包含的对象中有代码更改，容器类就需要更改。容器与容器对象紧密耦合，这使得开发变得困难。

### 注

尽量避免编写紧密耦合的类。

无论是松耦合还是紧耦合，我们都可以得到可重用的对象。现在的问题是如何创建这些对象。在 Java 中，可以通过以下两种主要方式创建对象：

*   构造函数调用。
*   工厂提供物品

作为一个抽象级别，这两种方式看起来都很相似，因为最终用户将获得一个要使用的对象。但这些都不一样。在工厂中，依赖类负责创建对象，在构造函数中直接调用构造函数。Java 应用程序以对象为中心并围绕对象旋转。每个开发人员首先要尝试正确初始化对象，以便以复杂的方式处理数据和执行操作。实例创建和状态初始化是创建每个正确初始化的对象的两个步骤。由于容器将涉及这两个过程，我们应该对这两个过程都有很好的了解。让我们从实例创建开始。

## 实例创建

* * *

在 java 中，以下是创建实例的两种方法：

*   使用构造函数
*   使用工厂法

我将不详细讲述什么时候使用哪种方式的场景，因为我们都来自 Java 背景，并且已经做了很多次或者读了很多次原因。我们将直接从如何在 Spring 框架中逐个使用它们开始。

### 使用构造函数

让我们以一辆汽车为例，通过以下步骤明确容器将如何创建汽车对象：

1.  创建 Java 应用程序 Ch02_ 实例 _ 创建并添加我们在上一个项目中添加的 JAR。
2.  在 com.ch02.beans 包中创建一个类 Car，并将 chesis 编号、颜色、燃料类型、价格、平均值作为数据成员。代码如下所示：

```
      class Car{ 
        private String chesis_number, color, fuel_type; 
        private long price; 
        private double average; 

        public Car() { 
          // TODO Auto-generated constructor stub 
          chesis_number=""eng00""; 
          color=""white""; 
          fuel_type=""diesel""; 
          price=570000l; 
          average=12d; 
        } 
      } 

```

3.  在汽车中添加 show（），如下所示：

```
      public void show() 
      { 
        System.out.println(""showing car ""+chesis_number+"" having      
          color:-""+color+""and price:-""+price); 
      } 

```

4.  当开发人员尝试创建对象时，代码如下所示：

```
      Car car_obj=new Car(); 

```

现在我们需要在 XML 文件中配置`BeanDefination`，该文件表示一个 bean 实例，这样 bean 将由 Spring 容器管理。

1.  在`Classpath`中创建`instance.xml`来配置我们的车`BeanDefination`需要配置如下：

```
      <bean id=""car_obj"" class=""com.ch02.beans.Car""/> 
      </beans> 

```

2.  在默认包中创建带有 main 函数的 TestCar，以使 bean 使用业务逻辑。

*获取 Spring 容器实例。我们将使用 ClassPathXmlApplicationContext，如容器初始化中所述。

*从容器中获取 bean 实例。

代码如下：

```
      public class TestCar { 
        public static void main(String[] args) { 
          // TODO Auto-generated method stub 
          ApplicationContext context=new      
            ClassPathXmlApplicationContext(""instance.xml""); 
          Car car=(Car)context.getBean(""car_obj""); 
          car.show(); 
        }  
      } 

```

输出如下图所示：

![](https://www.packtpub.com/graphics/9781787120341/graphics/image_02_002.png)

图 02

从输出中可以清楚地看到，容器使用了默认构造函数来定义值。让我们通过在如下代码中添加默认构造函数来证明这一点：

```
public Car() { 
  // TODO Auto-generated constructor stub 
  chesis_number=""eng00""; 
  color=""white""; 
  fuel_type=""diesel""; 
  price=570000l; 
  average=12d; 
} 

```

更新后的输出将如以下快照所示：

![](https://www.packtpub.com/graphics/9781787120341/graphics/image_02_003.png)

### 采用工厂法

bean 在 Spring 容器中配置，其对象通过实例或静态工厂方法创建。

#### 使用实例工厂法

实例创建将通过 bean 的非静态方法完成。要使用该方法创建实例，必须配置属性“factory-method”。有时还可以使用其他类来创建实例。“factory-bean”属性将与容器用于创建实例的“factory-method”一起配置。

让我们按照以下步骤使用 factory 方法创建实例。我们将使用相同的 Ch02_ 实例 _ 创建。

1.  在 com.ch02.factory 中创建 CarFactory 类，如下代码所示：

```
      public class CarFactory { 
        private static Car car=new Car(); 

        public Car buildCar() 
        { 
          System.out.println(""building the car ""); 
          return car; 
        } 
      } 

```

`buildCar()`方法将构建 Car 实例并返回它。现在，使容器意识到使用上述代码的任务将由 bean 定义完成。

2.  在 instance.xml 文件中添加两个 bean，一个用于 CarFactory，另一个用于 Car，如下所示：

```
      <bean id="car_factory" class="com.ch02.factory.CarFactory" /> 
      <bean id="car_obj_new" factory-bean="car_factory"
        factory-method="buildCar" /> 

```

属性工厂方法指定`buildCar`作为从工厂 bean 属性指定的`car_factory`开始用于实例创建的方法。这里不需要指定 class 属性。

3.  使用以下代码创建带有 main 函数的 TestCarFactory：

```
      public static void main(String[] args) { 
        // TODO Auto-generated method stub 
        ApplicationContext context = new    
          ClassPathXmlApplicationContext(""instance.xml""); 
        Car car = (Car) context.getBean(""car_obj_new""); 
        car.show(); 
      } 

```

1.  执行时，将显示以下快照，

![](https://www.packtpub.com/graphics/9781787120341/graphics/image_02_004.png)

#### 采用静态工厂法

我们可以在返回对象的类中定义静态方法。属性“factory method”用于指定创建实例的方法名。在以下步骤的帮助下，让我们使用 Ch02_ 实例 _ 创建项目来使用 factory 方法属性。

1.  在 com.ch02.service 包中创建 CarService 类，如下所示：

```
      public class CarService { 
        private static CarService carService=new CarService(); 
        private CarService(){} 
        public static CarService createService() 
        { 
          return carService; 
        } 
        public void serve() 
        { 
          System.out.println(""car service""); 
        }  
      } 

```

2.  添加 XML 格式的配置，如下所示：

```
      <bean id="carService" factory-method="createService"       
        class="com.ch02.service.CarService"/> 

```

**‘工厂方法’**指定返回实例的方法。

3.  在 TestCarService 中编写测试代码，如下所示：

```
      public static void main(String[] args) { 
        // TODO Auto-generated method stub 
        ApplicationContext context = new  
          ClassPathXmlApplicationContext(""instance.xml""); 
        CarService carService = (CarService)     
          context.getBean(""carService""); 
        carService.serve(); 
      } 

```

代码的执行给出如下输出，如下所示：

![](https://www.packtpub.com/graphics/9781787120341/graphics/image_02_005.png)

创建实例后，现在是初始化状态的时候了。Java 开发人员的初始化状态如下所示：

```
car.setChessis_Number(""as123er""); 
car.setColor(""baker''s chocolate""); 
car.setFuel_Type(""Petrol""); 
car.setPrice(689067L); 
car.setAverage(21); 

```

在这里，如果我们改变数据成员的值，状态也会改变。所以很明显，汽车依赖于数据成员值。但是，正如我们在这里设置的那样，这些值是代码的一部分，它们中的任何更改都需要更改代码或重新部署代码。在依赖注入中，设计是以这样一种方式完成的，即对象从外部获得其状态，而不是从一段代码中硬编码它们。

## 依赖注入

* * *

依赖倒置原则规定两个模块之间不应紧密耦合。在没有指定依赖关系细节的情况下，应该使用抽象来定义模块。依赖倒置原则（DIP）有助于确保松散耦合的模块化编程。依赖注入是 DIP 的实现。要知道什么是依赖注入，我们首先必须清楚地了解什么是依赖？

对象的状态由其数据成员的值给出。我们都知道，这些数据成员可以是基本类型或次要类型。如果数据成员是基元，则它们直接以辅助数据类型获取其值，该值取决于该对象的状态。这意味着无论何时发生对象初始化，数据成员初始化都起着非常重要的作用。换句话说，我们可以说数据成员是对象初始化中的依赖项。在对象上插入或设置依赖项的值就是依赖项注入。

依赖项注入有助于实现松散耦合的体系结构。松耦合有助于轻松测试模块。代码和代码使用的值是分开的，可以通过中央配置进行控制，从而便于代码维护。代码不受影响，因为这些值位于外部配置中，因此易于迁移，更改最少。

在 Spring 框架中，依赖项注入可以通过以下方式实现：，

*   设值注入
*   构造函数注入

以上两种是我们可以用于 DI 的方法，但可以通过以下几种方法实现：

*   基于 XML 的配置
*   命名空间为“p”的基于 XML 的配置
*   基于注释的配置

让我们开始一个接一个地探索它们

### 基于 XML 的配置

### 塞特注射

对象的依赖关系由 setter 注入中的 setter 方法实现。因此，非常重要的一点是，当我们进行 setter 注入时，需要有一个 bean，它的数据成员将通过 setter 方法进行设置。使用 setter 注入的步骤如下：

1.  使用标准 java 命名约定声明类及其属性。
2.  在 bean 定义 XML 中配置 bean，如下所示：

```
      <bean id="bean_id" class="fully qualified _class_name"></bean> 

```

3.  上述配置中的 bean 创建实例。必须对其进行更新以配置属性。

*每个<property>标记将配置一个数据成员</property>

*每个<property>标记接受两个值</property>

 1\. name:“name”属性指定开发人员要配置其值的数据成员的名称。

 2\. 值：“值”指定要给数据成员的值。

更新的配置如下所示：

```
      <bean id="bean_id" class="fully qualified _class_name"> 
        <property name="name_of_property" value="value_of_property"> 
      </bean> 

```

如果要设置多个数据成员的值，则需要使用多个<property>标记。</property>

4.  从 Spring 容器中获取 bean，就可以使用它了。

首先，让我们通过以下步骤了解如何使用 setter 注入配置 bean：

1.  将 Ch02_ 依赖项 _ 注入创建为 Java 项目。
2.  再加上我们在前一章中已经使用过的所有核心弹簧罐。
3.  在 com.ch2.beans 中创建一个类 Car。您可以参考上一个项目（Ch02_ 实例 _ 创建）中的代码。

*由于我们将使用 setter 注入注入依赖项，因此也要创建 setter 方法。

*还要添加 show（）方法。

代码如下：

```
      public class Car { 
        private String chesis_number, color, fuel_type; 
        private long price; 
        private double average; 

        public void setChesis_number(String chesis_number) { 
          this.chesis_number = chesis_number; 
        } 

        public void setColor(String color) { 
          this.color = color; 
        } 

        public void setFuel_type(String fuel_type) { 
          this.fuel_type = fuel_type; 
        } 

        public void setPrice(long price) { 
          this.price = price; 
        } 

        public void setAverage(double average) { 
          this.average = average; 
        } 

        public void show() { 
          System.out.println("showing car "+chesis_number+" 
            having color:-"+color+"and price:-"+price); 
        } 
      } 

```

### 注

确保无论何时创建要在 Spring 容器中配置的类，都应该遵循 Bean 命名约定。

可以使用 getter 方法获得对象的状态。因此，开发人员通常会同时添加 getter 和 setter。添加 getter 始终取决于应用程序的业务逻辑：

1.  现在我们需要在类路径中的 beans.xml 中配置 bean 定义，该类路径表示 bean 定义，这样 bean 将由 Spring 容器管理。配置如下所示：

```
      <bean id=""car_obj"" class=""com.ch02.beans.Car"" /> 

```

2.  在上一步中，只创建了一个实例，我们现在还想设置它的属性，即使用 setter 注入依赖项。代码如下：

```
      <bean id=""car_obj"" class=""com.ch02.beans.Car""> 
        <property name=""chesis_number"" value=""eng2012"" /> 
        <property name=""color"" value=""baker''s chocolate"" /> 
        <property name=""fule_type"" value=""petrol"" /> 
        <property name=""average"" value=""12.50"" /> 
        <property name=""price"" value=""643800"" /> 
      </bean> 

```

如果我们不想设置任何依赖项的值，那么简单的方法是不将其添加到配置中。

3.  现在我们可以使用这个 bean 了。我们必须要求容器提供 bean 的对象。在带有 main 函数的默认包中创建类 TestCar。我们不必更改主代码中的任何内容，因为依赖项的外部化，我们已经在 Ch02_ 实例 _ 创建的 TestCar 中进行了更改。代码保持不变。代码如下所示：

```
      public class TestCar { 
        public static void main(String[] args) { 
          // TODO Auto-generated method stub 
          ApplicationContext context=new   
            ClassPathXmlApplicationContext("beans.xml"); 
          Car car=(Car)context.getBean("car_obj"); 
          car.show(); 
        } 
      } 

```

4.  在执行代码时，我们将获得以下输出：

![](https://www.packtpub.com/graphics/9781787120341/graphics/image_02_006.png)

图中显示的值与我们在配置中设置的值相同。

### 构造函数注入

在构造函数注入中，依赖项将由构造函数的参数或简单参数化的参数来实现。让我们开发一个应用程序来使用基于构造函数的依赖项注入。

方式 1：没有歧义

在以下步骤的帮助下，我们将使用相同的项目 Ch02_Dependency_Injection：

1.  向具有以下代码的 Car 添加参数化构造函数：

```
      public Car(String chesis_number,String color, double average,
        long price, String fuel_type) { 
        // TODO Auto-generated constructor stub 
        this.chesis_number = chesis_number; 
        this.average = average; 
        this.price = price; 
        this.color=color; 
        this.fuel_type=fuel_type; 
      } 

```

### 注

如果要添加参数化构造函数，并且希望同时使用 setter 和构造函数注入，则必须添加默认构造函数

2.  在 beans.xml 文件中再添加一个 bean，但这次我们将使用<constructor-arg>来使用构造函数 DI，而不是使用<property>标记。代码如下所示：</property></constructor-arg>

```
      <bean id="car_const" class="com.ch02.beans.Car"> 
        <constructor-arg value=""eng023""></constructor-arg> 
        <constructor-arg value=""green""></constructor-arg> 
        <constructor-arg value=""12""></constructor-arg> 
        <constructor-arg value=""678900""></constructor-arg> 
        <constructor-arg value=""petrol""></constructor-arg> 
      </bean> 

```

3.  在默认包中创建一个类 TestCarConstructorDI，它将从容器中获取 Car 对象。代码如下：

```
      public static void main(String[] args) { 
        // TODO Auto-generated method stub 
        ApplicationContext context=new    
          ClassPathXmlApplicationContext(""instance.xml""); 
        Car car=(Car)context.getBean(""car_const""); 
        car.show(); 
      } 

```

在这里，容器很高兴拥有具有不同数据类型的构造函数的每个参数。但并非每次都是如此。我们可能会遇到一些代码，其中构造函数将有多个参数，这些参数的数据类型不明确。有时我们在类中确实有多个构造函数，由于自动向上转换，意外的构造函数可能会被容器调用。也可能是开发人员错过了争论的顺序。

#### 方式二：模棱两可

1.  让我们在 beans.xml 中再添加一个 bean 定义，如下所示：

```
      <bean id=""car_const1"" class=""com.ch02.beans.Car""> 
        <constructor-arg value=""eng023""></constructor-arg> 
        <constructor-arg value=""green"" ></constructor-arg> 
        <constructor-arg value=""petrol""></constructor-arg> 
        <constructor-arg value=""12"" ></constructor-arg> 
        <constructor-arg value=""678900""></constructor-arg> 
      </bean> 

```

参数的数量与构造函数定义匹配，但第三个参数不是传递平均值，而是传递 fuel_ 类型值。别担心，继续你的旅程，要有信心！

2.  创建 TestConstructor\u Dumblicity 以查找不匹配参数上发生的情况。代码如下所示：

```
      public static void main(String[] args) { 
        // TODO Auto-generated method stub 
        ApplicationContext context=new    
          ClassPathXmlApplicationContext(""beans.xml""); 
        Car car=(Car)context.getBean(""car_const1""); 
        car.show(); 
      } 

```

3.  主功能执行时出现异常，如下快照所示：

![](https://www.packtpub.com/graphics/9781787120341/graphics/image_02_007.png)

下划线表示参数值的模糊性。我们可以有两种解决方案：

*您可以更改配置顺序，以便与构造函数参数匹配。

*Spring 通过提供“index”属性来解析构造函数参数的顺序，提供了一种简便的方法。

Spring 提供了另一种配置“类型”属性的方法。

4.  让我们通过从步骤 1 更新 bean 定义来尝试配置“索引”，如下所示：

```
      <bean id=""car_const1"" class=""com.ch02.beans.Car""> 
        <constructor-arg value=""eng024"" index=""0"">
          </constructor-arg> 
        <constructor-arg value=""yellow"" index=""1"">
          </constructor-arg> 
        <constructor-arg value=""petrol"" index=""4"">
          </constructor-arg> 
        <constructor-arg value=""15"" index=""2"">
          </constructor-arg> 
        <constructor-arg value=""688900"" index=""3"">
          </constructor-arg> 
      </bean> 

```

您可以找到另外一个我们这次配置为“index”的属性，它将告诉容器哪个值是哪个参数的值。“索引”始终以“0”开头。我们尚未更改配置中属性的顺序。

5.  运行相同的 TestConstructor。您将毫无问题地获得您的实例。

### 注

指定索引是克服歧义的最安全方法，但即使我们可以指定“类型”而不是索引来克服这种情况。但是，如果构造函数具有多个具有相同数据类型的参数，“类型”将无法帮助我们解决问题。要在前面的代码中使用 type，我们需要将 XML 文件中的 bean 定义更改为，

这里我们探讨了设置 bean 属性的方法。但是，如果您敏锐地观察到我们在这里设置的所有属性都是基本的，但即使我们可以将辅助数据作为数据成员。让我们通过下面的演示了解如何设置辅助数据类型的属性。

让我们开发一个客户示例，该客户的地址是数据成员之一。为了更好地理解，请遵循以下步骤：

1.  创建 Java 应用程序“Ch02\u Reference\u DI”，并向其添加 JAR，就像我们在前面的示例中所做的那样。
2.  在 com.ch02.beans 包中创建 Address 类，将 city_ 名称、build_ 编号、pin_ 代码作为数据成员。还要添加 setter 方法。代码如下：

```
      public class Address { 
        private String city_name; 
        private int build_no; 
        private long pin_code; 

        public void setCity_name(String city_name) { 
          this.city_name = city_name; 
        } 
        public void setBuild_no(int build_no) { 
          this.build_no = build_no; 
        } 
        public void setPin_code(long pin_code) { 
          this.pin_code = pin_code; 
        } 
        @Override 
        public String toString() { 
          // TODO Auto-generated method stub 
          return this.city_name+""\t""+this.pin_code; 
        } 
      } 

```

3.  在 com.ch02.beans 包中创建具有客户名称、客户 id 和客户地址的客户。添加 getter 和 setter 方法。守则内容如下：

```
      public class Customer { 
        private String cust_name; 
        private int cust_id; 
        private Address cust_address; 
        //getter and setter methods 
      } 

```

您很容易发现客户地址是辅助数据。

4.  对于配置，请在类路径中创建 customer.xml。
5.  我们有两个 bean 要在 XML 中配置。第一个 bean 表示地址，第二个 bean 表示客户。让我们首先为地址配置 bean，如下所示：

```
      <bean id=""cust_address "" class=""com.ch02.beans.Address""> 
        <property name=""build_no"" value=""2"" /> 
        <property name=""city_name"" value=""Pune"" /> 
        <property name=""pin_code"" value=""123"" /> 
      </bean> 

```

注意，我们在这里使用的地址 id 是“客户地址”。但如果你愿意，你可以用你自己的。

6.  现在，为客户添加配置，如下代码所示：

```
      <bean id=""customer"" class=""com.ch02.beans.Customer""> 
        <property name=""cust_id"" value=""20"" /> 
        <property name=""cust_name"" value=""bob"" /> 
        <property name=""cust_address"" ref=""cust_address"" /> 
      </bean> 

```

cust_id 和 cust_name 将直接具有 value 属性。但是，cust_ 地址不是原语，因此我们需要在这里使用“ref”而不是“value”作为属性。

***ref**：“ref”属性用于引用我们需要注入的对象。“ref”的值是容器中“id”的值。这里我们使用 ref 值作为“cust_address”，因为我们已经为地址数据类型声明了一个具有类似 id 的 bean。

7.  现在是测试代码如何工作的时候了。使用 main 方法在默认包中添加 TestCustomer，以借助以下代码从容器中获取 Customer 对象：

```
      public static void main(String[] args) { 
        // TODO Auto-generated method stub 
        ApplicationContext context=new  
          ClassPathXmlApplicationContext("customer.xml"); 
        Customer customer=(Customer)context.getBean("customer"); 
        System.out.println(customer.getCust_name()+"\t"+ 
          customer.getCust_id()); 
      } 

```

### 注

开发人员通常调用 bean 的业务逻辑方法，而不是直接使用数据成员。

8.  执行时，我们将在控制台上获得客户 id 和客户名称。

### 注

我们甚至可以通过添加参数化构造函数并使用<constructor-arg>而不是<property>标记来使用这里的构造函数注入。如上所示，“value”属性必须替换为“ref”。您可以从 Customer\u Constructor\u DI.java 中找到代码</property></constructor-arg>

### 属性的命名空间“p”

在前面的一个示例中，我们使用了<property>标记来注入实例中属性的值。该框架借助于“p”名称空间为<property>提供了更为复杂的方式和替代方案。要使用“p”命名空间，开发人员必须添加模式 URI[http://www.springframework.org/schema/p 配置文件中的](http://www.springframework.org/schema/p)如下所示：</property></property>

```
xmlns:p=""http://www.springframework.org/schma/p""  

```

使用“p”设置属性的基本值的语法为：

```
p: name_of_property =value_of_the_property_to_set. 

```

如果设置了多个属性，请使用空格分隔这些属性。

引用数据类型的语法更改如下：

```
p: name_of_property-ref =id_of_bean_which_to_inject 

```

让我们在 XML 中使用新的配置。我们将使用与 Ch02_Dependency_Injection 相同的项目结构，只需修改 beans.xml。让我们通过以下步骤创建一个新的应用程序：

1.  使用\u namespce 创建一个名为 Ch02\u DI\u 的新 Java 项目，并将 JAR 添加到其中。
2.  在 com.ch02.beans 包中创建或复制 Car 类。您可以参考 Ch02_Dependency_Injection 中的代码。
3.  创建 beans.xml 文件并将其更新为命名空间“p”的声明，如上所示。配置文件如下所示：

```
      <beans     
        xmlns:p="http://www.springframework.org/schema/p"  
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
        xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd"">  
      </beans> 

```

4.  使用命名空间“p”添加 bean 定义，如下所示：

```
      <bean id="car_obj" class="com.ch02.beans.Car"    
        p:chesis_number="eng2013" p:color="baker's chocolate"    
        p:fuel_type="petrol" p:average="12.50" p:price="750070"> 
      </bean> 

```

5.  创建 TestCar 类，从容器中获取 Car 实例并执行代码。您可以从 Ch02\u Dependency\u 注入项目中引用相同的 TestCar.Java。

一旦我们知道了如何设置原语，让我们也为参考配置进行编码。我们将使用相同的 DI_using-namespce 项目来开发进一步的代码：

1.  复制或创建类地址。（请参阅 com.Ch02.beans 包中 Ch02_Reference_DI 中的代码）。
2.  复制或创建类 Customer。（请参阅 com.Ch02.beans 包中 Ch02_Reference_DI 中的代码）。
3.  使用 bean.xml 中的 setter DI 为 Address 添加 bean。
4.  使用命名空间“p”为客户添加 bean，配置如下所示：

```
      <bean id=""customer"" class=""com.ch02.beans.Customer""  
         p:cust_id=""2013"" p:cust_name=""It''s Bob""  
         p:cust_address-ref=""cust_address""> 
      </bean> 

```

您可以在这里看到客户地址不是原语，因此我们使用引用 p:cust_address=“cust_address”，而不是使用值，其中“cust_address”是表示地址 bean 的 id。

5.  使用包含以下代码的主函数创建 TestCustomer：

```
      public static void main(String[] args) { 
        // TODO Auto-generated method stub 
        ApplicationContext context=new  
          ClassPathXmlApplicationContext(""beans.xml""); 
        Customer customer=(Customer)context.getBean(""customer""); 
        System.out.println(customer.getCust_name()+""\t""+ 
          customer.getCust_id()); 
      } 

```

6.  代码的执行将显示以下输出：

![](https://www.packtpub.com/graphics/9781787120341/graphics/image_02_008.png)

#### 配置内部 bean

bean 定义文件有多个由容器管理的 bean。正如我们所知，这些 bean 可以彼此重用。在某一点上，这种可重用性是惊人的，但随之而来的是一个问题。让我们以客户地址为例。可以针对地址和客户进行配置。我们可以为另一个客户使用地址 bean 吗？是的，我们可以。但是……如果客户不想分享他的地址，也不想将其保留为私人地址，该怎么办？在当前配置下，这是不可能的。但是，我们可以有一个替代配置，使设施保持个人地址。Ch02_Reference_DI 中客户 bean 的配置可以修改为使用 internal，如下所示：

```
<bean id=""customer_obj"" class=""com.ch02.beans.Customer""> 
  <property name=""cust_id"" value=""20"" /> 
  <property name=""cust_name"" value=""bob"" /> 
  <property name=""cust_address""> 
    <bean class=""com.ch02.beans.Address""> 
      <property name=""build_no"" value=""2"" /> 
      <property name=""city_name"" value=""Pune"" /> 
      <property name=""pin_code"" value=""123"" /> 
    </bean> 
  </property> 
</bean> 

```

地址 bean 是内部的，其实例将被创建，并与 Cutomer 实例的 address 属性连接。这类似于 Java 内部类。

由于 setter 注入支持内部 bean，因此构造函数注入也支持内部 bean。配置将是：

```
<bean id=""customer_obj_const"" class=""com.ch02.beans.Customer""> 
  <constructor-arg value=""20"" /> 
  <constructor-arg value=""bob"" /> 
  <constructor-arg> 
    <bean id=""cust_address"" class=""com.ch02.beans.Address""> 
      <property name=""build_no"" value=""2"" /> 
      <property name=""city_name"" value=""Pune"" /> 
      <property name=""pin_code"" value=""123"" /> 
    </bean> 
  </constructor-arg> 
</bean> 

```

您可以在 Ch02_InnerBeans 项目中找到完整的代码。

#### 遗传映射

继承是 Java 的主要支柱。Spring 支持在 XML 中配置 bean 定义。继承支持由“parent”属性提供，该属性表示可以从父 bean 使用缺少的属性。当我们开发 Java 代码时，使用“父类”可以在继承方面与父类相似。甚至可以从父 bean 重写属性。让我们通过以下步骤了解如何实际使用：

1.  创建 Ch02_ 继承作为 Java 项目。
2.  加上罐子。
3.  使用以下代码在 com.ch02.beans 包中创建班级学生：

```
      public class Student { 
        private int rollNo; 
        private String name; 
        // getters and setters 
      } 

```

4.  创建继承自学生的类`EnggStudent`为：

```
      public class EnggStudent extends Student { 
        private String branch_code; 
        private String college_code; 
        // getters and setters 
      } 

```

5.  在类路径中创建 student.xml，将学生的 bean 配置为：

```
      <bean id=""student"" class=""com.ch02.beans.Student""> 
        <property name=""rollNo"" value=""34"" /> 
        <property name=""name"" value=""Sasha"" /> 
      </bean> 

```

6.  现在是为 EnggStudent 配置 bean 的时候了。首先是我们不想使用的普通配置：

```
      <bean id=""engg_old"" class=""com.ch02.beans.EnggStudent""> 
        <property name=""rollNo"" value=""34"" /> 
        <property name=""name"" value=""Sasha"" /> 
        <property name=""branch_code"" value=""Comp230"" /> 
        <property name=""college_code"" value=""Clg_Eng_045"" /> 
      </bean> 

```

很明显，我们重复了 rollNo 和 name 的配置。我们不必通过如下所示配置“父”属性来重复配置：

```
<bean id="engg_new" class="com.ch02.beans.EnggStudent"  
  parent="student"> 
  <property name="branch_code" value="Comp230"/> 
  <property name=""college_code"" value=""Clg_Eng_045"" /> 
</bean> 

```

虽然在这里我们跳过了配置 name 和 rollNo 并从“student”bean 中重用它，但也可以覆盖其中任何一个，如下所示：

```
<bean id="engg_new1" class="com.ch02.beans.EnggStudent"   
  parent="student"> 
  <property name=""rollNo"" value=""40"" /> 
  <property name=""branch_code"" value=""Comp230"" /> 
  <property name=""college_code"" value=""Clg_Eng_045"" /> 
</bean> 

```

选择权在你，使用哪一个！！

1.  编写 TestStudent，其主要功能如下：

```
      public static void main(String[] args) { 
        // TODO Auto-generated method stub 
        ApplicationContext context=new  
          ClassPathXmlApplicationContext("student.xml"); 
        //old configuration 
        EnggStudent student_old= 
          (EnggStudent)context.getBean("engg_old"); 
        System.out.println(""with old configuration""); 
        System.out.println(student_old.getName()+ 
          "\t"+student_old.getRollNo()+"\t"+ 
          student_old.getCollege_code()); 
        //new configuration 
        EnggStudent student_new=
          (EnggStudent)context.getBean(""engg_new""); 
        System.out.println(""with new configuration""); 
        System.out.println(student_new.getName()+ 
          "\t"+student_new.getRollNo()+"\t"+ 
          student_new.getCollege_code()); 
        System.out.println(""with new configuration with       
          overridding roll number""); 
        //new configuration with overriding the roll number 
        EnggStudent student_new1=
          (EnggStudent)context.getBean(""engg_new1""); 
        System.out.println(student_new1.getName()+"\t"+ 
          student_new1.getRollNo()+"\t"+ 
          student_new1.getCollege_code()); 
      } 

```

2.  下面的快照显示控制台输出，如下所示：

![](https://www.packtpub.com/graphics/9781787120341/graphics/image_02_009.png)

3.  开发人员可以获得学生实例和英语学生实例。在某些情况下，我们不希望任何人使用学生实例，或者任何人都不能获得学生实例。在这种情况下，在实例开发人员不想公开的 bean 上配置属性“abstract”。默认情况下，abstract=false 的值表示任何人都可以获得 bean 的实例。我们将配置 abstract=”“true“”，使其不可用。学生的更新配置如下所示：

```
      <bean id=""student"" class=""com.ch02.beans.Student""    
        abstract=""true""> 
        <property name=""rollNo"" value=""34"" /> 
        <property name=""name"" value=""Sasha"" /> 
      </bean>
```

4.  现在，每当有人请求学生 bean 时，就会抛出异常。您可以通过在 TestStudent 中添加以下行来尝试代码：

```
      System.out.println(""obtaining Student instance""); 
      Student student=(Student)context.getBean(""student""); 

```

5.  执行时，我们将获得以下堆栈跟踪，该跟踪指定在获取学生 bean 时发生 bean 创建异常：

![](https://www.packtpub.com/graphics/9781787120341/graphics/image_02_010.png)

#### 配置空值

在 Java 中，除非数据成员的任何值未设置，否则每个值都将获得其默认值。引用属性将分别定义为“0”的 null 和基元整数。这些空值稍后将由构造函数注入或 setter 注入的集合值覆盖。开发人员也可能希望将其保持为空，直到某些业务逻辑不会给出计算值或从某些外部资源获取计算值。无论出于何种原因，我们希望将该值配置为 null，只需使用“<null>”。客户地址将设置为空，如下所示：</null>

```
<bean id=""customer_obj"" class=""com.ch02.beans.Customer""> 
  <property name=""cust_id"" value=""20"" /> 
  <property name=""cust_name"" value=""bob"" /> 
  <property name=""cust_address""><null/></property> 
</bean> 

```

您可以在 Ch02_InnerBeans 的 customer.xml 中找到配置。

到目前为止，我们已经看到了原语、引用、null 或内部 bean 的映射。我们非常高兴，但 Java 的一个非常重要的基本概念是集合框架。是的，我们还必须讨论集合的映射。

#### 配置采集

Java 中的集合框架便于处理对象，以简化的方式执行对象的添加、删除、搜索和排序等各种操作。接口集、列表、映射、队列是这些接口有许多实现，如 HashSet、ArrayList、TreeMap、PriorityQueue 等，它们提供了处理数据的方法。我们不会详细讨论为操作选择哪一个，但是，我们将在注入集合时讨论 Spring 支持的不同配置。

**映射列表**

列表是有序的集合，它提供按数据插入顺序处理数据的功能。它通过允许重复元素的索引来维护数据的插入、删除和获取。ArrayList、LinkedList 是它的一些实现。框架通过<list>标签支持列表配置。让我们通过以下步骤开发一个应用程序来配置列表：</list>

1.  创建 Ch02_DI_ 集合作为 Java 项目，并向其中添加 Spring JAR。
2.  在 com.ch02.beans 包中创建 POJO 类书。

*添加 isbn、书名、价格和出版物作为数据成员。

*添加默认构造函数和参数化构造函数。

*Write.getter 和 setter 方法。

*由于我们正在处理收款，因此添加`equals()`和`hashCode()`

*要显示对象，请添加`toString()`

这本书将如下面的代码所示，

```
      public class Book { 
        private String isbn; 
        private String book_name; 
        private int price; 
        private String publication; 

        public Book() 
        { 
          isbn=""310IND""; 
          book_name=""unknown""; 
          price=300; 
          publication=""publication1""; 
        }       

        public Book(String isbn,String book_name,int price, String  
          publication) 
        { 
          this.isbn=isbn; 
          this.book_name=book_name; 
          this.price=price; 
          this.publication=publication; 
        } 

        @Override 
        public String toString() { 
          // TODO Auto-generated method stub 
          return book_name+""\t""+isbn+""\t""+price+""\t""+publication; 
        } 

        @Override 
        public boolean equals(Object object) { 
          // TODO Auto-generated method stub 
          Book book=(Book)object; 
          return this.isbn.equals(book.getIsbn()); 
        } 

        public int hashCode() { 
          return book_name.length()/2; 
        } 

        // getters and setters 
      } 

```

3.  在 com.ch02.beans 中创建具有图书列表的库列表。Write displayBooks（）以显示书籍列表。守则如下：

```
      public class Library_List { 
        private List<Book> books; 
        public void displayBooks() 
        { 
          for(Book b:books) 
          { 
            System.out.println(b); 
          } 
        } 
        // getter and setter for books 
      } 

```

4.  在类路径中创建 books.xml。再加上四个书豆。我正在尝试以下三种配置：

*使用 setter DI 预订 bean。

*使用构造函数 DI 预订 bean。

*使用“p”命名空间的 Bookbean。

无需尝试所有组合，您可以按照其中任何一种进行操作。我们已经在以前的演示中使用了所有这些功能。配置如下所示：

```
     <bean id=""book1"" class=""com.ch02.beans.Book""> 
       <property name=""isbn"" value=""20Novel"" /> 
       <property name=""book_name"" value=""princess Sindrella"" /> 
       <property name=""price"" value=""300"" /> 
       <property name=""publication"" value=""Packt-Pub""></property> 
     </bean> 

     <bean id="book2" class="com.ch02.beans.Book"> 
       <constructor-arg value="Java490" /> 
       <constructor-arg value="Core Java" /> 
       <constructor-arg value="300" /> 
       <constructor-arg value="Packt-Pub" /> 
     </bean> 

     <bean id="book3" class="com.ch02.beans.Book"   
       p:isbn="200Autobiography"
       p:book_name="Playing it in my way" p:price="300"  
       p:publication="Packt-Pub"> 
     </bean> 

```

有意地，第四本书是前三本书之一的第二本，我们通过两个步骤来发现原因。等着瞧！！

5.  添加一个具有<list>配置的库 bean，如下所示：</list>

```
      <bean id=""library_list"" class=""com.ch02.beans.Library_List""> 
        <property name=""books""> 
          <list> 
            <ref bean=""book1""></ref> 
            <ref bean=""book2""></ref> 
            <ref bean=""book3""></ref> 
            <ref bean=""book3""></ref> 
          </list> 
        </property> 
      </bean> 

```

<list>包含要为图书列表注入的 bean 的<ref>列表，其中‘book1’、‘book2’、‘book3’、‘book4’是我们在步骤 4 中创建的 bean 的 id。</ref></list>

6.  使用 main 函数创建 TestLibrary_List，以获取库实例及其拥有的图书列表。代码如下：

```
      public static void main(String[] args) { 
        // TODO Auto-generated method stub 
        ApplicationContext context=new   
          ClassPathXmlApplicationContext(""books.xml""); 
        Library_List  list=       
          (Library_List)context.getBean(""library_list""); 
        list.displayBooks(); 
      } 

```

7.  执行它以获得书籍的输出显示列表。查找表示列表允许重复元素的最后两个条目：

![](https://www.packtpub.com/graphics/9781787120341/graphics/image_02_011.png)

**映射集**

Set 接口是无序集合，不允许集合中存在重复项。HashSet、TreeSet 是 Set 的实现。Spring 提供<set>标签来配置 Set。让我们使用 Ch02_DI_Collection 项目通过以下步骤添加一组书籍：</set>

1.  在 com.ch02.beans 包中添加 Library_Set 类，并将书籍集声明为数据成员。为它添加 getter 和 setter。代码如下所示：

```
      public class Library_Set { 
        HashSet<Book> books; 

        public void displayBooks() 
        { 
          for(Book b:books) 
          { 
            System.out.println(b); 
          } 
        } 
        //getter and setter for books 
      } 

```

2.  在 beans.xml 中为库 _ 集合添加一个 bean，配置为<set>，如下所示：</set>

```
      <bean id=""library_set"" class=""com.ch02.beans.Library_Set""> 
        <property name=""books""> 
          <set> 
            <ref bean=""book1""></ref> 
            <ref bean=""book2""></ref> 
            <ref bean=""book3""></ref> 
            <ref bean=""book3""></ref> 
          </set> 
        </property> 
      </bean> 

```

3.  创建 TestLibrary_ 集合，其主要功能如下所示：

```
      public static void main(String[] args) { 
        // TODO Auto-generated method stub 
        ApplicationContext context=new  
          ClassPathXmlApplicationContext(""books.xml""); 
        Library_Set set=     
          (Library_Set)context.getBean(""library_set""); 
        set.displayBooks();      
      } 

```

4.  执行的输出如下图所示：

![](https://www.packtpub.com/graphics/9781787120341/graphics/image_02_012.png)

我们注入了四本书，但只输出了三本，所以很明显，这套书不允许复制。

**测绘图**

映射处理具有键和值对的对象集合。映射可以有重复的值，但不允许有重复的键。其实现方式为`TreeMap`、`HashMap`和`LinkedHashMap`。

让我们通过以下步骤来探索配置映射：

1.  我们将使用相同的 Ch02_DI_ 收集项目。在 com.ch02.beans 包中创建类库映射。
2.  添加| Map<string>book 作为数据成员，以及 getter 和 setter。别忘了在里面加上`displayBooks()`。代码如下所示：</string>

```
      public class Library_Map { 
        private Map<String,Book> books; 
        //getters and setters 

        public void displayBooks() 
        { 
          Set<Entry<String, Book>> entries=books.entrySet(); 
          for(Entry<String, Book> entry:entries) 
          { 
            System.out.println(entry.getValue()); 
          }    
        }   
      } 

```

3.  在 beans.xml 中配置映射，如下所示：

```
<bean id=""library_map"" class=""com.ch02.beans.Library_Map""> 
    <property name=""books""> 
      <map> 
        <entry key=""20Novel"" value-ref=""book1"" /> 
        <entry key=""200Autobiography"" value-ref=""book3"" /> 
        <entry key=""Java490"" value-ref=""book2"" /> 
      </map> 
    </property> 
  </bean> 

```

与列表和设置不同，映射将采用额外的“键”属性来指定键。我们在这里使用了书的名称作为键，但若你们想要，你们也可以声明其他东西。请不要忘记，在地图中，钥匙始终是唯一的：

1.  编写 TestLibrary_Map，其主要功能如下：

```
      public static void main(String[] args) { 
        // TODO Auto-generated method stub 
        ApplicationContext context=new     
          ClassPathXmlApplicationContext("books.xml"); 
        Library_Map map=  
          (Library_Map)context.getBean("library_map"); 
        map.displayBooks(); 
      } 

```

2.  执行代码以在控制台上显示书籍详细信息。

这里我们根据条目配置单个对象。但实际上，一个条目可能包含一个列表或一套书籍。在这种情况下，配置将包含带<list>的<entry>，而不是带【value-ref】的<entry>，如下所示：</entry></entry></list>

```
<bean id=""library_map1"" class=""com.ch02.beans.Library_Map1""> 
    <property name=""books""> 
      <map> 
        <entry key=""20Novel""> 
          <list> 
            <ref bean=""book1""></ref> 
            <ref bean=""book1""></ref> 
          </list> 
        </entry> 
        <entry key=""200Autobiography""> 
          <list> 
            <ref bean=""book3""></ref> 
            <ref bean=""book3""></ref> 
          </list> 
        </entry> 
      </map> 
    </property> 
  </bean> 

```

在上面的配置中，每个“条目”都有包含图书“<list>”的图书名称，但如果我们谈论图书库，这是显而易见的。库 _Map1.java 和 TestLibrary_Map1.java 的完整代码可参考 Ch02_DI_ 集合。</list>

**映射属性**

属性还保存键值对中的元素集合，但与此处的映射不同，键值都是字符串类型。属性可以保存或从流中读取。

让我们考虑一个拥有多个州作为财产的国家。按照以下步骤了解如何在`beans.xml`中配置属性：

1.  在 com.ch02.beans 包中创建一个类 Country。
2.  将名称、洲和州首府声明为数据成员。同时添加 getter 和 setter。要显示州首府，请添加 printCapital（）。代码如下所示：

```
      public class Country { 
        private String name; 
        private String continent; 
        private Properties state_capitals; 

        // getters and setter  

        public void printCapitals() 
        { 
          for(String state:state_capitals.stringPropertyNames()) 
          {   
            System.out.println(state+"":\t""+ 
              state_capitals.getProperty(state)); 
          } 
        } 
      } 

```

3.  在 beans.xml 中，配置国家/地区的定义，如下所示：

```
      <bean id=""country"" class=""com.ch02.beans.Country""> 
        <property name=""name"" value=""India""></property> 
        <property name=""continent"" value=""Asia""></property> 
        <property name=""state_capitals""> 
          <props> 
            <prop key=""Maharashtra"">Mumbai</prop> 
            <prop key=""Goa"">Panji</prop> 
            <prop key=""Punjab"">Chandigad</prop> 
          </props> 
        </property> 
      </bean> 

```

“state_capitals”包含“<props>”配置，将 state 名称保存为“key”，其大写为“value”。</props>

1.  使用具有以下代码的主函数编写 TestProperties，

```
public static void main(String[] args) { 
    // TODO Auto-generated method stub 
    ApplicationContext context=new   
                   ClassPathXmlApplicationContext(""books.xml""); 
    Country country=(Country)context.getBean(""country""); 
    country.printCapitals();; 
   } 

```

2.  输出将如快照中所示：

![](https://www.packtpub.com/graphics/9781787120341/graphics/image_02_013.png)

“util”命名空间为开发人员提供了一种在 XML 文件中优雅地配置集合的方法。使用“util”命名空间可以配置列表、映射、集合和属性。要使用“util”命名空间，必须更新[www.springframework.org/schma/util](http://www.springframework.org/schma/util)URI 的模式，如下面的快照所示：

![](https://www.packtpub.com/graphics/9781787120341/graphics/image_02_014.png)

为了在配置中使用“util”命名空间，必须添加带下划线的行。

使用“util”命名空间的列表配置如下所示：

```
      <bean id=""library_list1"" class=""com.ch02.beans.Library_List""> 
        <property name=""books""> 
          <util:list> 
            <ref bean=""book1""></ref> 
            <ref bean=""book2""></ref> 
            <ref bean=""book3""></ref> 
          </util:list> 
        </property> 
      </bean> 

```

您可以在 books.xml 中找到更新的配置。

我们知道如何获取 bean 以及如何实现它所具有的不同类型的依赖关系。bean 配置通过注入依赖项定义创建实例的方式及其状态。在业务逻辑需求的任何时候，bean 的状态都可以更改。但我们还不知道 SpringContainer 创建了多少个实例，或者如果开发人员希望单个实例为每个请求提供服务该怎么办？或者每个操作都需要不同的实例。实际上我们在谈论“范围”

#### 豆镜

bean 的作用域定义了 Spring 容器将创建多少实例，并使其可供应用程序使用。使用<bean>的“范围”属性提供有关实例数的信息。在发现创建和提供实例的默认过程之前，我们无法移动。它将使术语“范围”变得清晰，也将定义为什么理解“范围”如此重要。</bean>

让我们使用 Ch02_Dependency_Injection 项目来查找容器默认创建的实例数。您可以使用同一个项目，也可以像我们在以下步骤中所做的那样创建它的新副本。

1.  将 Ch02\u Bean\u 范围创建为 Java 项目。
2.  加上弹簧罐。
3.  在 com.ch02.beans 包中创建或复制 Car。
4.  在类路径中创建 beans.xml 并配置“car”bean，如下所示，

```
      <bean id=""car"" class=""com.ch02.beans.Car""> 
        <property name=""chesis_number"" value=""eng2012"" /> 
        <property name=""color"" value=""baker''s chocolate"" /> 
        <property name=""fuel_type"" value=""petrol"" /> 
        <property name=""average"" value=""12.50"" /> 
        <property name=""price"" value=""643800"" /> 
      </bean> 

```

范围与 bean 的配置方式无关。

5.  创建 TestCar 以请求“car”bean 两次，如下所示。别惊讶。我们想知道创建了多少实例。让我们开始：

```
      public static void main(String[] args) { 
        // TODO Auto-generated method stub 
        ApplicationContext context=new  
          ClassPathXmlApplicationContext(""beans.xml""); 
        // first request to get the car instance 
        Car car_one=(Car)context.getBean(""car""); 
        car_one.show(); 

        //second request to get the car instance 
        Car car_two=(Car)context.getBean(""car""); 
        car_two.show(); 
      } 

```

代码的执行将给出以下输出：，

![](https://www.packtpub.com/graphics/9781787120341/graphics/image_02_015.png)

是，两个对象具有相同的值。为什么不呢？我们用 XML 配置它们。这不会使我们得出任何结论。让我们继续进行第二步。

*使用相同的 TestCar 代码，但这次更改任何一个 car 对象的状态。我们将换成“一号车”，观察二号车发生了什么？car_2 是否包含更改的值或配置的值？更改后的代码如下所示：

```
      public class TestCarNew { 
        public static void main(String[] args) { 
          // TODO Auto-generated method stub 
          ApplicationContext context=new  
            ClassPathXmlApplicationContext(""beans.xml""); 
          // first request to get the car instance 
            Car car_one=(Car)context.getBean(""car""); 
            car_one.show(); 

          //second request to get the car instance 
            Car car_two=(Car)context.getBean(""car""); 
            car_two.show(); 

          System.out.println(""after changing car-one is""); 
          // change average and color of car_one 
          car_one.setAverage(20.20d); 
          car_one.setColor(""white""); 
          car_one.show(); 
          System.out.println(""after changing car-two is""); 
          car_two.show(); 
        } 
      } 

```

在执行时，您将得到以下输出。

![](https://www.packtpub.com/graphics/9781787120341/graphics/image_02_016.png)

我们刚刚更改了 car_one 的状态，但输出显示 car_two 的状态发生了更改，这证明了无论您向容器请求实例多少次，每次都会将相同的实例返回给我们。

### 注

“singleton”是 bean 的默认范围，表示每个 Spring 容器有一个实例。

*保持 TestCarNew 不变，并在 carbean 中配置“scope”属性，如下所示，

```
<bean id=""car"" class=""com.ch02.beans.Car"" scope=""prototype""> 

```

执行 TestCarNew，您将获得以下输出：

![](https://www.packtpub.com/graphics/9781787120341/graphics/image_02_017.png)

输出显示 car_1 的变化状态不改变 car_2 的状态。这意味着，对于来自容器的每个 car 实例请求，容器都会创建并提供一个新实例。

### 注

“prototype”为来自容器的实例的每个请求指定一个新实例。

下面是 Spring 框架给出的几个范围，

*   **请求**：默认情况下，在 web 应用程序中，所有 HTTP 请求都由同一实例提供服务，这可能导致数据处理或数据一致性问题。要确保每个请求都有自己的新实例，“请求”作用域将非常有用。
*   **会话**：我们非常了解如何在 web 应用程序中处理会话请求“”为每个请求创建实例，但当多个请求绑定到同一会话时，每个请求的实例会变得笨拙，管理数据也会变得笨拙。“会话”范围是在开发人员需要每个会话的实例的情况下的救援。
*   **应用程序**：每个 web 应用程序都有自己的 ServletContext。“应用程序”作用域为每个 ServletContext 创建实例。
*   **全局会话**：在 ProtleContext 中，Spring 配置为每个全局 HTTPSession 提供实例。
*   **websocket**：“websocket”范围指定每个 websocket 创建实例。

### 基于注释的配置

从 Spring2.5 开始，Spring 开始支持基于注释的配置。我们已经讨论了 Java 中的概念以及如何在 XML 中配置它们？在进行基于注释的配置时，我们会遇到两种类型的配置

*   基于 Spring 的注释
*   基于 JSR 的注释。

#### 基于 Spring 的注释

Spring 提供了大量注释，这些注释可能包括管理生命周期、创建 bean 实例、连接注释等等。让我们一个接一个地找到他们。但在此之前，我们需要知道一件非常重要的事情。必须通过在 XML 中配置 bean 定义来注册它。现在，要进行基于注释的配置，必须使用上下文名称空间进行 bean 注册，如下所示：

```
<beans " 
  xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""  
  xmlns:context=""http://www.springframework.org/schema/context"" 
  xsi:schemaLocation= 
    "http://www.springframework.org/schema/beans 
     http://www.springframework.org/schema/beans/spring-beans.xsd  
     http://www.springframework.org/schema/context  
     http://www.springframework.org/schema/context/spring-context.xsd"> 
<context:annotation-config/> 

```

AUT0T0 要求容器考虑 bean 上的注释。

您甚至可以使用以下配置来代替上述配置，

```
<bean calss=""or.springframework.bean.factory.annotation.
  AutowiredAnnotationBeanPostProcessor""/> 

```

让我们从为不同场景逐个使用注释开始，如下所示：，

##### 刻板印象注释

这些注释是类级别的注释，可以在 Spring 容器中注册。下图显示了原型注释：

![](https://www.packtpub.com/graphics/9781787120341/graphics/image_02_018.png)

让我们在应用程序中使用@Component。我们将使用 Ch02_Reference_DI 作为基础项目，并使用以下步骤：

1.  创建 Ch02_Demo_ 注释和我们前面添加的所有 jar，并将 spring-aop.jar 添加到其中。
2.  在 com.ch02.beans 包中创建或复制 Address.java。
3.  在 com.ch02.stereotype.annotation 包中创建或复制 Customer.java。将其重命名为 Customer_Component.java
4.  添加默认构造函数，因为我们所引用的代码没有任何默认构造函数。代码可以如下所示：

```
      public Customer_Component() { 
        // TODO Auto-generated constructor stub 
        cust_id=100; 
        cust_name=""cust_name""; 
        cust_address=new Address(); 
        cust_address.setBuild_no(2); 
        cust_address.setCity_name(""Delhi""); 
      } 

```

5.  用@Component 注释该类，如下所示：

```
      @Component 
      public class Customer_Component {   } 

```

在这里，我们配置了一个可自动扫描的组件。默认情况下，此组件的 id 将是非优化的类名。在我们的案例中，它是“客户组件”。如果我们想使用自定义 id，我们可以修改配置，将“myObject”用作 bean id，

```
      @Component(value=""myObject"")  

```

而且不需要像我们前面所做的那样在 XML 中配置它。但是，对于其他一些配置，我们仍然需要 XML。

6.  在类路径中创建或复制 customer.xml。
7.  添加以下代码来考虑注释：

```
      <context:annotation-config/> 

```

我们已经了解了如何配置“上下文”命名空间。

8.  创建 TestCustomer\u 组件以获取 Customer\u 组件的 bean，如下所示，以了解我们的配置的输出：

```
      public class TestCustomer_component { 
        public static void main(String[] args) { 
          // TODO Auto-generated method stub 
          ApplicationContext context = new  
            ClassPathXmlApplicationContext(""customer.xml""); 
          Customer_Component customer = (Customer_Component)  
            context.getBean(""customer_Component""); 
          System.out.println(customer.getCust_name() + ""\t"" +  
          customer.getCust_id() +  
          customer.getCust_address()); 
        } 
      } 

```

执行时，我们将获得以下异常堆栈跟踪，

```
      Exception in thread "main"  
      org.springframework.beans.factory.NoSuchBeanDefinitionException:
      No bean named ''customer_component'' is defined 

```

9.  如果我们什么都做了，那为什么我们仍然会例外呢。原因是组件可以自动扫描，但忘记告诉容器在哪里扫描注释？让我们将扫描组件的位置配置为：

```
      <context:component-scan  
        base-package=""com.ch02.stereotype.*""> 
      </context:component-scan> 

```

这里将扫描 com.ch02.streotype 的所有子包，以找出 id 为“customer\u Component”的 bean。

10.  添加配置后，我们将获得以下输出，显示数据成员值：

```
      INFO: Loading XML bean definitions from class path resource 
      [customer.xml] 
      cust_name 100 Delhi 2
```

同样，我们也可以使用其他注释，但我们将在接下来的章节中逐一讨论它们。

##### 接线说明

我们已经深入讨论了“自动连接”，它为我们提供了减少配置并自动发现作为 bean 中的依赖项注入哪个对象的工具。以下是有助于自动布线和整理自动布线中出现的问题的注释。

![](https://www.packtpub.com/graphics/9781787120341/graphics/image_02_019.png)

让我们使用 Cho2_Demo_ 注释项目来演示上述注释。

##### 案例 1。使用@Autowired

1.  在 com.ch02.autowiring.annotation 中创建类 Customer_Autowired。这类似于我们在原型注释中创建的 Customer_ 组件。如果没有默认客户，请不要忘记添加默认客户。
2.  在字段 cust_address 上添加@Autowired 注释，如下所示：

```
      @Autowired 
      private Address cust_address; 

```

3.  在 customer_new.xml 中，为地址配置一个 bean，如下所示，

```
      <bean id=""cust_address"" class=""com.ch02.beans.Address""> 
        <property name=""build_no"" value=""2"" /> 
        <property name=""city_name"" value=""Pune"" /> 
        <property name=""pin_code"" value=""123"" /> 
      </bean> 

```

4.  创建 TestCustomer_Autowired 以获取 id 为“customer_Autowired”的 bean：

```
      public static void main(String[] args) { 
        // TODO Auto-generated method stub 
        ApplicationContext context = new  
          ClassPathXmlApplicationContext(""customer_new.xml""); 
        Customer_Autowired customer = (Customer_Autowired)  
          context.getBean(""customer_Autowired""); 
        System.out.println(customer.getCust_name() + ""\t"" +  
          customer.getCust_id() +  
          customer.getCust_address()); 
      } 

```

5.  我们将在执行时获得以下控制台输出：

```
      INFO: Loading XML bean definitions from class path resource
      [customer_new.xml] 
      my name  10  Mumbai  12 

```

##### 案例 2。使用自动连线=错误

无论开发人员采取何种措施，我们总是会遇到依赖项不可用或由于某种原因无法注入的情况。很明显这里有例外。为了避免这种强制注射，在`@Autowired`中添加`'autowired=false`。

1.  您可以通过在上一个项目中从 customer.xml 中删除 cust_ 地址来尝试这一点。在执行 main 时，我们将得到以下异常：

```
      Caused by:
      org.springframework.beans.factory.NoSuchBeanDefinitionException:
      No qualifying bean of type [com.ch02.beans.Address] found for
      dependency [com.ch02.beans.Address]: expected at least 1 bean
      which qualifies as autowire candidate for this dependency.
      Dependency annotations:
        {@org.springframework.beans.factory.annotation.Autowired 
      (required=true)} 

```

2.  将@Autowired 注释更改为：

```
      @Autowired(required=false) 
      private Address cust_address; 

```

1.  再次运行 main，我们将获得以下输出：

```
my name 10null
```

值 null 表示没有注入地址，但我们这里没有任何 bean 创建异常。

### 注

完成 required=false 的演示后，撤消我们在本演示中所做的所有更改。

##### 案例三。使用@Qualifier

在某些情况下，我们可能会在容器中配置多个相同类型的 bean。除非开发人员控制依赖项注入，否则拥有多个 bean 不是问题。也可能具有不同的依赖项 id，并且具有多个相同类型的 bean，但没有一个 id 是匹配的。让我们用`@Qualifier`来克服这些问题。我们将使用与上一步相同的类`Customer_Autowired`：

1.  将 bean cust_address 的 id 重命名为我们前面创建的 cust_address1。
2.  在其中再添加一个 Address 类型的 bean，如下所示：

```
      <bean id=""address"" class=""com.ch02.beans.Address""> 
        <property name=""build_no"" value=""2"" /> 
        <property name=""city_name"" value=""Pune"" /> 
        <property name=""pin_code"" value=""123"" /> 
      </bean> 

```

3.  创建 TestCustomer_Autowiring1 以获取客户实例，如下所示：

```
      public static void main(String[] args) { 
        // TODO Auto-generated method stub 
        ApplicationContext context = new  
          ClassPathXmlApplicationContext(""customer_new.xml""); 
        Customer_Autowired customer = (Customer_Autowired)  
          context.getBean(""customer_Autowired""); 
        System.out.println(customer.getCust_name() + ""\t"" +  
          customer.getCust_id() +  
          customer.getCust_address()); 
      }   

```

4.  执行时，我们将得到以下异常，指定有多个类型 Address 的实例可供注入，从而导致歧义：

```
      Caused by: 
      org.springframework.beans.factory.NoUniqueBeanDefinitionException
      :No qualifying bean of type [com.ch02.beans.Address] is defined:
      expected single matching bean but found 2: cust_address1,address 

```

5.  使用@Qualifier 更新数据成员 cust_address 的注释，如下所示：

```
       @Qualifier(value=""address"") 
       private Address cust_address; 

```

我们正在指定要注入以实现依赖关系的 bean 的 id。在本例中，将注入 id 为“地址”的 bean。

6.  执行我们在步骤 2 中创建的主函数，以获得以下输出，该输出显示 id 为“address”的 bean 在`Customer_Autowried`中被注入：

```
      INFO: Loading XML bean definitions from class path resource
        [customer_new.xml] 
      my name  10  Pune  2 

```

##### 案例三。使用@Required

在开发代码时，如果没有提供正确的值或者没有这些值，业务逻辑将失败。所以必须注入依赖项，无论发生什么，都不应该失败。为确保已注入依赖项并准备好使用，请在`@Autowired`注释之后应用`@Required`。它的工作方式与“`autowired=true`”相同。但与之相反，注释只能应用于 setter 方法。如果依赖项不可用，将抛出`BeanInitializationException`。

以下是清晰理解`@Required`用法的代码：

```
@Component(value=""cust_required"") 
public class Customer_Annot_Required { 

  private String cust_name; 
  private int cust_id; 

  private Address cust_address; 

  public void setCust_name(String cust_name) { 
    this.cust_name = cust_name; 
  } 

  public void setCust_id(int cust_id) { 
    this.cust_id = cust_id; 
  } 

  @Autowired 
  @Required 
  public void setCust_address(Address cust_address) { 
    this.cust_address = cust_address; 
  } 

  public Customer_Annot_Required() { 
    // TODO Auto-generated constructor stub 
    cust_id=10; 
    cust_name=""my name""; 
  } 
// getter methods 
} 

```

##### 案例 4 范围管理说明

几页以前，我们已经深入讨论了作用域及其使用。我们还了解了如何根据 XML 中的需求管理范围。通常，`@Scope`是类级注释。但是，它也可以与 Bean 注释一起使用，该方法指示从它返回的实例的范围。

以下代码表示@Scope 的使用：

```
package com.ch02.scope.annotation; 

@Component 
@Scope(scopeName=""prototype"") 
public class Customer_Scope { 

  private String cust_name; 
  private int cust_id; 

  @Autowired   
  @Qualifier(value=""address"") 
  private Address cust_address; 

  public Customer_Scope() { 
    // TODO Auto-generated constructor stub 
    cust_id=10; 
    cust_name=""my name""; 
  } 
//getters and setters 
} 

```

您可以使用以下代码检查是否每次提供新实例：

```
public class TestCustomer_Scope { 
  public static void main(String[] args) { 
    // TODO Auto-generated method stub 
    ApplicationContext context = new  
      ClassPathXmlApplicationContext(""customer_new.xml""); 
    Customer_Scope customer = (Customer_Scope)  
      context.getBean(""customer_Scope""); 
    System.out.println(customer.getCust_name() + ""\t"" +  
      customer.getCust_id() +    
      customer.getCust_address()); 
    customer.setCust_name(""new name set""); 
    Customer_Scope customer1 = (Customer_Scope)  
      context.getBean(""customer_Scope""); 
    System.out.println(customer1.getCust_name() + ""\t"" +  
      customer1.getCust_id() +  
      customer1.getCust_address()); 
    System.out.println(""after changing name and using prototype  
      scope""); 
    System.out.println(customer.getCust_name() + ""\t"" +  
      customer.getCust_id() +  
      customer.getCust_address()); 
    System.out.println(customer1.getCust_name() + ""\t""     
      + customer1.getCust_id()+   
      customer1.getCust_address()); 
  } 
} 

```

您可以参考完整的代码表 Ch02\U Demo\U 注释。

#### JSR 标准注释

Spring2.5 支持 JSR-250 和 3.0 之后，框架开始支持 JSR-330 标准注释，其发现方式与基于 Spring 的注释相同。JSR 为生命周期管理、bean 配置、自动连接以及更多此类需求提供了注释。让我们逐一讨论。

##### 生命周期注释

关于 bean 的生命周期，以及通过 XML 配置实现 bean 的不同方式，我们已经讨论得够多了？但是我们还没有讨论基于注释的方法。Spring 2.5 以后版本通过`@PostConstruct`和`@PreDestroy`支持生命周期管理，这分别提供了`InitializingBean`和一次性接口的替代方案。

**@施工后：**

在容器使用默认构造函数实例化 bean 之后，调用用@PostConstruct 注释的方法。在返回实例之前调用此方法。

**@PreDestroyed:**

用@PreDestroy 注释的方法将在 bean 被销毁之前调用，这允许从资源中提取值，如果对象被销毁，这些值可能会丢失。

让我们按照以下步骤使用它来了解 bean 生命周期：

1.  在 Ch02\u Bean\u Life\u java 项目中，我们在讨论 Bean Life 时已经使用了该项目，在 com.Ch02.beans 包中添加了 Car\u JSR 类。
2.  为 car 的初始化添加方法 init_car，并使用@PostConstruct 对其进行注释，如下所示：

```
      @PostConstruct 
      public void init_car() 
      { 
         System.out.println(""initializing the car""); 
         price=(long)(price+(price*0.10)); 
      } 

```

3.  添加到 a 类方法中，该方法将具有 car 销毁代码，该代码仅为资源释放，如下所示：

```
       @PreDestroy 
       public void destroy_car() 
       {   
         System.out.println(""demolishing the car""); 
       } 

```

4.  添加 bean_new.xml 来配置 bean，不要忘记在应用程序中使用注释的规则。XML 将如下所示：

```
      <context:annotation-config/> 
        <bean id=""car"" class=""com.ch02.beans.Car""       
          scope=""prototype""> 
          <property name=""chesis_number"" value=""eng2012"" /> 
          <property name=""color"" value=""baker''s chocolate"" /> 
          <property name=""fuel_type"" value=""petrol"" /> 
          <property name=""average"" value=""12.50"" /> 
          <property name=""price"" value=""643800"" /> 
        </bean> 

```

5.  在 TestCar 中添加一个 main 方法，如下所示：

```
      public static void main(String[] args) { 
        // TODO Auto-generated method stub 
        ApplicationContext context=new           
          ClassPathXmlApplicationContext(""beans.xml""); 
        // first request to get the car instance 
        Car_JSR car_one=(Car_JSR)context.getBean(""car""); 
        car_one.show(); 
      } 

```

6.  在执行代码时，我们将得到以下输出，显示调用了 init_car（）：

```
      INFO: Loading XML bean definitions from class path resource
        [beans.xml] 
      initializing the car 
      showing car eng2012 having color:-baker''s chocolate and 
      price:-708180 

```

7.  由于 destroy 方法将在 context-get-switch 之后获得，所以输出将不会显示在控制台上。我们可以使用以下代码优雅地关闭容器：

```
      ((AbstractApplicationContext)context).registerShutdownHook(); 

```

**@命名**

@使用命名注释代替应用于类级别的@Component@命名注释不提供可组合模型，但其扫描方式与@Component 相同：

```
@Named 
public class Customer { 

  private String cust_name; 
  private int cust_id; 

  private Address cust_address; 
   //default and parameterize constructor 
   //getters and setters 
} 

```

**@注入**

@Inject 用于自动连接依赖项，方法与@Autowired 相同。但它不会具有属性“required”，以指定依赖项是可选的。以下代码显示了实现：

```
@Named 
public class Customer { 

  private String cust_name; 
  private int cust_id; 

   @Inject 
  private Address cust_address; 
   // default and parameterized constructor 
   // getters and setters 
} 

```

**@配置**

class-level@Configuration 注释用于指示类作为 bean 定义的源，与我们在<beans>标记内的 XML 文件中所做的相同。</beans>

```
@Configuration 
public class MyConfiguration { 

// bean configuration will come here 

} 

```

作为@Component、@Repository 的 Spring 注释需要在框架中注册。在 XML 中，通过向<component-scan>提供一个属性基包来启用这些注释的扫描@组件扫描是启用 Spring 原型注释扫描的替代方法。语法如下所示：</component-scan>

```
@Component-Scan(basePackage=name_of_base_package) 

```

**@Bean**

@Bean 与@Configuration 一起用于声明 Bean 定义，就像我们通常在 XML 中的`<bean></bean>`标记中所做的那样。它适用于具有 bean 定义的方法。代码可以如下所示：

```
@Configuration 
public class MyConfiguration { 
    @Bean 
    public Customer myCustomer() 
    { 
        Customer customer=new Customer(); 
        customer.setCust_name(""name by config""); 
      return customer; 
   } 
} 

```

要定义从`myCustomer()`返回的 bean，还可以自定义 bean id，可通过以下方式给出：

```
@Bean(name=""myCustomer"") 

```

XML 已被基于注释的配置所取代。`AnnotationConfigApplicationContext`类帮助加载配置，方法与`ClasspathXmlApplicationContext`相同。测试类可以编写为：

```
public static void main(String[] args) { 
  ApplicationContext context=new   
     AnnotationConfigApplicationContext(MyConfiguration.class); 
  Customer customer=(Customer)context.getBean(""myCustomer""); 
  System.out.println(customer.getCust_id()+""\t""+ 
    customer.getCust_name()); 
} 

```

您可以参考 Ch02\u Demo\u JSR\u Annot 中的完整代码。

### 注

XML 提供了进行 bean 配置的集中式方法。由于依赖项不在源代码中，因此它们中的更改不会影响源代码。在 XML 配置中，源代码也不需要重新编译。但是，基于注释的配置直接是源代码的一部分，分散在整个应用程序中。它变得分散，最终变得难以控制。基于注释的注入值将被 XML 注入覆盖，因为基于注释的注入发生在 XML 注入之前。

### 弹簧表达语言（SpEL）

到目前为止，我们配置了二级类型的值。为了连接 bean，我们使用了我们编写并在编译时可用的 XML 配置。但是使用它我们无法配置运行时值。Spring 表达式提供了所需的解决方案，其值将在运行时进行计算。

使用 SpEL，开发人员可以使用 id 引用其他 bean 并设置文本值。它提供了调用对象的方法和属性的方法。SpEL 无法使用数学、关系和逻辑运算符计算值。它还支持收集和注入。这有点类似于在 JSP 中使用 EL。要使用 SpEL 的 sysntax 为“#{value}”。让我们逐一了解如何在应用程序中使用 SpEL。

#### 使用文字

在 SpEL 中使用文字无法让开发人员为 bean 的属性设置原语值。虽然在配置中使用文字并不有趣，但知道如何在表达式中使用文字肯定有助于我们使用复杂的表达式。按照以下步骤理解文字的用法，

1.  创建 Ch02_SpringEL 作为 Java 应用程序，并向其添加 Spring JAR。
2.  在 com.ch02.bean 中定义 Customer.java，如下所示：

```
      public class Customer { 
        private String cust_name; 
        private String cust_id; 
        private boolean second_handed; 
        private double prod_price; 
        private String prod_name; 
        // getters and setters 
        // toString() 
      } 

```

3.  在类路径中创建 beans.xml 以配置客户 bean，如下所示：

```
      <bean id=""cust_new"" class=""com.ch02.beans.Customer""> 
        <property name=""cust_name"" value=""Bina"" /> 
        <property name=""cust_id"" value=""#{2}"" /> 
        <property name=""prod_name"" value=""#{''Samsung Fridge''}"" /> 
        <property name=""prod_price"" value=""#{27670.50}"" /> 
        <property name=""second_handed"" value=""#{false}"" /> 
      </bean> 

```

您可以观察使用 SpEL 语法配置的 cust_id、prod_price 的值为“”{value}”，我们使用单引号指定 prod_name 的值。您甚至可以使用双引号来指定字符串值。客户名称已以旧式配置。是的，仍然可以同时使用旧式和 SpEL 来设置值。

4.  添加 TestCustomer.java，如下代码所示：

```
      public static void main(String[] args) { 
        // TODO Auto-generated method stub 
          ApplicationContext context=new     
          ClassPathXmlApplicationContext(""beans.xml""); 
        Customer customer=(Customer)context.getBean(""cust_new""); 
        System.out.println(customer); 
      } 

```

5.  我们将得到如下输出：

```
      INFO: Loading XML bean definitions from class path resource 
      [beans.xml] 
      Bina has bought Samsung Fridge for Rs 27670.5 

```

#### 使用 bean 引用

XML 中配置的每个 bean 都有其唯一的 bean id。这可用于引用值或使用 SpEL 进行自动连接。使用以下步骤了解如何使用 bean 引用。

1.  在上面的 Ch02_SpringEL 项目中，在 com.Ch02.beans 中添加新的 POJO 类作为地址和 Customer_ 引用，如下所示：

```
      public class Address { 
        private String city_name; 
        private int build_no; 
        private long pin_code; 

        // getter and setter 
        @Override 
        public String toString() { 
          // TODO Auto-generated method stub 
          return city_name+ "",""+pin_code; 
        } 
      } 
      public class Customer_Reference { 
        private String cust_name; 
        private int cust_id; 
        private Address cust_address; 

        // getter and sertter 

        @Override 
        public String toString() { 
          return cust_name + "" is living at "" + cust_address; 
        } 
      } 

```

2.  在 beans.xml 中添加地址和客户参考 bean，如下所示：

```
      <bean id=""cust_address"" class=""com.ch02.beans.Address""> 
        <property name=""build_no"" value=""2"" /> 
        <property name=""city_name"" value=""Pune"" /> 
        <property name=""pin_code"" value=""123"" /> 
      </bean> 
      <bean id="cust_ref" class=""com.ch02.beans.Customer_Reference""> 
        <property name=""cust_name"" value=""Bina"" /> 
        <property name=""cust_id"" value=""#{2}"" /> 
        <property name=""cust_address"" value=""#{cust_address}"" /> 
      </bean> 

```

观察 cust_ 地址的初始化方式。客户的地址作为 cust_address 进行赋值，cust_address 是为 address 定义的 bean 的 id。

3.  定义 TestCustomer_ 引用，就像我们在前面案例的步骤 4 中所做的那样，以获取 bean“cust_ref”。
4.  执行时，我们将获得如下所示的输出：

```
      INFO: Loading XML bean definitions from class path resource
      [beans.xml] 
      Bina is living at Pune,123 

```

5.  有时，我们可能希望只注入 bean 的一个属性，而不是使用 bean，如下所示：

```
      <bean id="cust_ref_new"class="com.ch02.beans.Customer_Reference"> 
        <property name=""cust_name""  
          value=""#{cust_ref.cust_name.toUpperCase()}"" /> 
        <property name=""cust_id"" value=""#{2}"" /> 
        <property name=""cust_address"" value=""#{cust_address}"" /> 
      </bean> 

```

我们从 bean'cust_ref'借用 cust_name 并将其转换为大写，从而注入了 cust_name。

#### 使用数学、逻辑、关系运算符

在某些场景中，依赖项的值需要数学、逻辑或关系运算符来定义和放置依赖项的值。您可以在下面的演示中找到如何使用它们。

1.  我们将使用前面案例中定义的相同项目 Ch02_SpringEL。
2.  在 beans.xml 中为客户定义一个 bean，如下所示：

```
      <bean id=""cust_calculation"" class="com.ch02.beans.Customer""> 
        <property name="cust_name" value="Bina" /> 
        <property name="cust_id" value="#{2}" /> 
        <property name="prod_name" value="#{''Samsung Fridge''}" /> 
        <property name="prod_price" value="#{27670.50*12.5}" /> 
        <property name="second_handed"  
          value="#{cust_calculation.prod_price > 25000}" /> 
      </bean> 

```

产品价格的值在运行时通过数学运算符和关系运算符计算的“二手货”值进行计算。

3.  编写 TestCustomer\u Cal 以获取客户计算并显示其属性，如下所示：

```
      public static void main(String[] args) { 
        // TODO Auto-generated method stub 
        ApplicationContext context=new  
          ClassPathXmlApplicationContext(""beans.xml""); 
        Customer customer=    
          (Customer)context.getBean(""cust_calculation""); 
        System.out.println(customer); 
        System.out.println(customer.isSecond_handed()); 
      } 

```

在本章中，我们已经了解了如何进行配置。但我们忽略了一个非常重要的点“松耦合”。在任何地方，我们都使用导致紧密耦合的类，我们知道契约式编程为开发人员提供了编写松散耦合模块的便利。我们避免为以上所有演示使用接口，因为这可能会使它们变得不必要的复杂。但是在实时应用程序中，您会发现在 Spring 的每个阶段都使用了接口。从下一章开始，我们将使用编写基于 Spring 的应用程序的标准方法。

## 总结

* * *

这一章充满了做同一件事的配置、不同的方法和备选方案。无论 Spring 版本是 5.0 还是更低版本，本章都将帮助您完成 Spring 的整个旅程。在本章中，我们将探讨创建实例和初始化实例的各种方法。我们现在已经了解了几乎所有类型的 Java 概念，以及如何使用 XML 和基于注释的方式进行配置。我们还看到了自动布线、SpEL 等方法来最小化配置。我们演示了 Spring 以及 JSR 注释。

现在我们准备在应用程序中实现所有这些。让我们从数据库处理开始。在下一章中，我们将了解如何使用 Spring 处理数据库，以及 Spring 如何帮助我们进行更快的开发。