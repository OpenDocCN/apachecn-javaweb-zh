# 四、面向切面编程

关于 SpringDAO 的前一章给出了 Spring 如何处理松散耦合的 JDBCAPI 的良好实践。但是，我们既没有讨论 JDBC 事务，也没有讨论 Spring 如何处理事务。如果您已经处理了事务，那么您知道它的步骤以及更多，您很清楚这些步骤是重复的，并且分布在整个代码中。一方面，我们说使用 Spring 来停止代码的重复，另一方面，我们正在编写这样的代码。Java 坚持编写具有高度内聚性的模块。但是在代码中编写事务管理将不允许我们编写内聚模块。此外，交易不是编写代码的动机。它只是提供支持，以便应用的业务逻辑不会执行任何不希望的效果。我们还没有讨论如何处理这些支持功能以及应用开发的主要动机。除了事务之外，为应用提供支持的功能还有哪些？本章将帮助我们编写高度内聚的模块，而无需重复代码来处理此类支持功能。在本章中，我们将讨论以下几点：

*   什么是交叉技术？
*   横切技术在应用开发中扮演什么角色？
*   我们将讨论 AOP 以及 AOP 如何在处理横切技术方面发挥重要作用。
*   我们将深入探讨 AOP 中的方面、建议和切入点。

软件应用为客户的问题提供了可靠的解决方案。虽然我们说可靠，但总有可能出现一些运行时问题。所以随着开发，软件的维护也同样重要。每当应用中出现问题时，客户机就会返回给开发人员寻求解决方案。除非并且直到客户无法陈述问题的准确原因，否则开发人员将无能为力。开发人员必须重新创建相同的情况，以防止它再次发生。在企业应用中，由于模块数量巨大，同一问题的再现变得复杂。如果有人能一直跟踪用户正在做什么，那就太好了。此跟踪程序的跟踪功能帮助开发人员了解错误的原因和原因，甚至使用跟踪程序，以便他们可以轻松地重新创建跟踪程序。是的，我说的是日志机制。

让我们来看看另一个非常常见的铁路订票情况。在订票时，我们从图表中选择可用的座位并进行汇款。有时，钱被成功地转移，就像票被预订一样。但不幸的是，有时由于资金交易时间，表格填写延迟或某些服务器端问题可能会导致在未预订机票的情况下转账出现问题。这笔钱不用开罚单就扣了。客户对于退款会感到不高兴，而且会感到紧张。此类情况需要在交易管理的帮助下小心处理，以便在未发行票据的情况下，将资金存入客户账户。手动操作将是一项乏味的任务，而事务管理将优雅地处理它。

我们可以在不进行日志记录或事务管理的情况下编写可行的代码，因为这两者都不是业务逻辑的一部分。Java 应用围绕着为企业问题提供定制的、简单的解决方案。业务逻辑是提供应用主要功能的核心，有时可能被称为“主要关注点”。但它还必须支持其他一些功能或服务，不能忽视。这些服务在应用中起着至关重要的作用。要么迁移应用变得耗时，要么回溯运行时出现的问题将很困难。这些关注点分散在整个应用中，主要是重复的代码。此类次要关注点称为“交叉关注点”，有时也称为“水平关注点”。日志、事务管理、安全机制是开发人员在应用中使用的一些交叉关注点。

下图显示了日志记录和事务管理等横切关注点在应用代码中的分散方式：

![](https://www.packtpub.com/graphics/9781787120341/graphics/image_04_001.png)

## 面向切面编程（AOP）

* * *

与面向对象编程类似，面向切面编程也是一种编程风格，它允许开发人员通过将横切关注点与业务逻辑代码分离来编写内聚代码。AOP 概念由 Gregor KicZales 及其同事开发。它提供了不同的方法或工具来编写横切关注点。

处理交叉问题的 AOP 写在一个地方，这有助于实现以下好处：，

*   减少代码的重复，以实现编写干净的代码。
*   帮助编写松散耦合的模块。
*   有助于实现高度内聚的模块。
*   开发人员可以集中精力编写业务逻辑
*   无需触摸现有代码即可轻松更改或修改代码以实现新功能。

要理解 AOP，我们必须了解以下通用术语，没有这些术语，我们无法想象 AOP。

### 连接点

连接点是应用中的一些点，在这些点上，可以插入一个方面来实现一些其他功能，而不必成为实际业务逻辑的一部分。每个代码都有许多机会，可以将其视为连接点。类是应用中最小的单元，它有数据成员、构造函数、setter 和 getter 以及其他函数类。其中每一个都可以成为应用方面的机会。Spring 只支持作为连接点的方法。

### 切入点

连接点是机会，但在可以应用方面的地方没有考虑所有这些机会。切入点是开发人员决定应用方面来执行横切关注点的特定操作的地方。切入点将使用方法名、类名、正则表达式来定义可以应用方面的匹配包、类和方法。

### 忠告

方面在切入点采取的行动称为“建议”。通知中包含针对各个横切关注点执行的代码。如果将该方法视为连接点，则可以在执行方法之前或之后应用该方面。该方法还可能具有异常处理代码，可以在其中插入方面。以下是 Spring 框架中可用的建议。

#### 之前

Before 建议包含将在匹配切入点表达式的业务逻辑方法之前应用的实现。除非没有抛出异常，否则它将继续执行该方法。@Before 注释或<before>配置可应用于支持 Before 建议的方法。</before>

#### 之后

在 After 通知中，实现将在业务逻辑方法之后应用，而不管该方法是成功执行还是抛出异常。@After 注释或<after>配置可用于通过将其应用于方法来支持 Before 通知。</after>

#### 返回后

返回后的通知具有仅在成功执行业务逻辑方法后应用的实现。@AfterReturning 注释或<after-returning>配置可应用于支持 AfterReturning 建议的方法。返回后通知方法可以使用业务逻辑方法返回的值。</after-returning>

#### 投掷后

After Throwng 通知具有在执行引发异常的业务逻辑方法之后应用的实现。@Afterhrowing 注释或<throwing>配置可用于通过将其应用于方法来支持抛出建议后的操作。</throwing>

#### 周围

在所有建议中，环绕建议是最重要的，也是在执行业务逻辑方法之前和之后应用于方法的唯一建议。它可用于选择是否使用 ProceedingJoinPoint 的 proceed（）方法调用继续下一个连接点。继续（）通过返回自己的返回值，帮助选择是否继续到连接点。它可以用于开发人员需要执行预处理、后处理或两者兼而有之的场景。计算方法执行所花费的时间就是这样的场景之一。@Around 注释或<around>配置可用于通过将其应用于方法来支持 Around 建议。</around>

### 方面

方面通过切入点表达式和建议来定义机会，以指定何时何地采取行动@方面注释或<aspect>配置应用于类以将其声明为方面。</aspect>

### 导言

介绍有助于在不更改现有代码的情况下声明现有类中的其他方法和字段。SpringAOP 允许开发人员向方面建议的任何类引入新接口。

### 目标物体

目标对象是应用方面的类的对象。SpringAOP 在运行时创建目标对象的代理。将重写类中的方法，并将通知包含到该方法中以获得所需的结果。

### AOP 代理

默认情况下，SpringAOP 使用 JDK 的动态代理来获取目标类的代理。使用 CGLIB 创建代理也是很常见的。始终使用 SpringAOP 代理机制代理目标对象。

### 编织

作为开发人员，我们在两个单独的模块中编写业务逻辑和方面代码。然后，必须将这两个类合并为代理目标类。在业务逻辑代码中插入方面的过程称为“编织”。编织可以发生在编译时、加载时或运行时。SpringAOP 在运行时进行编织。

让我们举一个非常简单的例子来理解所讨论的术语。我儿子喜欢看戏剧。所以我们去看了一场。我们都知道，除非我们有入场证或入场券，否则我们不能入场。显然我们需要先收集它们。一拿到票，我儿子就把我拖到座位上，兴奋地把座位给我看。演出开始了。对孩子们来说，这是一部有趣的戏剧。所有的孩子都在笑话中大笑，在对话中鼓掌，在戏剧性的场景中兴奋不已。幕间休息时，大多数观众去吃爆米花、零食和冷饮。大家都很欣赏这出戏，高兴地离开了出口。现在，我们可能认为我们都知道这一点。我们为什么要讨论这个问题，以及它与相位的关系。我们不是偏离了讨论的方向吗？不，我们在正确的轨道上。等一会儿，你们也会同意的。在这里，我们的主要任务是看电视剧，比如说这是我们的业务逻辑或核心关注点。购买门票、支付费用、进入剧院、戏剧结束后离开剧院，这些功能是核心关注的一部分。但我们不能静静地坐着，我们会对发生的事情做出反应吗？我们鼓掌、大笑，有时甚至哭泣。但这些是主要的担忧吗？不但如果没有它们，我们无法想象观众在看电视剧。这些将是每个观众自发的支持功能。对的这些是贯穿各领域的问题。观众不会单独获得关于交叉关注点的说明。这些反应是有建议的方面的一部分。有些人会在演出前鼓掌，少数人会在演出后鼓掌，他们感到最激动的时候。这些都是在相位的建议之前、之后或周围。如果观众不喜欢这部戏，他们可能会在这段时间内离开，就像抛出例外之后一样。在非常不幸的一天，演出可能会被取消，甚至中途停止，这需要组织者作为紧急情况介绍。希望您现在了解这些概念及其实际方法。我们将在稍后的演示中介绍这一点以及更多内容。

在继续演示之前，让我们首先讨论一下市场上的一些 AOP 框架，如下所示。

#### AspectJ

AspectJ 是易于使用和学习的 Java 兼容框架，用于集成横切实现。AspectJ 已在 PARC 开发。如今，它是著名的 AOP 框架之一，因为它的简单性，但却具有支持组件模块化的能力。它可以用于在静态或非静态字段、构造函数、私有、公共或受保护的方法上应用 AOP。

#### AspectWertz

AspectWertz 是另一个与 Java 兼容的轻量级强大框架。它可以很容易地集成到新的和现有的应用中。AspectWertz 支持 XML 以及基于注释的方面编写和配置。它支持编译时、加载时和运行时编织。自 AspectJ5 以来，它已合并到 AspectJ 中。

#### JBoss AOP

JBossAOP 支持编写方面和动态代理目标对象。它可以用于在静态或非静态字段、构造函数、私有、公共或使用拦截器保护的方法上应用 AOP。

#### Dynaop

Dynaop 框架是基于代理的 AOP 框架。该框架有助于减少依赖性和代码重用性。

#### 凯撒

CASER 是 Java 兼容的 AOP 框架。它支持抽象组件的实现及其集成。

#### 弹簧 AOP

它是一个 Java 兼容的易用框架，用于在 Spring 框架中集成 AOP。它利用 SpringIOC 在组件中提供 AOP 实现的紧密集成。它是一个基于代理的框架，可用于方法执行。

Spring AOP 满足应用横切关注点的最大要求。但以下是 Spring AOP 无法应用的一些限制：，

*   Spring AOP 不能应用于字段
*   我们不能在一个方面应用任何其他方面
*   无法建议使用私有和受保护的方法
*   不能通知施工人员

Spring 支持 AspectJ 和 SpringAOP 集成，以较少的编码使用横切关注点。Spring AOP 和 AspectJ 都用于实现横切技术，但以下几点有助于开发人员在实现中做出最佳选择：

*   SpringAOP 基于动态代理，它只支持方法连接点，但 AspectJ 可以应用于字段、构造函数，即使它们是私有的、公共的或受保护的，也支持细粒度的通知。
*   SpringAOP 不能用于调用同一类的方法或静态或最终的方法，但 AspectJ 可以。
*   AspectJ 不需要 Spring 容器来管理组件，而 Spring AOP 只能用于由 Spring 容器管理的组件。
*   SpringAOP 支持基于代理模式的运行时编织，AspectJ 支持编译时编织，不需要创建代理。一旦应用请求 bean，就会创建对象的代理。
*   SpringAOP 编写的 Aspect 是基于 Java 的组件，而 AspectJ 编写的 Aspect 是 Java 的扩展语言，因此开发人员需要在使用之前先学习它。
*   SpringAOP 很容易通过使用@Aspect 注释或简单配置来实现。但是要使用 AspectJ，需要创建*.aj 文件。
*   SpringAOP 不需要任何特殊的容器，但是方面需要，因为使用 AspectJ 创建的方面需要使用 AspectJ 编译器进行编译。
*   AspectJ is a best choice for the applications which already exists.

    ### 注

    没有最终静态方法的简单类只使用 SpringAOP，否则选择 AspectJ 编写方面。

让我们深入讨论 SpringAOP 及其实现方式。SpringAOP 可以使用基于 XML 的方面配置或基于 AspectJ 风格注释的实现来实现。基于 XML 的配置可以在多个点上进行拆分，这使得它有点复杂。在 XML 中，我们不能定义命名切入点。但是由注释编写的方面在单个模块中，该模块支持编写命名切入点。因此，在不浪费时间的情况下，让我们开始基于 XML 的方面开发。

### 基于 XML 的方面配置

以下是开发基于 XML 的方面需要遵循的步骤，

1.  选择要实施的横切关注点
2.  编写方面以满足横切关注点的要求。
3.  在 Spring 上下文中将方面注册为 bean。
4.  将方面配置写为：

*在 XML 中添加 AOP 命名空间。

*添加具有切入点表达式和建议的方面配置。

*注册可以应用方面的 bean。

从可用的连接点开始，开发人员需要决定跟踪哪个连接点，然后需要使用表达式编写切入点来定位它们。为了编写这样的切入点，Spring 框架使用 AspectJ 的切入点表达式语言。我们可以借助表达式中的下列指示符来编写切入点。

#### 使用方法签名

方法签名可用于从可用连接点定义切入点。可以使用以下语法编写表达式：

```java
expression(<scope_of_method>    <return_type><fully_qualified_name_of_class>.*(parameter_list)
```

Java 支持 private、public、protected 和 default 作为方法作用域，但是 SpringAOP 在编写切入点表达式时只支持 public 方法。参数列表用于指定匹配方法签名时将考虑哪些数据类型。如果开发人员不想指定参数数量或数据类型，可以使用两点（..）。

让我们考虑下面的表达式来理解表达式的深度写，以决定哪些连接点将被建议：

*   `expression(* com.packt.ch04.MyClass.*(..)`-指定 com.packt.cho3 包中具有 MyClass 任何签名的所有方法。
*   `expression(public int com.packt.ch04.MyClass.*(..)`-指定 com.packt.cho3 包中从 MyClass 返回整数值的所有方法。
*   `expression(public int com.packt.ch04.MyClass.*(int,..)`-指定 com.packt.cho3 包中从 MyClass 返回 integer 及其 integer 类型的第一个参数的所有方法。
*   `expression(* MyClass.*(..)`-指定将建议所有具有 MyClass 任何签名的方法。这是一种非常特殊的表达式，只有当 advice 和类属于同一个包时才能使用。

#### 使用类型

类型签名用于匹配具有指定类型的连接点。我们可以使用以下语法指定类型：

```
within(type_to_specify) 

```

这里的类型将是包或类名。以下是一些可用于指定连接点的表达式：

*   `within(com.packt.ch04.*)`-指定属于 com.packt.ch04 包的所有类中的所有方法
*   `within(com.packt.ch04..*)`-指定属于 com.packt.ch04 包及其子包的所有类中的所有方法。我们指定了两个点而不是一个点来跟踪子包。
*   `within(com.packt.ch04.MyClass)`-指定 MyClass 中属于 com.packt.ch04 包的所有方法
*   `within(MyInterface+)`-指定实现 MyInterface 的所有类中的所有方法。

#### 使用 Bean 名称

Spring2.5 以后的所有版本都支持在表达式中使用 bean 名称来匹配连接点。我们可以使用以下语法：

```
bean(name_of_bean) 

```

考虑下面的例子：

`bean(*Component)`-表达式指定要匹配的连接点，该连接点属于名称以 Component 结尾的 bean。表达式不能与 AspectJ 批注一起使用。

#### 使用这个

“this”用于匹配 bean 引用是指定类型实例的连接点。当表达式指定类的名称而不是接口时使用。当 SpringAOP 使用 CGLIB 创建代理时使用它。

#### 5.5.设定目标

目标用于匹配连接点，其中目标对象是指定类型的接口。当 SpringAOP 使用基于 JDK 的代理创建时，会使用它。仅当目标对象正在实现接口时才使用目标。开发人员甚至可以将属性“代理目标类”设置为 true。

让我们考虑下面的例子来理解这个和目标在表达式中的用法：

```
package com.packt.ch04; 
Class MyClass implements MyInterface{ 
  // method declaration 
} 

```

我们可以将表达式写入目标方法，如下所示：

`target( com.packt.ch04.MyInterface)`或

`this(com.packt.ch04.MyClass)`

#### 用于注释跟踪

开发人员可以编写切入点表达式，这些表达式不跟踪方法，而是跟踪应用的注释。让我们通过以下示例来了解如何监视注释。

**与执行一起使用：**

执行（@com.packt.ch03.MyAnnotation）-指定以使用 MyAnnotation 注释的方法或类为目标。

execution（@org.springframework.transaction.annotation.Transactional）-指定以使用 Transactional 注释的方法或类为目标。

**与@target:**一起使用

它被用来考虑用指定注释注释类的连接点。下面的例子说明了这一点，

@目标（COM.PACT.CH03.MyService）-用于考虑由 MyService 注释注释的连接点。

**使用@args:**

表达式用于指定已使用给定类型注释参数的连接点。

@args（com.packt.ch04.annotations.MyAnnotation）

上面的表达式用于考虑由@ Myannotation 注释的接受对象的连接点。

**使用@within:**

表达式用于指定给定注释指定的类型内的连接点。

@内（org.springframework.stereotype.Repository）

上面的表达式有助于为@Repository 注释的连接点提供建议。

**使用@annotation:**

@注释用于匹配已由相应注释注释的连接点。

@注释（com.packt.ch04.annotations.Annotation1）

表达式匹配由 Annotation1 注释的所有连接点。

让我们使用切入点表达式，建议实现日志方面，以了解实时实现。我们将使用上一章中开发的应用 Ch03_JdbcTemplates 在其中集成 Log4j 作为基础。在第一部分中，我们将创建主应用的副本，第二部分将其与 log4J 集成，在第三部分中，我们将应用定制的日志方面。