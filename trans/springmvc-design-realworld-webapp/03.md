# 三、用 Spring 访问数据

数据访问或持久化是数据驱动应用的主要技术特性。这是一个需要仔细设计和专业知识的关键领域。现代企业系统使用各种各样的数据存储机制，从传统的关系数据库（如 Oracle、SQL Server 和 Sybase）到更灵活、无模式的 NoSQL 数据库（如 MongoDB、Cassandra 和 Couchbase）。Spring 框架以多种机制为数据持久化提供全面支持，从方便的模板组件到流行的**ORM**（**对象关系映射**工具和库的智能抽象，使它们更易于使用。Spring 的数据访问支持是选择它开发 Java 应用的另一个重要原因。

Spring Framework 为数据持久化机制提供了以下主要方法供开发人员选择：

*   SpringJDBC
*   ORM 数据访问
*   弹簧数据

此外，Spring 在一个名为`@Repository`的统一**DAO**（**数据访问对象**符号）下对上述方法进行了标准化。

使用 Spring 的另一个引人注目的原因是它的一流事务支持。Spring 提供了一致的事务管理，抽象了不同的事务 API，如 JTA、JDBC、JPA、Hibernate、JDO 和其他特定于容器的事务实现。

为了简化开发和原型设计，Spring 提供了嵌入式数据库支持、智能抽象（`DataSource`和优秀的测试集成。本章探讨 Spring 框架提供的各种数据访问机制及其对独立和 web 环境中事务管理的全面支持，并提供相关示例。

### 注

**既然有 JDBC，为什么还要使用 Spring 数据访问？**

**JDBC**（**Java Database Connectivity**），Java 到关系数据库的数据连接的 Java 标准版 API，是一个非常低级的框架。通过 JDBC 访问数据通常很麻烦；开发人员需要编写的锅炉板代码使代码容易出错。此外，JDBC 异常处理对于大多数用例来说是不够的；对于数据访问，确实需要简化但广泛且可配置的异常处理。SpringJDBC 封装了经常重复的代码，极大地简化了开发人员代码，并让开发人员直接关注业务逻辑。Spring 数据访问组件抽象了技术细节，包括持久化资源（如连接、语句和结果集）的查找和管理，并接受特定的 SQL 语句和相关参数来执行操作。Spring 数据访问组件在幕后使用相同的 JDBCAPI，同时为客户端提供简化、直观的接口。这种方法为 Spring 应用提供了一个更干净、因而可维护的数据访问层。

# 配置数据源

从任何 Java 应用连接到数据库的第一步是获取 JDBC 指定的连接对象。`DataSource`是 Java SE 的一部分，是`java.sql.Connection`对象的通用工厂，表示与数据库的物理连接，是产生连接的首选方法。`DataSource`处理事务管理、连接查找和池功能，减轻开发人员的基础设施问题。

`DataSource`对象通常由数据库驱动程序供应商实现，通常通过 JNDI 查找。应用服务器和 Servlet 引擎提供自己的`DataSource`（和）实现，或数据库供应商提供的`DataSource`对象的连接器。通常在基于 XML 的服务器描述符文件中配置，服务器提供的`DataSource`对象通常提供内置的连接池和事务支持。作为开发人员，您只需在服务器配置文件中以 XML 声明方式配置数据源，并通过 JNDI 从应用中查找它们。

在 Spring 应用中，您将`DataSource`引用配置为 Springbean，并将其作为依赖项注入 DAO 或其他持久化资源。弹簧`<jee:jndi-lookup/>`标签（属于[http://www.springframework.org/schema/jee](http://www.springframework.org/schema/jee) 名称空间）允许您轻松查找和构造 JNDI 资源，包括从应用服务器内部定义的`DataSource`对象。对于部署在 J2EE 应用服务器中的应用，建议使用容器提供的 JNDI`DataSource`对象。

```java
<jee:jndi-lookup id="taskifyDS" jndi-name="java:jboss/datasources/taskify"/>
```

对于独立应用，您需要创建自己的`DataSource`实现或使用第三方实现，如 Apache Commons DBCP、C3P0 或 BoneCP。以下是使用 Apache Commons DBCP2 的`DataSource`配置示例。它还提供了可配置的连接池功能。

```
<bean id="taskifyDS" class="org.apache.commons.dbcp2.BasicDataSource" destroy-method="close">
    <property name="driverClassName" value="${driverClassName}" />
    <property name="url" value="${url}" />
    <property name="username" value="${username}" />
    <property name="password" value="${password}" />
    <property name="initialSize" value="3" />
    <property name="maxTotal" value="50" />
    ...
</bean>
```

确保将相应的依赖项添加到构建文件中的`DataSource`实现中。以下内容适用于 DBCP2：

```
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-dbcp2</artifactId>
    <version>2.1.1</version>
</dependency>
```

Spring 提供了`DriverManagerDataSource`，这是`DataSource`的一个简单实现，仅用于测试和开发目的，不用于生产。请注意，它不提供连接池。下面是如何在应用中配置它。

```
<bean id="taskifyDS" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
    <property name="driverClassName" value="${driverClassName}" />
    <property name="url" value="${url}" />
    <property name="username" value="${username}" />
    <property name="password" value="${password}" />
</bean>
```

还可以使用基于 Java 的配置对其进行配置，如以下代码所示：

```
@Bean
DataSource getDatasource() {
    DriverManagerDataSource dataSource = new DriverManagerDataSource(pgDsProps.getProperty("url"));
    dataSource.setDriverClassName( pgDsProps.getProperty("driverClassName"));
    dataSource.setUsername(pgDsProps.getProperty("username"));
    dataSource.setPassword(pgDsProps.getProperty("password"));
    return dataSource;
}
```

### 注

切勿在生产环境中使用。独立应用使用第三方数据源，如 DBCP、C3P0 和 BoneCP，而 J2EE 容器使用容器提供的 JNDI`DataSource`。它们更可靠，提供了现成的高效连接池功能。

# 使用嵌入式数据库

对于原型和测试环境，最好使用基于 Java 的嵌入式数据库快速启动项目并轻松配置。它们重量轻，易于测试。Spring 本机支持 HSQL、H2 和 Derby 数据库引擎。以下是嵌入式 HSQL 数据库的`DataSource`配置示例：

```
@Bean
DataSource getHsqlDatasource() {
    return new 
        EmbeddedDatabaseBuilder().setType(EmbeddedDatabaseType.HSQL)
         .addScript("db-scripts/hsql/db-schema.sql")
         .addScript("db-scripts/hsql/data.sql")
         .addScript("db-scripts/hsql/storedprocs.sql")
         .addScript("db-scripts/hsql/functions.sql")
         .setSeparator("/").build();
}
```

此文件的 XML 版本类似于以下代码：

```
<jdbc:embedded-database id="dataSource" type="HSQL">
  <jdbc:script location="classpath:db-scripts/hsql/ db-schema.sql" />
    . . . 
</jdbc:embedded-database>
```

# Spring 数据层异常处理

对于传统的基于 JDBC 的应用，异常处理基于`java.sql.SQLException`，这是一个已检查的异常。它迫使开发人员仔细地编写`catch`和`finally`块，以进行适当的处理，并避免资源泄漏，例如使数据库连接保持打开状态。Spring 基于`RuntimeException`的智能异常层次结构使开发人员免于这场噩梦。以`DataAccessException`为根，Spring 绑定了一组有意义的异常，转换了传统的 JDBC 异常。Spring 还以一致的方式涵盖 Hibernate、JPA 和 JDO 异常。

Spring 使用`SQLErrorCodeExceptionTranslator`，继承`SQLExceptionTranslator`将`SQLException`翻译为`DataAccessExceptions`。我们可以扩展这个类来定制默认的翻译。我们可以通过注入持久化资源（如`JdbcTemplate`，稍后将介绍），用自定义实现替换默认转换器。关于我们如何在代码中定义`SQLExceptionTranslator`类，请参见以下代码列表：

```
String userQuery = "select * from TBL_NONE where name = ?";
SQLExceptionTranslator excTranslator = new SQLExceptionTranslator() {

  @Override
  public DataAccessException translate(String task, String sql, SQLException ex) {
    logger.info("SUCCESS --- SQLExceptionTranslator.translate invoked !!");
    return new BadSqlGrammarException("Invalid Query", userQuery, ex){};
  }
};
```

前面的代码片段捕获任何`SQLException`并将其转换为基于 Spring 的`BadSqlGrammarException`实例。那么这个自定义`SQLExceptionTranslator`需要在使用前传递给`Jdbctemplate`，如下代码所示：

```
JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
jdbcTemplate.setExceptionTranslator(excTranslator);
Map<String, Object> result = jdbcTemplate.queryForMap(userQuery, new Object[] {"abc"});
```

现在，任何无效查询都将调用自定义`SQLExceptionTranslator`类。您可以根据需要自定义其行为。

# DAO 支持和@Repository 注释

访问数据的标准方式是通过在数据访问层下执行持久化功能的专用 DAO。Spring 遵循相同的模式，提供 DAO 组件，并允许开发人员使用注释`@Repository`将其数据访问组件标记为 DAO。这种方法确保了各种数据访问技术（如 JDBC、Hibernate、JPA 和 JDO）以及特定于项目的存储库之间的一致性。Spring 将`SQLExceptionTranslator`应用于所有这些方法。

Spring 建议使用原型`@Repository`对数据访问组件进行注释。术语 repository 最初在*域驱动设计*、*Eric Evans*、*Addison Wesley*中定义为“一种封装存储、检索和搜索行为的机制，模拟对象集合”。此注释使该类符合`DataAccessException`的条件 Spring 框架下的翻译。

Spring 数据是 Spring 提供的另一种标准数据访问机制，它围绕`@Repository`组件运行。我们将在后面的章节中对此进行详细讨论。

# Spring JDBC 抽象

SpringJDBC 组件通过封装样板代码并通过一组简单的接口向开发人员隐藏与 JDBC API 组件的交互，简化了基于 JDBC 的数据访问。这些接口根据需要处理 JDBC 资源（连接、语句、结果集）的打开和关闭。它们准备并执行语句，从 ResultSet 中提取结果，提供用于转换、映射和处理数据的回调挂钩，处理事务，并将 SQL 异常转换为更合理、更有意义的`DataAccessException`层次结构。

Spring JDBC 提供了三种方便的访问关系数据库的方法：

*   `JdbcTemplate`
*   `SimpleJDBC`课程
*   RDBMS`Sql*`类

每个 SpringJDBC 类别下都有多种风格的组件，您可以根据自己的便利性和技术选择进行混合和匹配。您可以在`org.springframework.jdbc`包及其子包下探索它们。

## jdbc 模板

`JdbcTemplate`是 Spring JDBC 抽象下的核心组件。这个功能强大的组件通过其简单、有意义的方法执行几乎所有可能的 JDBC 操作，为一组令人印象深刻的数据访问接受参数。它属于包`org.springframework.jdbc.core`，其中包含许多其他支持类，帮助`JdbcTemplate`完成其 JDBC 操作。`DataSource`实例是该组件的唯一依赖项。所有其他 Spring JDBC 组件在内部使用`JdbcTemplate`进行操作。

通常，您将`JdbcTemplate`配置为另一个 Springbean，并将其注入 DAO 或任何其他您希望调用其方法的 bean 中。

```
<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
  <constructor-arg ref="dataSource"/>
</bean>
<bean id="userDAO" class="com.springessentials.chapter3.dao.impl.UserJdbcDAO">
  <constructor-arg ref="jdbctemplate"/>
</bean>
```

### 注

`JdbcTemplate`是 Spring 中模板模式的实现之一。模板模式是*四人帮*设计模式目录中列出的行为模式。它在称为**模板方法**的方法或操作中定义了算法的框架，将一些步骤推迟到子类中，而不改变算法的结构。`JdbcTemplate`是这些模板方法的集合；用户可以根据特定的需求对其进行扩展并覆盖某些行为。`JMSTemplate`和`JpaTemplate`也是模板模式实现的示例。

`JdbcTemplate`执行 SQL 查询（`SELECT`）、update 语句（`INSERT`、`UPDATE`和`DELETE`）、存储过程和函数调用，返回提取的结果（对于`SELECT`查询），调用回调方法提取结果集，并将行与域对象映射。对于结果集提取的不同方法，它有一套全面的查询和执行方法。下表介绍了几种非常有用的`JdbcTemplate`方法：

<colgroup><col> <col></colgroup> 
| 

方法

 | 

描述

 |
| --- | --- |
| `execute` | 用于执行 SQL update（`INSERT`、`UPDATE`、`DELETE`语句的一组重载方法，具有不同的参数集，包括要执行的 SQL 语句、绑定参数、语句创建者和回调方法。 |
| `query` | 一组重载方法，用于查询给定 SQL`SELECT`语句的`PreparedStatement`，其中包含大量参数集，包括绑定参数、参数类型、`RowMapper`、`ResultSetExtractor`、`PreparedStatementCreator`、`RowCallbackHandler`等。带有回调的方法是 void 方法，而其他方法返回一个类型为`<T>`的对象列表，并指定相应的`RowMapper`、`ResultSetExtractor`或填充的`<T>`类型实例。 |
| `queryForList` | 执行`SELECT`查询的重载查询方法集返回一个类型为`<T>`的对象列表，该类型的对象被指定为参数`Class<T> elementType`。未指定`elementType`返回`List<Map<String, Object>>`的方法。 |
| `queryForMap` | 执行一个（`SELECT`查询并将结果返回为`Map<String, Object>`。 |
| `queryForObject` | 查询给定 SQL`SELECT`语句的一组重载方法，参数集包括绑定参数、参数类型、`RowMapper`和所需返回类型`<T>`。 |
| `update` | 一组重载方法，发出 update（`INSERT`、`UPDATE`或`DELETE`语句，参数集包括绑定参数、参数类型、`PreparedStatementCreator`等。它返回一个整数，即受影响的记录数。 |
| `batchUpdate` | 一组重载方法，用于使用不同的参数集执行多个 SQL 更新（`INSERT`、`UPDATE`和 DELETE），这些参数集包括一组 SQL 语句以及`PreparedStatementSetter`和其他参数的多种组合。 |
| `execute` | 一组用于执行 SQL 更新的重载方法（无论是`INSERT`、`UPDATE`还是`DELETE`语句，具有不同的参数集，包括要执行的 SQL 语句、绑定参数、`StatementCreator`和回调方法。 |
| `query` | 一组重载方法，用于查询给定 SQL`SELECT`语句的`PreparedStatement`，其中包含多个参数集，包括绑定参数、参数类型、`RowMapper`、`ResultSetExtractor`、`PreparedStatementCreator`、`RowCallbackHandler`等。虽然那些带有回调的方法是 void 方法，但其他方法返回一个类型为`<T>`的对象列表，其中指定了相应的`RowMapper`、`ResultSetExtractor`或填充的`<T>`类型实例。 |

`JdbcTemplate`的超级功能背后是一组回调接口，作为上表所列方法的参数传递。这些执行挂钩有助于`JdbcTemplate`以纯粹面向对象和可重用的方式处理关系数据。充分理解这些接口对于正确使用`JdbcTemplate`至关重要。这些回调接口见下表：

<colgroup><col> <col> <col></colgroup> 
| 

回调接口

 | 

回调方法

 | 

责任

 |
| --- | --- | --- |
| `CallableStatementCreator` | `execute` | 构造`java.sql.CallableStatement`，用于在其`createCallableStatement(Connection)`方法中执行存储过程：。 |
| `PreparedStatementCreator` | `execute`、`update`、`query` | 在方法`createPreparedStatement (Connection)`内部构造给定连接的`java.sql.PreparedStatement,`。 |
| `PreparedStatementSetter` | `update`、`query` | 将值设置为执行前的`PreparedStatement`，在`JdbcTemplate.setValues (PreparedStatement)`内。 |
| `CallableStatementCallback` | `execute` | 准备`CallableStatement`。通常在实际执行之前，在`JdbcTemplate.doInCallableStatement(CallableStatement)`内设置存储过程或函数的`IN`和`OUT`参数。 |
| `PreparedStatementCallback` | `execute` | 用于`JdbcTemplate`执行`PreparedStatement`的编制方法。通常在实际执行之前，在`doInPreparedStatement(PreparedStatement)`方法中设置绑定参数：。 |
| `ResultSetExtractor` | `query` | 从`ResultSet`提取结果并返回一个域对象，在`extractData(ResultSet)`方法中：。 |
| `RowCallbackHandler` | `query` | 在`processRow(Resultset)`方法内以有状态的方式处理`ResultSet`的每一行，该方法不返回任何内容。 |
| `RowMapper` | `query` | 将`ResultSet`的每一行映射到`mapRow(Resultset, int rowNum)`方法内的域对象，返回创建的域对象。 |

现在让我们尝试一下`JdbcTemplate`的一些很好的现实用法。下面是使用`JdbcTemplate`执行计数查询的简单方法。

```
@Override
public int findAllOpenTasksCount() {
  return jdbcTemplate.queryForObject("select count(id) from tbl_user where status = ?", new Object[]{"Open"}, Integer.class);
}
```

您看到了这个简单的一行代码如何将您从所有样板和异常处理代码中解救出来，否则您将需要在典型的 JDBC 代码中编写这些代码吗？

下面的代码片段稍微复杂一些，说明了如何从表中查询唯一的行，并使用`RowMapper`将其映射到域对象（本例中为`User`）：

```
public User findByUserName(String userName) {
  return jdbcTemplate.queryForObject("SELECT ID, NAME, USER_NAME, PASSWORD, DOB, PROFILE_IMAGE_ID, PROFILE_IMAGE_NAME FROM TBL_USER WHERE USER_NAME = ?", new Object[] { userName }, 
    new RowMapper<User>() {
      @Override
      public User mapRow(ResultSet rs, int rowNum) throws SQLException {
        return new User(rs.getLong("ID"), 
        rs.getString("NAME"), 
        userName, 
        rs.getString("PASSWORD"), 
        rs.getDate("DOB"));
    }
  });
}
```

使用`JdbcTemplate`处理数据收集要容易得多。下面的代码片段演示了带绑定参数的`JdbcTemplate`查询方法和将`ResultSet`转换为类型列表的`<Task>`的`RowMapper`。

```
@Override
public List<Task> findCompletedTasksByAssignee(Long assigneeId) {
  String query = "SELECT * FROM TBL_TASK WHERE STATUS = ? AND 
  ASSIGNEE_USER_ID = ? ";

  return this.jdbcTemplate.query(query, new Object[] {"Complete", 
    assigneeId }, new RowMapper<Task>() {
    @Override
    public Task mapRow(ResultSet rs, int rowNum) throws SQLException{
      Task task = new Task();
      task.setId(rs.getLong("id"));
      Long assigneeId = rs.getLong("assignee_user_id");

      if (assigneeId != null)
        task.setAssignee(userDAO.findById(assigneeId));
      task.setComments(rs.getString("comments"));
      task.setName(rs.getString("name"));
      ...
      return task;
    }
  });
}
```

`JdbcTemplate`为您处理所有重复的代码，您只需要编写具体的代码，这是关于如何将一行的数据映射到您的域对象。

行映射的另一个变体是使用从`ResultSet`提取单行的`ResultSetExtractor`接口，如下代码所示：

```
@Transactional(readOnly = true)
public User findUserById(Long userId) {
  return jdbcTemplate.query("SELECT NAME, USER_NAME, PASSWORD, DOB, PROFILE_IMAGE_ID, PROFILE_IMAGE_NAME FROM TBL_USER WHERE ID = ?",
    new Object[] { userId }, new ResultSetExtractor<User>() {
    @Override
    public User extractData(ResultSet rs) throws SQLException, DataAccessException {
      if (rs.next()) {
        return new User(userId, rs.getString("NAME"), rs.getString("USER_NAME"), rs.getString("PASSWORD"), rs.getDate("DOB"));
      } else {
        return null;
      }
    }
  });
}
```

现在让我们来看看一些更新语句。下面是一个简单的`INSERT`语句作为一个线性代码的执行。SQL`UPDATE`和`DELETE`语句遵循相同的模式。

```
@Override
public void createUser(User user) {
  jdbcTemplate.update("INSERT INTO TBL_USER(NAME, USER_NAME, PASSWORD, DOB) VALUES(?,?,?,?)", new Object[] { user.getName(), user.getUserName(), user.getPassword(), user.getDateOfBirth()});
}
```

上述方法有一个缺点。尽管它将新的用户记录插入表中，但生成的 ID（可能是由数据库序列生成的）不会返回；您需要发出另一个查询来单独检索它。然而，`JdbcTemplate`提供了一个很好的方法来解决这个问题：使用`KeyHolder`类。这是`update`方法的另一个`variation`，在下面的代码中解释；您可以使用`KeyHolder`类结合`PreparedStatementCreator`在一次执行中检索生成的密钥（本例中为 ID）：

```
public void createUser(User user) {
  KeyHolder keyHolder = new GeneratedKeyHolder();
  jdbcTemplate.update( new PreparedStatementCreator() {
    public PreparedStatement createPreparedStatement(Connection connection) throws SQLException {
      PreparedStatement ps = connection.prepareStatement(
      "INSERT INTO TBL_USER(NAME,USER_NAME,PASSWORD,DOB) VALUES(?,?,?,?)", new String[]{"ID"});

        ps.setString(1, user.getName());
        ps.setString(2, user.getUserName());
        ps.setString(3, user.getPassword());
        ps.setDate(4, new java.sql.Date(user.getDateOfBirth().getTime()));
        return ps;
    }
  }, keyHolder);

  user.setId(keyHolder.getKey().longValue());
}
```

`JdbcTemplate`使批量更新变得容易，遵循与前面所示相同的模式。看看下面的代码：它在一组数据上执行一个`PreparedStatement`：

```
@Override
public void createUsers(List<User> users) {
    int[] updateCounts = jdbcTemplate.batchUpdate("INSERT INTO TBL_USER(NAME, USER_NAME, PASSWORD, DOB) VALUES(?,?,?,?)", new BatchPreparedStatementSetter() {
        public void setValues(PreparedStatement ps, int idx) throws SQLException {
            ps.setString(1, users.get(idx).getName());
            ps.setString(2, users.get(idx).getUserName());
            ps.setString(3, users.get(idx).getPassword());
            ps.setDate(4, new java.sql.Date(users.get(idx) .getDateOfBirth().getTime()));
        }

        public int getBatchSize() {
            return users.size();
        }
    });
}
```

### 命名参数 JDBCTemplate

到目前为止，我们已经使用`?`占位符将`JdbcTemplate`与绑定参数一起使用。当涉及到更多的参数时，命名参数是可读性和可维护性的更好选择。`NamedParameterJdbcTemplate`，`JdbcTemplate,`的专门版本支持使用命名参数，而不是传统的`?`占位符。`NamedParameterJdbcTemplate`使用基础`JdbcTemplate`进行操作，而不是从`JdbcTemplate`扩展。

您可以使用与经典`JdbcTemplate`相同的方式定义`NamedParameterJdbcTemplate`，将`DataSource`对象作为强制依赖项传递。然后，您可以像使用`JdbcTemplate`一样使用它，但是使用命名参数而不是绑定参数（`?`。下面的代码片段演示了使用`RowMapper`进行对象关系映射的`NamedParameterJdbcTemplate`查询方法的使用。

```
public User findByUserName(String userName, DataSource dataSource) {

  NamedParameterJdbcTemplate jdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
  SqlParameterSource namedParameters = new MapSqlParameterSource("USER_NAME", userName);

  return jdbcTemplate.queryForObject("SELECT ID, NAME, USER_NAME, PASSWORD, DOB, PROFILE_IMAGE_ID, PROFILE_IMAGE_NAME FROM TBL_USER WHERE USER_NAME = :USER_NAME", namedParameters, new RowMapper<User>() {

    @Override
    public User mapRow(ResultSet rs, int rowNum) throws SQLException {
      return new User(rs.getLong("ID"), rs.getString("NAME"), userName, rs.getString("PASSWORD"), rs.getDate("DOB"));
    }
  });
}
```

## SimpleJdbc 类

`SimpleJdbc`类是以更面向对象的方式访问数据的另一种好方法，但在内部仍然使用相同的`JdbcTemplate`。它们属于`org.springframework.jdbc.core.simple`包。其中有两类：

*   `SimpleJdbcCall`
*   `SimpleJdbcInsert`

`SimpleJdbcCall`处理对存储过程和函数的调用，`SimpleJdbcInsert`处理对数据库表的 SQL`INSERT`命令。两者都是`DatabaseMetadata`感知的，因此它们自动检测或映射域对象的类似命名字段。它们都充当围绕关系实体（分别是存储过程或函数和数据库表）执行 JDBC 操作的模板，接受一次（全局声明）确定操作行为的参数，然后在运行时使用动态数据集重复使用它。

`SimpleJdbcCall`类声明如下：

```
SimpleJdbcCall createTaskStoredProc = new SimpleJdbcCall(dataSource)
    .withFunctionName("CREATE_TASK")
    .withSchemaName("springessentials")
    .declareParameters(new SqlOutParameter("v_newID", Types.INTEGER),
        new SqlParameter("v_name", Types.VARCHAR), 
        new SqlParameter("v_STATUS", Types.VARCHAR),
        new SqlParameter("v_priority", Types.INTEGER),
        new SqlParameter("v_createdUserId", Types.INTEGER),
        new SqlParameter("v_createdDate", Types.DATE),
        new SqlParameter("v_assignedUserId", Types.INTEGER),
        new SqlParameter("v_comment", Types.VARCHAR));
```

前面的代码声明了`SimpleJdbcCall`，它调用一个存储过程（在 PostgreSQL 中，存储过程也称为函数）及其所有参数。一旦声明了它，就可以在运行时多次重用它。通常，您在类级别（DAO）声明它。以下代码说明了我们如何在运行时调用它：

```
@Override
public void createTask(Task task) {
    SqlParameterSource inParams = new 
        MapSqlParameterSource().addValue("v_name", task.getName())
        .addValue("v_STATUS", task.getStatus())
        .addValue("v_priority", task.getPriority())
        .addValue("v_createdUserId", task.getCreatedBy().getId())
        .addValue("v_createdDate", task.getCreatedDate())
        .addValue("v_assignedUserId", task.getAssignee() == null ?         null : task.getAssignee().getId())
        .addValue("v_comment", task.getComments());

    Map<String, Object> out = createTaskStoredProc.execute(inParams);
    task.setId(Long.valueOf(out.get("v_newID").toString()));
}
```

`SimpleJdbcInsert`通常声明如下代码所示：

```
SimpleJdbcInsert simpleInsert = new SimpleJdbcInsert(dataSource)
  .withTableName("tbl_user")
  .usingGeneratedKeyColumns("id");
```

注意下面代码段中表名旁边的生成键列的声明。同样，这通常是在类级别声明的，以便更好地重用。现在，看一下如何在运行时调用它。

```
public void createUser(User user) {
   Map<String, Object> parameters = new HashMap<>(4);
   parameters.put("name", user.getName());
   parameters.put("user_name", user.getUserName());
   parameters.put("password", user.getPassword());
   parameters.put("dob", user.getDateOfBirth());

   Number newId = simpleInsert.executeAndReturnKey(parameters);
   user.setId(newId.longValue());
}
```

您可以看到生成的密钥在执行后返回，设置回`User`对象。`SimpleJdbcCall`和`SimpleJdbcInsert`是香草`JdbcTemplate`的方便替代品；您可以始终如一地使用这些解决方案中的任何一种，也可以在同一应用中混合和匹配它们。

## 使用 Sql*类的 JDBC 操作

属于`org.springframework.jdbc.object`包的组类提供了另一种以更面向对象的方式执行 JDBC 操作的方法。下表列出了其中最常见的：

<colgroup><col> <col></colgroup> 
| 

组成部分

 | 

责任

 |
| --- | --- |
| `MappingSqlQuery` | SQL 查询的具体表示，支持`RowMapper`，有多种方便的`execute`和`find*`方法。也支持命名参数。 |
| `SqlUpdate` | 执行 SQL 更新（`INSERT`、`UPDATE`和`DELETE`操作，并支持命名参数和密钥持有者（用于检索生成的密钥）。 |
| `SqlCall` | 对存储过程和函数执行基于 SQL 的调用，并支持命名参数和密钥持有者（用于检索生成的密钥）。 |

以下代码说明了`MappingSqlQuery`的用法：

```
public Task findById(Long taskId) {
   MappingSqlQuery<Task> query = new MappingSqlQuery<Task>() {

      @Override
      protected Task mapRow(ResultSet rs, int rowNum) throws SQLException {
         return new RowMapper<Task>() {
            @Override
            public Task mapRow(ResultSet rs, int rowNum) throws SQLException {
               Task task = new Task();
               task.setId(rs.getLong("id"));
               ...
               return task;
            }
         }.mapRow(rs, rowNum);
      }
   };

   query.setJdbcTemplate(jdbcTemplate);
   query.setSql("select id, name, status, priority, created_user_id," + " created_date, assignee_user_id, completed_date, comments " + "from tbl_task where id = ?");
   query.declareParameter(new SqlParameter("id", Types.INTEGER));

   return query.findObject(taskId);
}
```

SQL 更新（`INSERT`、`UPDATE`和`DELETE`可以使用`SqlUpdate`和更具描述性的代码来执行，如下代码中的示例所示：

```
@Override
public void deleteTask(Task task) {
   SqlUpdate sqlUpdate = new SqlUpdate(this.jdbcTemplate.getDataSource(), "DELETE FROM TBL_TASK WHERE ID = ?");
   sqlUpdate.declareParameter(new SqlParameter("ID", Types.NUMERIC));
   sqlUpdate.compile();
   sqlUpdate.update(task.getId());
}
```

`SqlUpdate`提供多种方便的更新方式，适用于多种参数组合。您可以根据您的便利性和首选编程风格，混合和匹配前面列出的任何 Spring JDBC 组件。

# 弹簧数据

Spring 数据是 Spring 项目组合下的一个伞式项目，旨在跨多个不同的数据存储提供一致的数据访问，包括关系数据库和 NoSQL 数据库，以及其他类型的数据存储，如 REST（HTTP）、搜索引擎和 Hadoop。在 SpringData 下，每个特定方法和数据存储都有子项目，由这些技术的公司或开发人员组合在一起。Spring 数据大大简化了数据层的构建，而与底层数据库和持久化技术无关。

以下表列出了几个 Spring 数据子项目，并对每个子项目进行了简要说明：

<colgroup><col> <col></colgroup> 
| 

项目

 | 

描述

 |
| --- | --- |
| Spring 数据共享 | 包含一个核心 Spring 数据存储库规范和所有 Spring 数据项目的支持类。指定存储库、查询、审核和历史记录等概念。 |
| Spring 数据 JPA | 处理基于 JPA 的存储库。 |
| Spring 数据 MongoDB | 提供与 MongoDB 的轻松集成，包括对查询、条件和更新 DSL 的支持。 |
| Spring 数据 Redis | 与来自 Spring 应用的 Redis 内存数据结构存储集成。 |
| 弹簧数据解算器 | 提供与 ApacheSolr 的集成，ApacheSolr 是一个基于 ApacheLucene 的强大的开源搜索平台。 |
| Spring数据火灾 | 提供与 Pivotal Gemfire 的轻松集成，该数据管理平台提供实时数据访问、可靠的异步事件通知和有保障的消息传递。 |
| 弹簧数据键值 | 处理基于键值的数据存储。 |
| Spring 数据休息 | 使用 RESTAPI 公开存储库。 |

Spring 数据组合包含用于官方 Spring 数据项目未涵盖的更多数据存储的社区模块。几个非常流行的开源和专有数据库的社区正在为这些项目做出贡献，这使得 Spring Data 成为构建企业应用数据访问层的经验证解决方案的优秀来源，而不管底层数据存储是什么。Cassandra、Neo4J、Couchbase 和 ElasticSearch 是基于 Spring 数据的社区项目的一些例子。

## Spring 数据共享

Spring 数据通过称为 Spring Data Commons 的一致 API，通过其所有特定于存储的模块（子项目）标准化数据访问。SpringDataCommons 是所有 Spring 数据模块的基本规范和指南。所有 Spring 数据子项目都是 Spring 数据共享的存储特定实现。

Spring 数据共享定义了 Spring 数据模块的核心组件和一般行为。

*   Spring 数据存储库规范
*   查询派生方法
*   网络支持
*   审计

我们将在以下部分中检查这些组件中的每一个、它们的设置和用法。

## Spring 数据存储库规范

`org.springframework.data.repository.Repository`是 Spring 数据抽象的中央接口。这个标记接口是 Spring 数据共享的一部分，有两个专门的扩展，`CrudRepository`和`PagingAndSortingRepository`。

```
public interface CrudRepository<T, ID extends Serializable>
    extends Repository<T, ID> {
    ...
}
```

存储库管理域实体（设计为 POJO）。`CrudRepository`为 CRUD 提供实体的以下 CRUD 操作。

*   `save(One)`、`save(List)`
*   `find`、`findOne`、`findAll`
*   `delete`、`deleteAll`
*   `count`
*   `exists`

`PagingAndSortingRepository`在`CrudRepository`上增加分页和排序功能。它有以下两种方法：

*   `Page<T> findAll(Pageable)`
*   `Iterable<T> findAll(Sort)`

现在是时候开始讨论 Spring 数据的技术和存储特定模块了。我们将介绍 SpringDataJPA 和 SpringDataMongoDB，以说明数据库世界中两个完全不同的世界：关系和 NoSQL。当我们使用特定的实现时，我们使用特定于实现的存储库，但您的方法接口保持不变；因此，理论上，从一个特定的 Spring 数据实现切换到另一个不会影响您的客户机程序（服务、控制器或测试用例）。

### 弹簧数据 JPA

Spring 数据 JPA 是基于**JPA**（**Java 持久化架构**）的 Spring 数据实现，处理对象关系数据访问。对于开发人员来说，大多数编程都基于 SpringDataCommons 中描述的内容，而 SpringDataJPA 允许一些特定于关系 SQL 和 JPA 的额外定制。主要区别在于使用`@Query`注释的存储库设置和查询优化。

### 启用弹簧数据 JPA

在项目中启用 Spring 数据 JPA 是一个简单的两步过程：

1.  将`spring-data-jpa`依赖项添加到`maven/gradle`构建文件中。
2.  在 bean 配置中声明启用 JPA 存储库。

在 Maven 中，您可以添加一个`spring-data-jpa`依赖项，如下代码所示：

```
<dependency>
  <groupId>org.springframework.data</groupId>
  <artifactId>spring-data-jpa</artifactId>
  <version>${spring-data-jpa.version}</version>
</dependency>
```

如果使用 XML，可以启用 JPA 存储库，如下行所示：

```
  <jpa:repositories base-package="com.taskify.dao" />
```

在 Java 配置的情况下，只需添加注释即可启用 JPA 存储库。

```
@Configuration
@ComponentScan(basePackages = {"com.taskify"})
@EnableJpaRepositories(basePackages = "com.taskify.dao")
public class JpaConfiguration {
  ...
}
```

### J 假定的

在启用 JPA 存储库后，Spring 扫描给定包中带有`@Repository`注释的 Java 类，并创建功能齐全的代理对象以备使用。这些是 DAO，您只需定义方法，Spring 在运行时为您提供基于代理的实现。请参见一个简单的示例：

```
public interface TaskDAO extends JpaRepository<Task, Long>{

  List<Task> findByAssigneeId(Long assigneeId);

  List<Task> findByAssigneeUserName(String userName);
}
```

Spring 生成智能实现，在代理实现中实际执行这些方法所需的数据库操作，查看方法名称和参数。

## 弹簧数据 MongoDB

MongoDB 是最流行的面向文档的 NoSQL 数据库之一。它以**BSON**（**二进制 JSON**格式）存储数据，允许以嵌套的结构存储整个复杂对象，避免了将数据拆分为大量关系表的需要。它的嵌套对象结构直接映射到面向对象的数据结构，并且消除了任何对象关系映射的需要，JPA/Hibernate 就是这样。

Spring Data MongoDB 是 MongoDB 的 Spring 数据模块。它允许 Java 对象直接映射到 MongoDB 文档中。它还为连接 MongoDB 和操作其文档集合提供了全面的 API 和基础设施支持。

### 启用弹簧数据 MongoDB

Spring 数据 MongoDB 可以通过以下步骤启用：

1.  将`spring-data-mongodb`添加到构建文件（`maven/gradle`中）。
2.  在 Spring 元数据配置中注册 Mongo 实例。
3.  在 Spring 元数据中添加一个`mongoTemplate`Springbean。

使用 Maven 添加`spring-data-mongodb`依赖项应该如下所示：

```
<dependency>
  <groupId>org.springframework</groupId>
  <artifactId>spring-aop</artifactId>
  <version>${spring.framework.version}</version>
</dependency>
```

您可以在 XML 元数据中注册 Mongo 实例，如下行所示：

```
<mongo:mongo host="192.168.36.10" port="27017" />
```

此 Mongo 实例是服务器上运行的实际 MongoDB 实例的代理。

一个简单的`mongoTemplate`看起来像下面代码中给出的清单：

```
<bean id="mongoTemplate" class="org.springframework.data.mongodb.core.MongoTemplate">
  <constructor-arg ref="mongo" />
  <constructor-arg name="databaseName" value="Taskify" />
</bean>
```

### Mongore 假设

MongoRepository 是 Spring 数据 MongoDB 的 MongoDB 特定存储库。它看起来与`JpaRepository`非常相似。请看一个样本`MongoRepository`类：

```
public interface TaskDAO extends MongoRepository<Task, String>{

  List<Task> findByAssigneeId(String assigneeId);

  @Query("{ 'status' : 'Complete' }")
  List<Task> findCompletedTasks();

  @Query(value = "{ 'status' : 'Open', assignee.id: ?0 }")
  List<Task> findOpenTasksByAssigneeId(String assigneeId);
  ...
}
```

## 域对象和实体

数据驱动的应用通常将域对象设计为实体，然后在运行时将它们作为关系表或键值对的文档结构持久化到数据库中。Spring 数据与任何其他持久化框架一样处理域实体。为了说明存储库的用法，我们将参考以下三个相关实体，它们在您的程序中被设计为**普通旧 Java 对象**（**POJO**）。

![Domain objects and entities](img/image00787.jpeg)

以下是 Java 表示。第一个是为 JPA 注释的，另外两个是为 MongoDB 注释的。JPA 实体以`@Entity`注释。列映射到每个字段。请记住，您也可以对 JPA 实体使用基于 XML 的映射，而不是注释。XML 映射提供了几个好处，包括集中控制和可维护性。为了简单起见，本例使用注释，假设读者已经熟悉 JPA 或 Hibernate 映射。

```
@Entity
@Table(name = "TBL_USER", uniqueConstraints = @UniqueConstraint(name = "UK_USER_USERNAME", columnNames = {"USER_NAME" }) )
public class User {

  @Id
  @SequenceGenerator(name = "SEQ_USER", sequenceName = "SEQ_USER", allocationSize = 1, initialValue=1001)
  @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "SEQ_USER")
  private Long id;

  @Column(name = "NAME", length = 200)
  private String name;

  @Column(name = "USER_NAME", length = 25)
  private String userName;

  @Column(name = "PASSWORD", length = 20)
  private String password;

  @Column(name = "DOB")
  @Temporal(TemporalType.TIMESTAMP)
  private Date dateOfBirth;

  @ManyToOne(optional = true)
  @JoinColumn(name = "FILE_ID", referencedColumnName = "ID")
  private File profileImage;

  public User() {}

  public User(Long id, String name, String userName, String password, Date dateOfBirth) {
    super();
    this.id = id;
    this.name = name;
    this.userName = userName;
    this.password = password;
    this.dateOfBirth = dateOfBirth;
  }

  public Long getId() {
    return id;
  }
  ...
}
```

下面的是任务实体，注释为 MongoDB 文档。Mongo 实体用`@Document`注释。它需要一个 ID 字段，可以用`@Id`注释，也可以用名称`id`注释。

```
@Document(collection = "tasks")
public class Task {

  @Idprivate String id;
  private String name;
  private int priority;
  private String status;
  private User createdBy;
  private Date createdDate;
  private User assignee;
  private Date completedDate;
  private String comments;

  public Task() {}
  ...
}
```

文件实体被注释为 JPA 实体。

```
@Entity
@Table(name = "TBL_FILE")
public class File {

  @Id
  @SequenceGenerator(name = "SEQ_FILE", sequenceName = "SEQ_FILE", allocationSize = 1)
  @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "SEQ_FILE")
  private Long id;

  @Column(name = "FILE_NAME", length = 200)
  private String fileName;
  ...
}
```

### 查询解析方法

在中，除了接口级的声明查询（`find`、`count`、`delete`、`remove`、`exists`方法外，`CrudRepository`还支持使用任何名称的`@Query`注释方法进行声明查询，这有助于从**SpEL**（**Spring 表达式语言）派生出实际的 SQL 查询**表达式作为参数给出，在这两个查询派生选项中，Spring 数据采用基于以下查询查找策略的查询派生选项：

<colgroup><col> <col></colgroup> 
| 

查询查找策略

 | 

描述

 |
| --- | --- |
| `CREATE` | 从方法名称生成特定于模块的查询。 |
| `USE_DECLARED_QUERY` | 使用注释或其他方式声明的查询。 |
| `CREATE_IF_NOT_FOUND` | 这一策略结合了前两种策略。这是默认策略。 |

查询查找策略通常在启用 JPA 存储库时设置。

```
<jpa:repositories base-package="com.taskify.dao" query-lookup-strategy="create-if-not-found"/>
```

查询生成策略（`CREATE`以嵌套的方式围绕实体的属性（包括它们的依赖项）工作。作为一名开发人员，您可以根据可以由 Spring 数据解释和实现的特定格式定义方法名称。查询方法的总体结构如下所示：

`[return Type] [queryType][limitKeyword]By[criteria][OrderBy][sortDirection]`

*   `return type`可以是实体`<T>`本身（在唯一结果的情况下）、列表`<T>`、流`<T>`、页面`<T>`、原语编号、Java 包装类型、void、future`<T>`、`CompletableFuture<T>`、`ListenableFuture<T>`等。最后三个用于 Spring 的异步方法执行，应该用`@Async`注释。
*   `queryType`可以是`find`、`read`、`query`、`count`、`exists`、`delete`等。
*   `limitKeyword`支持`distinct`、`First[resultSize]`和`Top[resultSize]`。一个例子是`First5`。
*   `criteria`是通过将一个或多个属性表达式（使用驼峰大小写）与标准运算符（如`Or`、`And`、`Between`、`GreaterThan`、`LessThan`、`IsNull`、`StartsWith`、`Exists`组合而成。标准的后缀可以是`IgnoreCase`或`AllIgnoreCase`，以应用案例不敏感。
*   `OrderBy`按原样使用，以属性表达式作为后缀。
*   `sortDirection`可以是`Asc`或`Desc`中的任意一个。仅与`OrderBy`一起使用。

为了更清楚，让我们看一些例子。下面的示例代码说明了如何构造查询（或删除）方法，以便 Spring 数据可以在运行时生成实际的 SQL 查询。

```
public interface UserDAO extends JpaRepository<User, Long> {

  // Returns unique user with given user-name
  User findByUserName(String userName);

  // Returns a paginated list of users whose name starts with // given value
  Page<User> findByNameStartsWith(String name, Pageable pageable);

  // Returns first 5 users whose name starts with given value, 
  // order by name descending
  List<User> findTop5ByNameStartsWithOrderByNameDesc(String name);

  // Returns number of users whose birth date is before the given // value
  Long countUsersDateOfBirthLessThan(Date dob);

  // Deletes the User of given id
  void deleteById(Long userId);

  // Asynchronously returns a list of users whose name contains // the given value
  @Async
  Future<List<User>> findByNameContains(String name);
}
```

前面的示例显示了`JpaRepository`和`MongoRepository`的工作方式相同；您只需要从它扩展，而不需要更改方法签名。您已经看到约束查询和筛选方法遍历实体的根级属性，并适当地组合运算符。除了根级属性外，还可以通过嵌套属性遍历和过滤，以定义查询约束，换句话说，就是限制结果。请看以下示例：

```
public interface TaskDAO extends MongoRepository<Task, String>{

  List<Task> findByAssigneeId(Long assigneeId);

  List<Task> findByAssigneeUserName(String userName);
}
```

上例中列出的方法正在遍历任务实体的嵌套属性：

*   `findByAssigneeId = task.assignee.id`
*   `findByAssigneeUserName = task.assignee.userName`

您可以遍历实体的任何级别的嵌套元素，具体取决于实体和需求的复杂程度。

### 使用@Query 注释

除了如前一节所示，基于方法名自动生成查询之外，Spring 数据还允许您在本地直接在存储库中通过方法名声明实体查询。使用 SpEL 声明查询，Spring 数据在运行时解释查询，并（代理存储库）为您生成查询。这是查询解析策略的一个实现：`USE_DECLARED_QUERY`。

让我们来看看一些自我说明的例子：

```
public interface TaskDAO extends JpaRepository<Task, Long>{	

  @Query("select t from Task t where status = 'Open'")
  List<Task> findOpenTasks();

  @Query("select t from Task t where status = 'Complete'")
  List<Task> findCompletedTasks();

  @Query("select count(t) from Task t where status = 'Open'")
  int findAllOpenTasksCount();

  @Query("select count(t) from Task t where status = 'Complete'")
  int findAllCompletedTasksCount();

  @Query("select t from Task t where status = 'Open' and assignee.id = ?1")
  List<Task> findOpenTasksByAssigneeId(Long assigneeId);

  @Query("select t from Task t where status = 'Open' and assignee.userName = ?1")
  List<Task> findOpenTasksByAssigneeUserName(String userName);

  @Query("select t from Task t where status = 'Complete' and assignee.id = ?1")
  List<Task> findCompletedTasksByAssigneeId(Long assigneeId);

  @Query("select t from Task t where status = 'Complete' and assignee.userName = ?1")
  List<Task> findCompletedTasksByAssigneeUserName(String userName);
}
```

您可以从前面的示例中看到，我们可以遍历到嵌套属性中，以约束其中的条件部分中的查询。您还可以在同一个存储库中同时使用两种查询生成策略（`CREATE`和`USE_DECLARED_QUERY`。

前面的示例基于 Spring 数据 JPA；Spring 数据 MongoDB 等价物在以下代码中给出。您可以看到与 MongoDB 结构相比，`@Query`注释值是如何不同的。

```
public interface TaskDAO extends MongoRepository<Task, String>{

  @Query("{ 'status' : 'Open' }")
  List<Task> findOpenTasks();

  @Query("{ 'status' : 'Complete' }")
  List<Task> findCompletedTasks();

  @Query(value = "{ 'status' : 'Open' }", count = true)
  int findAllOpenTasksCount();

  @Query(value = "{ 'status' : 'Complete' }", count = true)
  int findAllCompletedTasksCount();

  @Query(value = "{ 'status' : 'Open', assignee.id: ?0 }")
  List<Task> findOpenTasksByAssigneeId(String assigneeId);

  @Query(value = "{ 'status' : 'Open', assignee.userName: ?0 }")
  List<Task> findOpenTasksByAssigneeUserName(String userName);

  @Query(value = "{ 'status' : 'Complete', assignee.id: ?0 }")
  List<Task> findCompletedTasksByAssigneeId(String assigneeId);

  @Query(value = "{ 'status' : 'Open', assignee.userName: ?0 }")
  List<Task> findCompletedTasksByAssigneeUserName(String userName);
}
```

### Spring 数据 web 支持扩展

SpringData 为 SpringMVC 应用提供了一个名为`SpringDataWebSupport`的智能扩展，如果您启用它，它将自动集成一些生产力组件。如果您使用 Spring 数据存储库编程模型进行数据访问，它主要使用请求映射控制器方法直接从请求参数解析域实体，如`Pageable`和`Sort`实例。

在使用这些功能之前，您需要为您的项目启用`SpringDataWebSupport`。如果您使用的是 Java 配置，则可以注释`@EnableSpringDataWebSupport`，如下代码所示：

```
@Configuration
@EnableWebMvc
@ComponentScan(basePackages = {"com.taskify"})
@EnableSpringDataWebSupport
@EnableJpaRepositories(basePackages = "com.taskify.dao")
public class ApplicationConfiguration {
 ...
}
```

对于 XML 元数据，您可以将`SpringDataWebConfiguration`注册为 Springbean，如下代码所示：

```
<bean class="org.springframework.data.web.config.SpringDataWebConfiguration" />
```

设置`SpringDataWebSupport`后，可以开始使用 Spring 数据实体作为请求映射方法的请求参数，如下代码所示：

```
@RestController
@RequestMapping("/api/v1/user")
@CrossOrigin
public class UserController {

  @RequestMapping(path = "/{id}", method = RequestMethod.GET)
  public User getUser(@PathVariable("id") User user) {
    return user;
  }
  ...
}
```

在前面的方法中，您可以看到 Spring 数据使用`UserRepository`透明地加载`User`实体数据。类似地，您可以接受针对 JSON 或 XML post 请求的`Pageable`和`Sort`实例。明智地使用`SpringDataWebSupport`扩展使您的代码更干净、更易于维护。

### 使用弹簧数据进行审计

跟踪数据修改是严肃业务应用的一项关键功能。管理员和经理急于知道何时以及谁更改了保存在数据库中的某些业务信息。Spring 数据为透明地审核数据实体提供了智能而简单的方法。Spring Data 提供了以下有意义的注释，用于捕获系统中修改的用户和时间数据实体：

<colgroup><col> <col></colgroup> 
| 

注释

 | 

期望类型

 |
| --- | --- |
| `@CreatedBy` | 创建实体的主要用户。通常，它是表示域用户的另一个实体。 |
| `@CreatedDate` | 实体创建时记录。支持的类型：`java.util.Date`、日历、JDK 8 日期/时间类型、`Joda DateTime`。 |
| `@LastModifiedBy` | 上次更新实体的用户主体。与`@CreatedBy`类型相同。 |
| `@LastModifiedDate` | 记录实体上次更新的时间。支持的类型与`@CreatedDate`相同。 |

典型的 JPA 实体应类似于以下代码：

```
@Entity
@Table(name = "tbl_task")
public class Task {

  @Id
  private Long id;
  ...
  @ManyToOne(optional = true)
  @JoinColumn(name = "CREATED_USER_ID", referencedColumnName = "ID")
  @CreatedBy
  private User createdBy;

  @Column(name = "CREATED_DATE")
  @Temporal(TemporalType.TIMESTAMP)
  @CreatedDate
  private Date createdDate;

  @ManyToOne(optional = true)
  @JoinColumn(name = "MODIFIED_USER_ID", referencedColumnName = "ID")
  @LastModifiedBy
  private User modifiedBy;

  @Column(name = "MODIFIED_DATE")
  @Temporal(TemporalType.TIMESTAMP)
  @LastModifiedDate
  private Date modifiedDate;
  ...
}
```

如果您使用 XML 而不是注释来映射实体，那么您可以实现一个可审计接口，强制您实现审计元数据字段，或者扩展`AbstractAuditable`，Spring Data 提供的一个方便的基类。

由于您正在记录创建和修改实体的用户的信息，因此需要帮助 Spring Data 从上下文中捕获该用户信息。您需要注册一个实现`AuditAware<T>`的 bean，其中`T`与您用`@CreatedBy`和`@LastModifiedBy`注释的字段类型相同。请看以下示例：

```
@Component
public class SpringDataAuditHelper implements AuditorAware<User> {

  ...
  @Override
  public User getCurrentAuditor() {
    // Return the current user from the context somehow.
  }

}
```

如果您使用 Spring Security 进行身份验证，`getCurrentAuditor`方法应该从`SecurityContextHolder`类获取并返回用户，如下所示：

```
@Component
public class SpringDataAuditHelper implements AuditorAware<User> {

  ...
  @Override
  public User getCurrentAuditor() {
    Authentication authentication = SecurityContextHolder.getContext().getAuthentication();

    if (authentication == null || !authentication.isAuthenticated()) {
      return null;
    }
    return ((User) authentication.getPrincipal()).getUser();
  }
}
```

现在您的审计基础设施已经就绪，您在可审计实体中所做的任何修改都将被 Spring 数据透明地跟踪。

到目前为止，您已经掌握了强大的 Spring 数据，并且知道如何使用 Spring 数据存储库创建优雅、干净但真正强大的数据访问层，因此现在是时候考虑如何确保应用的数据完整性和可靠性了。Spring 事务是答案；让我们在下一节中探讨它。

# Spring 事务支持

数据驱动的 To.T0.企业系统认为数据完整性是首要的，因此事务管理是主要数据库和应用服务器支持的关键特性。Spring 框架提供全面的事务支持，抽象任何底层基础设施。Spring 事务支持包括跨不同事务选择（如 JTA、JPA 和 JDO）的一致方法。它与所有 Spring 数据访问机制集成良好。Spring 事务支持声明式和编程式事务管理。

### 注

**事务**可以定义为数据交换的原子单元，在关系数据库中通常是 SQL 语句，应该作为块提交或回滚（全部或无）。事务系统或事务管理框架跨参与系统或资源（如数据库和消息队列）强制执行**ACID**（**原子**、**一致**、**隔离**、**持久**属性。

# Spring 交易的相关性

企业 Java 应用服务器本机提供**JTA**（**Java 事务 API**支持，支持分布式事务，即全局事务，跨越多个资源、应用和服务器。传统上，**企业 Java Beans**（**EJB**和**消息驱动 Beans**（**MDB**）被用于**容器管理事务**（**CMT**），而是基于 JTA 和 JNDI 的。JTA 事务管理是资源密集型的；它的异常处理基于已检查的异常，因此对开发人员不友好。此外，使用 EJBCMT 进行单元测试很困难。

对于那些不想使用资源密集型 JTA 事务的人，本地事务是另一个可用的选项，它允许您使用 API（如 JDBC）以编程方式强制执行特定于资源的事务。虽然相对容易使用，但它仅限于单个资源，因为多个资源不能参与单个事务。此外，本地事务通常具有入侵性，因此它们会污染代码。

Spring 事务抽象通过提供可在任何环境中运行的一致事务模型，解决了全局和本地事务的问题。尽管它同时支持声明式和编程式事务管理，但声明式模型对于大多数情况来说已经足够了。SpringTransaction 消除了仅用于事务的 JBoss 或 WebLogic 等应用服务器的需要。您可以在一个简单的 Servlet 引擎（如 Tomcat）上使用 Spring 开始本地事务，然后将其扩展到应用服务器上的分布式事务，而无需涉及业务代码，只需更改 Spring 元数据中的事务管理器。

大多数应用只需要本地事务，因为它们不处理多个服务器或事务资源，如数据库、JMS 和 JCA；因此，他们不需要一个成熟的应用服务器。对于通过远程调用跨越多个服务器的分布式事务，您需要 JTA，这就需要应用服务器，因为 JTA 需要 JNDI 来查找数据源。JNDI 通常仅在应用服务器中可用。使用`JTATransactionManager`内部应用服务器实现 JTA 功能。

### 注

在应用服务器中部署 Spring 应用时，可以使用特定于服务器的事务管理器来利用其全部功能。只需切换事务管理器，在 Spring 元数据中使用特定于服务器的`JtaTransactionManager`实现，如`WebLogicJTATransactionManager`和`WebSphereUowTransactionManager`。你所有的代码现在都是完全可移植的。

## Spring 交易基础

Spring 事务管理抽象是围绕名为`PlatformTransactionManager`的接口设计的，您需要在 Spring 元数据中将其配置为 Springbean。`PlatformTransactionManager`基于定义事务策略的`TransactionDefinition`实例，管理执行提交、回滚等事务操作的实际事务实例。`TransactionDefinition`定义关键事务属性，如隔离、传播、事务超时以及给定事务实例的只读状态。

### 注

事务属性确定事务实例的行为。它们既可以通过编程方式设置，也可以通过声明方式设置。事务属性包括：

**隔离级别**：定义一个事务与（可以看到）并行运行的其他事务隔离的程度。有效值为：`None`、`Read committed`、`Read uncommitted`、`Repeatable reads`和`Serializable`。`Read committed`无法看到来自其他事务的脏读取。

**传播**：确定一个数据库操作相对于其自身之前、之后和内部嵌套的其他操作的事务范围。有效值为：`REQUIRED`、`REQUIRES_NEW`、`NESTED`、`MANDATORY`、`SUPPORTS`、`NOT_SUPPORTED`和`NEVER`。

**超时**：事务在完成前可以保持运行或等待的最长时间段。一旦超时，它将自动回滚。

**只读状态**：在此模式下读取的数据不能保存。

这些事务属性并不特定于 Spring，而是反映了标准的事务概念。`TransactionDefinition`接口在 Spring 事务管理上下文中指定这些属性。

根据您的环境（单机版、web/app 服务器）和您使用的持久化机制（如普通 JDBC、JPA 和 Hibernate），您可以选择`PlatformTransactionManager`的适当实现，并根据需要在 Spring 元数据中进行配置。在引擎盖下，Spring 使用 Spring AOP 将`TransactionManager`注入代理 DAO（或者 JPA 中的`EntityManager`，并执行事务方法，应用 Spring 配置中声明的事务语义，使用`@Transactional`注释或等效的 XML 注释。我们将在本章后面讨论`@Transactional`注释及其 XML 等价物。

对于在单个`DataSource`对象上运行的应用，Spring 提供`DataSourceTransactionManager`。下面显示了如何在 XML 中配置它：

```
<bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
  <property name="dataSource" ref="taskifyDS" />
</bean>
```

对于多个`DataSource`对象或事务资源，您需要一个具有 JTA 功能的`JtaTransactionManager`，它通常委托给容器 JTA 提供者。您需要在 JavaEE 应用服务器中使用`DataSource`对象，该对象由服务器定义，并通过 JNDI 与`JtaTransactionManager`一起查找。典型的组合应类似于以下代码片段：

```
<bean id="txManager" class="org.springframework.transaction.jta.JtaTransactionManager" />
</bean>
<jee:jndi-lookup id="taskifyDS" jndi-name="java:jboss/datasources/taskify" expected-type="javax.sql.DataSource/>
```

如果您使用的是 Hibernate，并且只有一个`DataSource`（没有其他事务性资源），那么最好的选择是使用`HibernateTransactionManager`，这要求您将会话工厂作为依赖项传递。对于 JPA，Spring 提供了`JpaTransactionManager`，绑定一个 JPA`EntityManager`实例。但是，建议在应用容器环境中使用`JtaTransactionManager`。

Spring 为 WebLogic 和 WebSphere 的应用服务器提供了专门的事务管理器，以便充分利用特定于容器的事务协调器。在各自的环境中使用`WebLogicTransactionManager`和`WebsphereUowTransactionManager`。

## 声明式事务管理

将业务代码中的事务语义分离到方法上方的 XML 文件或注释中通常称为**声明性事务管理**。Spring 框架允许您使用其声明性事务管理特性，以透明和非侵入的方式将事务行为应用到 bean 中。

与 EJBCMT 不同，您可以在任何 Springbean 上声明性地应用 Spring 事务。使用 SpringTransaction，您可以在元数据中以 AOP 样式指定 bean 方法周围的事务性建议；然后 Spring 将在运行时使用 AOP 应用这些建议。您可以设置回滚规则来指定哪些 bean 或方法导致自动回滚或非回滚的异常。

### 事务模式–代理和 AspectJ

Spring 事务支持两种事务模式：代理模式和 AspectJ 模式。代理是默认和最流行的模式。在代理模式下，Spring 创建一个 AOP 代理对象，包装事务 bean，并使用基于元数据的事务方面透明地应用方法周围的事务行为。Spring 基于事务元数据创建的 AOP 代理，在配置的`PlatformTransactionManager`的帮助下，围绕事务方法执行事务。

如果为事务选择 AspectJ 模式，则事务方面将围绕指定的方法编织到 bean 中，在编译时修改目标类字节码。在这种情况下，将没有代理。在特殊情况下，例如调用具有不同传播级别的同一类的事务方法时，需要 AspectJ 模式，而代理则没有帮助。

### 定义交易行为

Spring 提供了两种方便的方法来声明性地定义 bean 的事务行为：

*   XML 元数据文件中事务的 AOP 配置
*   使用`@Transactional`注释

让我们从 XML 文件中的 AOP 配置开始。请参阅[第一章](01.html#aid-BE6O1 "Chapter 1. Getting Started with Spring Core")*Spring Core 入门*中的*面向方面编程*一节，详细讨论配置 AOP、使用方面、切入点、建议等。

通常，在 XML 元数据文件中使用切入点表达式声明事务通知和切入点。最好的方法是将事务配置保存在单独的 bean 定义文件（例如，`transation-settings.xml`）中，并将其导入主应用上下文文件中。

通常，您声明事务通知和其他语义，如以下代码所示：

```
<!-- transactional advices --> 
<tx:advice id="txAdvice" transaction-manager="transactionManager">
  <!-- the transactional semantics... -->
  <tx:attributes>
    <!-- all methods starting with 'get' are read-only -->
    <tx:method name="find*" read-only="true" />
    <!-- other methods use the default transaction settings (see below) -->
    <tx:method name="*" isolation="DEFAULT" propagation="REQUIRED" />
  </tx:attributes>
</tx:advice>

<!-- Applying the above advices to the service layer methods -->
<aop:config>
  <aop:pointcut id="allServiceMethods"
  expression="execution(* com.taskify.service.*.*(..))" />
  <aop:advisor advice-ref="txAdvice" pointcut- ref="allServiceMethods" />
</aop:config>
```

您可以看到，此 AOP 配置指示 Spring 如何使用切入点围绕方法编织事务性建议。指示`TransactionManager`将整个服务层的所有 find 方法设置为只读，并强制其他方法进行事务传播：`REQUIRED`，这意味着，如果该方法的调用方已经在事务上下文中，则该方法加入相同的事务，而不创建新的事务；否则，将创建一个新事务。如果要为此方法创建不同的事务，应使用`REQUIRES_NEW`传播。

另外，请注意，事务隔离级别指定为`DEFAULT`，这意味着将使用数据库的默认隔离。大多数数据库默认为`READ_COMMITTED`，这意味着事务线程无法看到进程中其他事务的数据（脏读）。

### 设置回滚规则

使用 Spring 事务，您可以在同一`<tx:advice>`块中以声明方式设置回滚规则，如下代码所示：

```
<tx:advice id="txAdvice" transaction-manager="transactionManager">
  <tx:attributes>
    ...
    <tx:method name="completeTask" propagation="REQUIRED" rollback-for="NoTaskFoundException"/>
    <tx:method name="findOpenTasksByAssignee" read-only="true" no-rollback-for="InvalidUserException"/>
    <tx:method name="*" isolation="DEFAULT" propagation="REQUIRED" />
  </tx:attributes>
</tx:advice>
```

您可以使用`<tx:method>`元素的`rollback-for`和`no-rollback-for`属性指定哪些异常应该或不应该回滚业务操作的事务。

### 注

`PlatformTransactionManager`接口的方法抛出的`TransactionException`是未检查的异常`RuntimeException`。在 Spring 中，事务会自动回滚未检查的异常。选中，或者除非在元数据中使用`rollback-for`属性指定，否则不会回滚应用异常。

Spring 事务允许您使用 Spring AOP 和 SpEL 将 bean 的事务行为定制到最小的粒度级别。此外，您可以在`<tx:method>`元素的方法级别上指定事务的行为属性，例如传播、隔离和超时。

## 使用@Transactional 注释

`@Transactional`注释描述方法或类上的事务属性。类级注释适用于所有方法，除非在方法级显式注释。它支持在 XML 配置中以其他方式设置的所有属性。请参见以下示例：

```
@Service
@Transactional
public class TaskServiceImpl implements TaskService {
  ...
  public Task createTask(Task task) {
    if (StringUtils.isEmpty(task.getStatus()))
      task.setStatus("Open");
    taskDAO.save(task);
    return task;
  }

  @Transactional(propagation = Propagation.REQUIRED, rollbackFor = NoUserFoundException)
  public Task createTask(String name, int priority, Long createdByuserId, Long assigneeUserId, String comments) {
    Task task = new Task(name, priority, "Open", userService.findById(createdByuserId), null, userService.findById(assigneeUserId), comments);
    taskDAO.save(task);
    logger.info("Task created: " + task);
    return task;
  }

  @Transactional(readOnly = true)
  public Task findTaskById(Long taskId) {
    return taskDAO.findOne(taskId);
  }
  ...
}
```

在上例中，具有传播`REQUIRED`的事务方法`createTask`回滚`NoUserFoundException`。同样，您也可以在同一级别上不设置回滚规则。

### 注

`@Transactional`只能应用于公共方法。如果要注释受保护的、私有的或包可见的方法，请考虑使用使用编译时方面编织的 AspectJ。Spring 建议只在具体类上注释`@Transactional`，而不是在接口上，因为它在大多数情况下都不起作用，比如在使用`proxy-target-class="true"`或`mode="aspectj"`时。

### 为@Transactional 启用事务管理

您需要首先在应用中启用事务管理，Spring 才能检测到 bean 方法的`@Transactional`注释。您可以使用以下符号在 XML 元数据中启用事务：

```
<tx:annotation-driven transaction-manager="transactionManager" />
```

以下是前一清单的 Java 配置备选方案：

```
@Configuration
@EnableTransactionManagement
public class JpaConfiguration {
}
```

当 Spring 看到前面的任何一个设置时，它会扫描应用上下文，寻找带`@Transactional`注释的 bean 方法。

您可以在此级别将交易模式从默认的`proxy`更改为`aspectj`：

```
<tx:annotation-driven transaction-manager="transactionManager" mode="aspectj"/>
```

您可以在该级别设置的另一个属性是`proxy-target-class`，该属性仅适用于`proxy`模式下的。

## 程序化事务管理

Spring 使用两个组件`TransactionTemplate`和`PlatformTransactionManager`为编程事务管理提供全面支持。下面的代码片段说明了`TransactionTemplate`的用法：

```
@Service
public class TaskServiceImpl implements TaskService {
  @Autowired
  private TransactionTemplate trxTemplate;
  ...
  public Task createTask(String name, int priority, Long createdByuserId, Long assigneeUserId, String comments) {

    return trxTemplate.execute(new TransactionCallback<Task>() {
      @Override
      public Task doInTransaction(TransactionStatus status) {
        User createdUser = userService.findById(createdByuserId);
        User assignee = userService.findById(assigneeUserId);
        Task task = new Task(name, priority, "Open", createdUser, null, assignee, comments);
        taskDAO.save(task);
        logger.info("Task created: " + task);
        return task;
      }
    });
  }
}
```

`TransactionTemplate`支持所有事务属性的设置，就像 XML 配置一样，这使您可以更精确地控制事务，但代价是将业务代码与事务关注点混合在一起。仅当您需要对声明性事务管理无法实现的特定功能进行绝对控制时，才使用它。如果可能，请使用声明性事务管理，以便更好地维护和管理应用。

# 总结

到目前为止，我们已经探索了 Spring 框架对数据访问和事务的所有技术方面的全面覆盖。Spring 提供了多种方便的数据访问方法，这消除了开发人员在构建数据层和标准化业务组件方面的许多繁重工作。Spring 数据访问组件的正确使用使 Spring 应用的数据层干净且高度可维护。利用 Spring 事务支持可确保应用的数据完整性，而不会污染业务代码，并使您的应用能够跨不同的服务器环境进行移植。由于 Spring 抽象了许多技术重担，因此构建应用的数据层成为软件工程中令人愉快的一部分。