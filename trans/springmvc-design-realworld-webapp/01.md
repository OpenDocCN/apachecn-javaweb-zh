# 第一章弹簧芯入门

Spring 框架是企业 Java 中最受信任、应用最广泛的应用程序开发框架。Spring 最初是作为复杂 J2EE 的一种简单而轻量级的替代方案引入的，现在已经发展成为一个真正的现代应用程序开发平台。Spring 及其子项目为端到端应用程序开发提供了极好的基础，除了最新的 JavaEE 之外，除了移动 java 开发、社交网络和大数据之外，除了传统的 java Web、服务器端，甚至是独立的应用程序之外，它们的功能都是非常出色的。Spring 成立十多年后，继续激励着全球的技术和技术专家。

尽管 Spring 极大地简化了 Java 开发，但软件开发人员和架构师仍然需要对其核心概念和特性有透彻的理解，以便更好地利用 Spring 系列。Spring 为复杂 Java 开发提供的简单性是它以优秀 API 和模块的形式提供的智能抽象的结果。Spring 组件减轻了开发人员的所有技术复杂性和常见技术和基础设施管道任务的繁重负担。正如 Spring 官方文档所说，Spring 提供了全面的基础设施支持，因此您可以专注于应用程序。

这本书试图让你的春季学习变得更容易，更愉快。

本章为您提供了核心 Spring 框架的坚实基础，引导您通过其核心概念、组件和模块，伴随着相关的示例代码片段，说明了每个功能的最佳和最实用的用法，以解决日常编程问题。

在本章中，我们将介绍以下主题：

*   春天的风景
*   建立发展环境
*   您的第一个 Spring 应用程序
*   核心概念
*   IoC（控制反转）容器
*   细枝末节
*   使用 bean 定义概要文件
*   处理资源
*   SpEL（Spring 表达式语言）
*   面向方面编程

# 春天的风景

Spring 涵盖了由不同类型的应用程序处理的各种技术方面，从简单的独立 Java 应用程序到您可以想象的最复杂、关键任务的分布式企业系统。与大多数其他专注于特定技术问题（如 Web、消息传递或远程处理）的开源或专有框架不同，Spring 成功地涵盖了业务应用程序的几乎所有技术方面。在大多数情况下，Spring 利用并集成经验证的现有框架来实现端到端覆盖，而不是重新设计解决方案。弹簧高度模块化；因此，它无创地允许您挑选所需的模块或特性，以便成为 JVM 上所有开发需求的一站式服务。

整个 Spring 框架组合分为三个主要元素：

*   弹簧框架
*   弹簧工具套件
*   Spring 子项目

Spring 不断改进，每一个新版本都变得越来越模块化，因此您可以只使用所需的模块。

### 注

这本书是基于 Spring 版本 4 的。

## 弹簧框架模块

核心 Spring 框架在其核心**控制反转**（**IoC**容器之上为 Java 开发提供了基础基础设施。IoC 容器是为应用程序提供**依赖注入**（**DI**的基础设施。本章后面将详细解释依赖项注入和 IoC 容器的概念。核心 Spring 框架分为以下模块，提供一系列服务：

<colgroup><col> <col></colgroup> 
| 

单元

 | 

总结

 |
| --- | --- |
| 核心容器 | 提供 IoC 和依赖项注入功能。 |
| AOP 与仪器 | 提供符合 AOP 联盟的功能，用于在 Spring 应用程序中编织横切关注点。 |
| 消息传递 | 通过 Spring 集成项目为基于消息传递的应用程序提供消息传递抽象。 |
| 数据存取/集成 | 数据访问/集成层由 JDBC、ORM、OXM、JMS 和事务模块组成。 |
| 网状物 | SpringMVC、WebSocket 和 PortletAPI 上的 Web 技术抽象。 |
| 测验 | 单元测试和集成测试支持 JUnit 和 TestNG 框架。 |

## 弹簧工具套件（STS）

STS 是用于 Spring 开发的基于 Eclipse 的**IDE**（简称**集成开发环境**）。您可以从[下载预捆绑 STShttp://spring.io/tools/sts/all](http://spring.io/tools/sts/all) 或从位于同一位置的更新站点更新您现有的 Eclipse 安装。STS 为 Spring 开发提供了各种高生产率功能。事实上，Java 开发人员可以使用他们选择的任何 IDE。几乎所有的 JavaIDE 都支持 Spring 开发，其中大多数都有 Spring 可用的插件。

## 春季子项目

Spring 有许多子项目可以解决各种应用程序基础架构需求。从配置到安全，从 web 应用到大数据，从生产力到**企业应用集成**（**EAI**），无论您的技术难点是什么，您都会找到一个 Spring 项目来帮助您进行应用开发。Spring 项目位于[http://spring.io/projects](http://spring.io/projects) 。

您可能会立即发现一些值得注意的项目是 Spring 数据（JPA、Mongo、Redis 等）、Spring 安全性、Spring Web 服务、Spring 集成、Spring for Android 和 Spring 引导。

# Spring 框架背后的设计理念

Spring Framework 的设计是由一组设计模式和最佳实践推动的，这些设计模式和最佳实践在业界不断发展，以解决面向对象编程的复杂性，包括：

*   简单、无创、轻量级的**POJO****普通旧 Java 对象**编程，无需复杂的应用服务器
*   松散耦合依赖，通过将*程序的概念应用于接口*和*组合而非继承*来实现，这是设计模式和框架的基本设计原则
*   由具有外部化依赖注入的对象组成的高度可配置系统
*   模板化抽象以消除重复的样板代码
*   在不污染业务组件的情况下声明性地编织横切方面

Spring 将既定的设计原则和模式实现到其优雅的组件中，并将其作为使用 Spring 构建的应用程序中的默认设计方法加以推广。这种非侵入性的方法使您能够设计出健壮且高度可维护的系统，这些系统由松散耦合的组件和对象组成，这些组件和对象使用干净的模块化代码编写。Spring 框架组件、模板和库实现了本章前面解释的目标和概念，让您专注于核心业务逻辑。

# 建立发展环境

Spring 项目通常创建为基于 Maven、Gradle 或 Ivy（构建自动化和依赖关系管理工具）的 Java 项目。您可以使用支持 Spring 工具的 STS 或 Eclipse 轻松创建基于 Maven 的 Spring 项目。您需要确保您的`pom.xml`（Maven 配置）文件至少包含对`spring-context`的依赖关系：

```java
<dependencies>
  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>${spring-framework.version}</version>
  </dependency>
  ...
</dependencies>
```

当然，您应该根据您的项目类型和需求，为模块添加更多依赖项，例如`spring-tx`、`spring-data-jpa`、`spring-webmvc`和`hibernate`。

除非明确指定存储库位置，否则项目将使用 Maven 的中央存储库。或者，您可以通过在`pom.xml`文件中指定 Spring 的官方 Maven 存储库（例如，里程碑和快照）：

```
<repositories>
    <repository>
        <id>io.spring.repo.maven.milestone</id>
        <url>http://repo.spring.io/milestone/</url>
        <snapshots><enabled>false</enabled></snapshots>
    </repository>
</repositories>
```

您可以根据需要使用 Spring`release`、`milestone`和`snapshot`存储库。

如果您使用 Gradle 作为构建系统，您可以声明您的依赖项（通常在`build.gradle`文件中），如下所示：

```
dependencies {
    compile('org.springframework:spring-context')
    compile('org.springframework:spring-tx')
    compile('org.hibernate:hibernate-entitymanager')
    testCompile('junit:junit')
}
```

如果您更喜欢使用 Ivy 依赖项管理工具，那么您的 Spring 依赖项配置将如下所示：

```
<dependency org="org.springframework"
    name="spring-core" rev="4.2.0.RC3" conf="compile->runtime"/>
```

# 您的第一次春季申请

现在让我们从一个非常简单的 Spring 应用程序开始。此应用程序只需向用户发送欢迎消息即可。从技术上讲，它演示了如何配置一个 Spring`ApplicationContext`（IoC 容器），其中只有一个 bean，并在应用程序中调用该 bean 方法。应用程序中有四个工件（当然，除了项目构建文件之外）：

*   `GreetingService.java`：Java 接口只是一个方法
*   `GreetingServiceImpl.java`：一个简单的`GreetingService`实现
*   `Application.java`：您的申请采用`main`方式
*   `application-context.xml`：应用程序的 Spring 配置文件

以下是应用程序的服务组件。服务实现只向记录器打印一条问候消息：

```
interface GreetingService {
   void greet(String message);
}

public class GreetingServiceImpl implements GreetingService {
   Logger logger = LoggerFactory.getLogger(GreetingService.class);

   public void greet(String message) {
      logger.info("Greetings! " + message);
   }
}
```

现在让我们看一个 PosiT0A.file，它是您的 Spring 配置文件，登记以下列表中的 Spring T1 作为 Spring bean：

```
<?xml version="1.0" encoding="UTF-8"?>
<beans 
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
   <bean id="Greeter"
      class="com.springessentialsbook.chapter1.GreetingServiceImpl">
   </bean>
</beans>
```

最后，从 Spring 应用程序调用`GreetingService.greet()`方法，如下代码所示：

```
public class Application {

   public static void main(String[] args) {
      ApplicationContext context = new ClassPathXmlApplicationContext(new String[] {"application-context.xml"});
      GreetingService greeter = (GreetingService) context.getBean("Greeter");
     greeter.greet("I am your first Spring bean instance, configured purely with XML metadata. I am resolved by name.");
   }
}
```

我们将从这个非常简单且几乎不言自明的应用程序中探索并征服强大的 Spring 框架。我们将在下面几节中讨论和阐述此应用程序背后的概念，以及更多内容。

## 解释了控制反转

IoC 是一种设计原则，它将面向对象程序的对象与其依赖项（协作者）分离，也就是说，与它们一起工作的对象。通常，这种解耦是通过将对象创建和依赖项注入的责任外部化到外部组件（如 IoC 容器）来实现的。

这个概念经常被比作好莱坞原则，“不要打电话给我们，我们会打电话给你。”在编程世界中，它建议主程序（或组件）不要自己实例化其依赖项，而是让汇编程序来完成这项工作。

这会立即将程序与紧密耦合的依赖关系所导致的许多问题分离开来，并减轻程序员的负担，让他们能够使用抽象依赖关系快速开发代码（*程序到接口*。稍后，在运行时，一个外部实体（如 IoC 容器）解析在某处指定的集中式实现，并在运行时注入它们。

您可以在我们刚才看到的示例中看到这个概念的实现。您的主程序（`Application.java`没有实例化`GreetingService`依赖项；它只要求`ApplicationContext`（IoC 容器）返回一个实例。在编写`Application.java`时，开发人员不需要考虑`GreetingService`接口的实际实现方式。Spring`ApplicationContext`负责对象创建，并透明地注入任何其他功能，保持应用程序代码干净。

IoC 容器管理的对象本身不控制其依赖项的创建和解析；相反，通过将其移到容器本身，该控制被反转；因此有了“控制权倒置”一词。

IoC 容器按照配置中的指定组装应用程序的组件。它处理托管对象的生命周期。

# 依赖注入

依赖注入是控制反转的一种特殊形式。它是一种更形式化的设计模式，通过这种模式，对象的依赖关系由汇编程序注入。DI 通常以三种主要样式执行：构造函数注入、属性（setter）注入，或者有时是接口注入。IoC 和 DI 经常互换使用。

DI 提供了几个好处，包括有效地解耦依赖项、更干净的代码和更高的可测试性。

## 春季国际奥委会集装箱

核心弹簧模块`spring-core`、`spring-beans`、`spring-context`、`spring-context-support`和`spring-expression`共同构成核心容器。Spring IoC 容器设计为以下接口的实现：

*   `org.springframework.beans.factory.BeanFactory`
*   `org.springframework.context.ApplicationContext`

`BeanFactory`接口提供了配置框架和基本功能，而`BeanFactory`的扩展`ApplicationContext`增加了更多企业特有的功能，例如更容易与 Spring 的 AOP 功能集成、消息资源处理（用于国际化）和事件发布。

Spring 为各种上下文提供了几种开箱即用的`ApplicationContext`的具体实现。下表列出了其中最受欢迎的：

<colgroup><col> <col></colgroup> 
| 

应用程序上下文

 | 

典型应用程序类型

 |
| --- | --- |
| `ClassPathXmlApplicationContext` | 独立的 |
| `AnnotationConfigApplicationContext` | 独立的 |
| `FileSystemXmlApplicationContext` | 独立的 |
| `GenericWebApplicationContext` | 网状物 |
| `XmlWebApplicationContext` | 网状物 |
| `XmlPortletApplicationContext` | Web portlet |

在春季，IoC 容器管理的对象称为**bean**。IoC 容器处理 SpringBean 的组装和生命周期。bean 是在容器使用的配置元数据中定义的，容器实例化并组装 bean 以组成应用程序。

## 配置元数据

Spring 支持三种形式的配置元数据来配置您的 bean：

*   基于 XML 的配置元数据
*   基于注释的配置元数据
*   基于 Java 的配置元数据

您前面看到的示例代码清单使用了基于 XML 的配置元数据。您始终可以在单个应用程序中混合和匹配不同形式的元数据。例如，您可以将主元数据定义为根 XML 文件，该文件组合了一组基于注释的元数据，这些元数据反过来定义了来自不同层的 bean。

### 基于 XML 的配置元数据

我们在上一个 Spring 应用程序示例中看到的`application-context.xml`文件是基于 XML 的配置元数据的非常简单的示例。bean 被配置为顶级`<beans>`元素中的`<bean/>`元素。

表示服务层的类（核心业务逻辑，也称为**服务**类）、**数据访问对象**（**DAOs**）、托管 web 支持 bean（如 Struts 动作实例和 JSF 托管 bean）、基础设施对象（如 Hibernate 会话工厂和 JMS 队列）等，都是 SpringBean 的优秀候选对象。细粒度域对象通常不会配置为 SpringBean，因为 DAO 通常负责创建和加载域对象 Hibernate 实体的业务逻辑就是典型的例子。

您可以创建一个合并（根）`ApplicationContext`XML 文件，该文件导入表示应用程序各个层的其他 XML 文件：

```
<?xml version="1.0" encoding="UTF-8"?>
<beans ...>

   <import resource="/xml-data-access-objects.xml"/>
   <import resource="/xml-services.xml"/>
   <import resource="/web-beans.xml"/>
   <import resource="/rest-endpoints.xml"/>
...
   <bean id="systemSettings" class="com...SystemSettings">
</beans>
```

### 基于注释的配置元数据

这个方法依赖字节码元数据来连接组件，而不是基于 XML 的尖括号声明。bean 的配置是在 bean 本身的源级别以类、字段或方法级别的注释形式定义的。

让我们来看一下源代码注释所配置的最简单的 Spring bean：

```
@Component("Greeter")
public class GreetingServiceImpl implements GreetingService {

   Logger logger = LoggerFactory.getLogger(GreetingService.class);

   public void greet(String message) {
      logger.info("Greetings! " + message);
   }
}
```

这只是在*您的第一个 Spring 应用程序*部分中显示的同一`GreetingServiceImpl`的一个注释版本，在`application-context.xml`文件中完全以 XML 形式配置。在前面的清单中，注释`@Component`使其成为 Springbean。现在，它不需要在 XML 中定义，但是您应该指示您的 AutoT3AL 考虑注释，如下面的代码所给出的：

```
<context:component-scan base-package="com.springessentialsbook"/>
```

您的`application-context.xml`文件中的这段代码片段强制`ApplicationContext`扫描整个应用程序，包括它的所有依赖项，甚至在 JAR 文件中，这些组件被注释为各种原型的 SpringBean，例如`@Component`、`@Service`、`@Repository`和`@Controller`。除了组件扫描，`ApplicationContext`在类、属性、构造函数和方法级别（包括 setter 方法）查找该 bean 中的所有注释，以便在启动时将依赖项和其他行为注入 bean。

注意，如果为`base-package`属性提供更广泛的包名，那么组件扫描可能会非常耗时；建议提供更具体的要扫描的包名称（例如，一组逗号分隔的包名称），以便您拥有更多的控制权。您可以使用`<context:include-filter/>`和`<context:exclude-filter/>`进一步缩小组件扫描范围。

启用注释配置的另一个简单指令是`<context:annotation-config/>`。它只是在应用程序上下文中注册的 bean 上查找注释，不会检测组件，而如果您使用`<context:component-scan/>`，它会处理组件扫描和其他注释，这将在本章后面介绍，因此您不需要显式声明`<context:annotation-config/>`。因此，基于注释的配置最好的方法是使用`<context:annotation-config/>`。

### 基于 XML 与基于注释的配置

基于 XML 的配置与基于注释的配置相比有一些优势。最大的一个问题是，所有 bean 定义都在一个地方，而不是分散在许多类甚至 JAR 依赖项中。XML 允许您拆分元数据文件，然后使用`<import/>`组合它们。使用 XML，您可以配置任何类，包括第三方类，如 Springbeans，并向其中注入依赖项和其他服务，这在注释的情况下是不可能的。此外，您还可以将同一类定义为多个不同的 bean，每个 bean 具有不同的名称、依赖项、配置等。

与 XML 配置相比，基于注释的元数据也有一些优势。它更简洁，更易于开发和维护，因为注释和 DI 就在源代码中。关于一个类的所有信息都在一个地方。

对于更大的应用程序，最好的选择是一种混合方法，在这种方法中，更可重用的 bean（多个项目之间共享的库）和第三方组件是用 XML 配置的，而那些范围较小的组件是注释的。

### 组件原型注释

Spring 为代表各种角色的 bean 提供了进一步的组件原型。主要原型是`@Component`，其他所有原型都是针对更具体用例的专门化：

<colgroup><col> <col></colgroup> 
| 

刻板印象

 | 

描述

 |
| --- | --- |
| `@Component` | 所有 Spring 管理组件（bean）的通用类型。 |
| `@Service` | 服务层组件的标记元注释。目前，Spring 将其视为`@Component`，没有特殊功能。 |
| `@Repository` | 将用作持久层中的 DAO。Spring 数据库提供了额外的功能。 |
| `@Controller` | 处理 Web MVC 端点，以便处理映射到特定 URL 的 HTTP 请求。 |
| `@RestController` | 用于 RESTful web 服务的专用控制器，是 web MVC 的一部分。它是结合了`@Controller`和`@ResponseBody`的元注释。 |

自定义原型可以通过从头定义元注释或组合现有注释来创建。

### 基于 Java 的配置元数据

从 Spring3.0 开始，您可以在 Java 类中配置 Spring 元数据，完全避免任何 XML 配置，同时增强基于注释的元数据。您可以在类级别使用`@Configuration`注释对任何 Java 类进行注释，并在实例化`@Component`注释或任何其他专用 bean 的工厂方法上将方法注释为`@Configuration`注释，以定义您的应用程序上下文。让我们看一个简单的例子：

```
@Configuration
@ComponentScan(basePackages = "com.springessentialsbook")
public class SpringJavaConfigurator {

    @Autowired
    private GreetingService greeter;

    @Autowired
    private BannerService banner;

    @Bean
    public BannerService createBanner() {
        return new BannerService();
    }

    public BannerService getBanner() {
        return this.banner;
    }

    public void run() {
        this.banner.displayBanner();
        this.greeter.greet("I am the Greeter Spring bean, configured with Java Configuration.");
    }
}
```

在`SpringJavaConfigurator.java`中，Java 配置类配置 SpringBean，替换`application-context.xml`文件。您的 Spring 应用程序可以直接依赖此`Configuration`类加载`ApplicationContext`。

通常，您使用`AnnotationConfigApplication`实例来实例化您的应用程序上下文：

```
ApplicationContext ctx = new AnnotationConfigApplicationContext(
  SpringJavaConfigurator.class);
SpringJavaConfigurator app = ctx.getBean(SpringJavaConfigurator.class);
app.run();
BannerService banner = ctx.getBean(BannerService.class);
banner.displayBanner();
```

当`@Configuration`类作为构造函数参数提供时，`@Configuration`类本身注册为 bean 定义，类内所有声明的`@Bean`方法也是如此。Spring 将扫描整个项目及其对`@Component`或其专门化（前面列出的其他原型）的依赖关系，将`@ComponentScan(basePackages = "…")`中提供的参数值与所有其他相关注释匹配，并构建应用程序上下文。

JavaConfig 元数据的优点是，您可以对 Spring 配置进行编程控制，同时将整个 DI 和 bean 配置分离到一个单独的 Java 类中。使用 JavaConfig，您可以消除管理许多 XML 文件的复杂性。您最早会在开发过程中检测到任何配置问题，因为 JavaConfig 在编译过程中失败，而对于 XML，您将只在应用程序启动时才知道配置问题。

### JSR 330 标准注释

除了特定于 Spring 的注释外，Spring 还从 Spring 3.0 开始支持 DI 的 JSR 330 标准注释。您只需要在 Maven 或 Gradle 配置中包含`javax.inject`工件。

JSR 330 标准注释在 Spring 中具有以下等价物：

<colgroup><col> <col> <col></colgroup> 
| 

春天

 | 

JSR-330（javax.inject.*）

 | 

目标级别/使用率

 |
| --- | --- | --- |
| `@Component` | `@Named` | 类型（类别） |
| `@Autowired` | `@Inject` | 属性和 setter 方法 |
| `@Qualifier` | `@Named` | 类型、属性和 setter 方法 |
| `@Scope("singleton")` | `@Singleton` | bean 声明的元注释 |

虽然 Springbeans 的默认范围是`singleton`，但 JSR330 的默认范围与 Spring 的`prototype`类似。然而，为了一致性，Spring 将 Spring 中 JSR330 注释的 bean 视为`singleton`，除非声明的原型明确使用`@Scope("..")`。

JSR330 对于一些基于 Spring 的 DI 注释（如`@Value`、`@Required`和`@Lazy`）没有等价物。我们将在本章后面讨论更多关于 bean 作用域的内容。

# 豆子细节

Spring 应用程序由一组 bean 组成，这些 bean 执行特定于应用程序层的功能，并由 IoC 容器管理。您可以使用 XML、注释或 JavaConfig 形式的配置元数据定义 bean。

### 注

Springbean 的默认范围是`singleton`。这意味着应用程序中任何位置的客户端之间共享一个实例。当心在`singleton`类中保留状态（类级数据），因为一个客户端设置的值将对所有其他客户端可见。此类`singleton`类的最佳用例是无状态服务。

bean 由一个`id`属性、提供给 bean 定义的`name`属性（逗号、分号或空格分隔）的任何值（甚至作为`alias`定义）唯一标识。您可以使用`id`或 bean 定义中指定的任何名称或别名在应用程序中的任何位置引用 bean。

没有必要总是为 bean 提供一个`id`或名称。如果没有提供，Spring 将为它生成一个唯一的 bean 名称；但是，如果您想使用名称或`id`来引用它，则必须提供一个。

如果没有提供`id`或名称，Spring 将尝试按类型自动连接 bean。这意味着`ApplicationContext`将尝试匹配具有相同类型或实现的 bean，以防它是一个接口。

如果 bean 是该类型中唯一注册的 bean 或标记为`@Primary`（`primary="true"`表示 XML），则可以按类型引用该 bean。通常，对于嵌套 bean 定义和 autowire 协作者，除非在定义之外引用名称，否则不需要定义名称。

您可以使用`<alias/>`标记在 bean 定义之外别名 bean，如下所示：

```
<alias name="fromName" alias="toName"/>
```

## 豆定义

定义用于描述 bean 的 bean 定义对象具有以下元数据：

<colgroup><col> <col></colgroup> 
| 

所有物

 | 

描述

 |
| --- | --- |
| `class` | bean 的完全限定类名。 |
| `id` | bean 的唯一标识符。 |
| `name` | 一个或多个由逗号、分号或空格分隔的唯一名称。通常，`id`和名称是相同的，您可以提供这两个选项中的任何一个。列表中的其他名称将成为别名。 |
| `parent` | 用于从父 bean 定义继承配置数据的父 bean。 |
| `scope` | 这决定了对象的范围。Springbean 的默认范围是`singleton`。这意味着调用之间共享一个实例。稍后我们将讨论更多关于 bean 作用域的内容。 |
| `constructor args` | 基于构造函数的 DI 的 Bean 引用或名称。 |
| `properties` | 基于 setter 的 DI 的值或引用。 |
| `autowire`模式 | 指示 bean 是否或如何自动关联与协作者的关系。自动布线将在后面讨论。 |
| `primary` | 这表明在找到多个匹配项的情况下，bean 应该被视为主要的自动连接候选项。 |
| `depends-on` | 这将强制在该 bean 之前实例化依赖 bean。 |
| `lazy-init` | 如果为 true，则在第一次请求时创建一个 bean 实例。 |
| `init-method` | 初始化回调方法。这没有`args void`方法，将在创建实例后调用。 |
| `destroy-method` | 销毁回调方法。它没有`args void`方法，将在`destroy`之前调用。 |
| `factory-method` | bean 本身上的静态实例工厂方法，除非提供了`factory-bean`。 |
| `factory-bean` | 另一个 bean 引用，充当此 bean 的实例工厂。通常与`factory-method`属性一起出现。 |

让我们来看一个 XML 格式的 bean 定义示例：

```
<bean id="xmlTaskService" class="com...XmlDefinedTaskService"
init-method="init" destroy-method="cleanup">
   <constructor-arg ref="userService"/>
   <constructor-arg>
      <bean class="com...TaskInMemoryDAO"></bean>
   </constructor-arg>
</bean>
```

在这个示例`application-context`文件中，bean`xmlTaskService`是通过构造函数自动连接的，也就是说，依赖项是通过构造函数注入的。第一个构造函数参数引用现有的 bean 定义，第二个是没有`id`的内联 bean 定义。这个 bean 有`init-method`和`destroy-method`指向它自己的方法。

现在，让我们来看看一个注释稍微不同的 bean 的特征：

```
@Service
public class AnnotatedTaskService implements TaskService {

...
   @Autowired
   private UserService userService;

   @Autowired
   private TaskDAO taskDAO;

   @PostConstruct
   public void init() {
      logger.debug(this.getClass().getName() + " started!");
   }

   @PreDestroy
   public void cleanup() {
      logger.debug(this.getClass().getName() + " is about to destroy!");
   }

   public Task createTask(String name, int priority, int createdByuserId, int assigneeUserId) {
      Task task = new Task(name, priority, "Open",
         userService.findById(createdByuserId), null,
         userService.findById(assigneeUserId));
      taskDAO.createTask(task);
      logger.info("Task created: " + task);
      return task;
   }
...
}
```

此`@Service`bean 使用`@Autowired`注释自动关联其对字段（属性）的依赖关系。注意`@PostConstruct`和`@PreDestroy`注释，它们是前面 XMLBean 定义示例中`init-method`和`destroy-method`的等价物。这些不是特定于 Spring 的，而是 JSR250 注释。它们与 Spring 配合得很好。

## 实例化 bean

Bean 定义是实例化 Bean 实例的方法。Spring 框架根据元数据属性，如`scope`、`lazy`和`depends-on`，决定创建实例的时间和方式。我们稍后会详细讨论。这里，让我们看看实例创建的“方式”。

### 与施工人员

任何有或没有构造函数参数但没有`factory-method`的 bean 定义都通过其自己的构造函数实例化，使用`new`运算符：

```
<bean id="greeter" class="com...GreetingBean"></bean>
```

现在让我们看一个带注释的`@Component`，带有基于默认构造函数的实例化：

```
@Component("greeter")
public class GreetingService {
...
}
```

### 采用静态工厂法

在这种情况下，将调用同一类中标记为`factory-method`的静态方法来创建实例：

```
<bean id="Greeter" class="...GreetingBean" factory-method="newInstance"></bean>
```

通过 Java 配置，您可以使用`@Bean`注释代替工厂方法：

```
@Configuration
@ComponentScan(basePackages = "com.springessentialsbook")
public class SpringJavaConfigurator {
...
   @Bean
   public BannerService createBanner() {
      return new BannerServiceImpl();
   }
...
}
```

### 使用实例工厂方法

在这种情况下，bean 定义不需要 class 属性，但是您指定`factory-bean`属性，这是另一个 bean，它的一个非静态方法为`factory-method`：

```
<bean id="greeter"  factory-bean="serviceFactory" factory-method="createGreeter"/>
<bean id="serviceFactory"  class="...ServiceFactory">
<!— ... Dependencies ... -->
</bean>
```

## 注入 bean 依赖项

IoC 容器的主要目的是在对象（bean）返回给调用实例的客户机（比如，使用`getBean`方法）之前解析它们的依赖关系。Spring 基于 bean 配置透明地完成这项工作。当客户机接收到 bean 时，除非指定为不需要（`@Autowired(required = false)`），否则其所有依赖项都将被解析，并准备好使用。

Spring 支持基于构造函数和基于 setter 的 DI 的两种主要变体，即开箱即用。

### 基于构造函数的依赖注入

在基于构造函数的 DI 中，bean 的依赖项作为构造函数参数被注入。基本上，容器调用定义的构造函数，传递参数的解析值。通过构造函数解决强制依赖关系是最佳实践。让我们看一个简单的 POJO`@Service`类的例子，它是基于构造函数的 DI 的候选类：

```
public class SimpleTaskService implements TaskService {
...
   private UserService userService;
   private TaskDAO taskDAO;

   public SimpleTaskService(UserService userService, TaskDAO taskDAO) {
      this.userService = userService;
      this.taskDAO = taskDAO;
   }
...
}
```

现在，让我们将其定义为 XML 中的 Springbean：

```
<bean id="taskService" class="com...SimpleTaskService"">
   <constructor-arg ref="userService" />
   <constructor-arg ref="taskDAO"/>
</bean>
```

Spring 容器通过基于参数类型的构造函数解析依赖项。对于前面的示例，您不需要传递参数的索引或类型，因为它们属于复杂类型。

但是，如果构造函数具有简单的类型，例如基元（`int`、`long`和`boolean`、基元包装器（`java.lang.Integer`、`Long`等等）或`String`，则可能会出现类型和索引的歧义。在这种情况下，可以显式指定每个参数的类型和索引，以帮助容器匹配参数，如下所示：

```
<bean id="systemSettings" class="com...SystemSettings">
   <constructor-arg index="0" type="int" value="5"/>
   <constructor-arg index="1" type="java.lang.String" value="dd/mm/yyyy"/>
   <constructor-arg index="2" type="java.lang.String" value="Taskify!"/>
</bean>
```

记住，索引编号从零开始。这同样适用于基于 setter 的注入。

### 基于 Setter 的依赖注入

容器在调用构造函数（有或没有`args`）后，如果是基于 setter 的 DI，容器调用 bean 的 setter 方法。假设`SystemSettings`现在有一个`no-args`构造函数，让我们看看如果依赖项是通过 setter 方法注入的，那么前面`SystemSettings`的 bean 定义会是什么样子：

```
<bean id="systemSettings" class="com...SystemSettings">
   <property name="openUserTasksMaxLimit" value="5"/>
   <property name="systemDateFormat" value="dd/mm/yyyy"/>
   <property name="appDisplayName" value="Taskify!"/>
</bean>
```

Spring 在`ApplicationContext`启动时验证 bean 定义，如果配置错误，则会发送正确消息失败。当创建 bean 实例时，为具有内置类型（如`int`、`long`、`String`和`boolean`的属性提供的字符串值会自动转换和注入。

## 基于构造函数还是基于 setter 的 DI？哪一个更好？

这些 DI 方法中哪种更好纯粹取决于您的场景和一些需求。以下最佳实践可提供指南：

1.  对强制依赖项使用基于构造函数的 DI，以便 bean 在第一次调用时就可以使用。
2.  当你的构造函数中塞满了大量的参数时，那就是象征性的坏代码味道。现在是将 bean 分解为更小的单元以实现可维护性的时候了。
3.  仅对可选依赖项使用基于 setter 的 DI，或者如果以后需要重新注入依赖项，可以使用 JMX。
4.  避免当 bean（bean a）的依赖项（比如 bean B）直接或间接地再次依赖于同一个 bean（bean a）时出现循环依赖项，并且所有涉及的 bean 都使用基于构造函数的 DI。您可以在这里使用基于 setter 的 DI。
5.  您可以为同一个 bean 混合基于构造函数和基于 setter 的 DI，考虑强制、可选和循环依赖。

在典型的 Spring 应用程序中，您可以看到使用这两种方法注入的依赖项，但这取决于场景，考虑到前面的指导原则。

## 具有名称空间快捷方式的 Cleaner bean 定义

您可以使用`p:(property)`和`c:(constructor)`名称空间使 bean 定义更清晰、更具表现力，如下所示。`p`命名空间允许您使用`<bean/>`元素的属性而不是嵌套的`<property/>`元素来描述您的属性值（或协作 bean 引用），而`c`命名空间允许您将构造函数`args`声明为`<bean/>`元素的属性：

```
<beans  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:c="http://www.springframework.org/schema/c" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context/spring-context.xsd">

   <bean id="p-taskService" class="com...SimpleTaskService" c:userService-ref="userService" c:taskDAO-ref="taskDAO"/>

   <bean id="p-systemSettings" class="com...SystemSettings"
      p:openUserTasksMaxLimit="5"
      p:systemDateFormat"dd/mm/yyyy"
      p:appDisplayName="Taskify!"/>
</beans>
```

前面清单中的 bean 定义更清晰，但更具表达力。`c:`和`p:`名称空间遵循相同的约定。在将它们与`<bean/>`元素一起使用之前，需要在 XML 根元素（`<beans/>`处声明这两个元素。注意，bean 引用使用了`-ref`后缀。

## 将列表关联为依赖项

在情况下，我们需要将静态数据集合作为 bean 依赖注入。Spring 提供了一种连接列表的自然方法。请参见此示例：

```
<bean id="systemSettings" class="com...SystemSettings">
. . .
  <constructor-arg>
    <list>
      <value>admin@taskify.ae</value>
      <value>it@taskify.ae</value>
      <value>devops@taskify.ae</value>
    </list>
  </constructor-arg>
</bean>
```

为了简单起见，前面的示例连接了一个`java.util.List<String>`。如果您的列表包含一个 bean 集合，您可以将`<value>`替换为`<ref>`或`<bean>`。

## 将地图关联为依赖项

您也可以以类似的方式注入`java.util.Map`实例。看看这个例子：

```
<bean id="systemSettings" class="com...SystemSettings">
. . .
  <property name="emails">
    <map>
      <entry key="admin" value="admin@taskify.ae"></entry>
      <entry key="it" value="it@taskify.ae"></entry>
      <entry key="devops" value="devops@taskify.ae"></entry>
    </map>
  </property>
</bean>
```

您可以将 bean 作为值注入，将`<value>`替换为`<ref>`或`<bean>`。

## 自动连线依赖项

如果指定 autowire 模式，Spring 可以通过检查`ApplicationContext`中存在的 bean 定义，自动连接 bean 的依赖项。在 XML 中，您可以指定`<bean/>`元素的`autowire`属性。或者，您可以使用`@Autowired`注释 bean 以自动关联依赖项。Spring 支持四种自动布线模式：`no`、`byName`、`byType`、`constructor`。

### 注

SpringBean 的默认自动连线为`byType`。如果您正在自动连接一个接口，Spring 将尝试找到配置为 Springbean 的该接口的实现。如果有多个，Spring 将查找要解析的配置的`primary`属性；如果没有找到，它将失败，抱怨 bean 定义不明确。

以下是自动关联构造函数参数的示例：

```
@Service
public class AnnotatedTaskService implements TaskService {
...
   @Autowired
   public AnnotatedTaskService(UserService userService, TaskDAO taskDAO) {
      this.userService = userService;
      this.taskDAO = taskDAO;
   }
...
}
```

或者，可以在字段级别自动关联，如下所示：

```
@Service
public class AnnotatedTaskService implements TaskService {
...
   @Autowired
   private UserService userService;
   @Autowired
   private TaskDAO taskDAO;
...
}
```

自动布线可以通过`@Qualifier`注释和所需属性进行微调：

```
@Autowired(required = true)
@Qualifier("taskDAO")
private UserService userService;
```

您也可以在构造函数级别使用`@Qualifier`：

```
@Autowired
public AnnotatedTaskService(@Qualifier("userService") UserService userService, @Qualifier("taskDAO") TaskDAO taskDAO) {
   this.userService = userService;
   this.taskDAO = taskDAO;
}
```

## 大豆范围界定

当使用依赖项和其他配置值定义 bean 时，您可以选择在 bean 定义中指定 bean 的范围。范围决定了 bean 的寿命。Spring 提供了六个现成的内置作用域，并支持创建自定义作用域。如果没有明确指定，bean 将采用`singleton`范围，这是默认范围。下表列出了内置的 Spring 作用域：

<colgroup><col> <col></colgroup> 
| 

范围

 | 

描述

 |
| --- | --- |
| `singleton` | 这确保了容器中只有一个实例。这是默认范围。 |
| `prototype` | 为 bean 的每个请求创建一个新实例。 |
| `request` | 使用每个新 HTTP 请求的生命周期确定实例的作用域。 |
| `session` | 作用域包含每个新 HTTP 会话的生命周期。 |
| `globalSession` | 在 portlet 上下文中使用 HTTP 会话的作用域。 |
| `application` | 具有`ServletContext`生命周期的范围。`singleton`代表`ServletContext`。 |

虽然`singleton`和`prototype`可以在所有环境中工作，但请求、会话和应用程序只能在 web 环境中工作。`globalSession`范围适用于 portlet 环境。

在 XML bean 定义中，通过`<bean/>`元素的`scope`属性设置范围：

```
<bean id="userPreferences" class="com...UserPreferences" scope="session">... </bean>
```

您可以将 bean 范围注释为对`@Component`或其派生的元注释，如`@Service`和`@Bean`，如下所示：

```
@Component
@Scope("request")
public class TaskSearch {...}
```

通常，服务类和 Spring 数据存储库被声明为`singleton`，因为它们是根据最佳实践无状态构建的。

## 使用作用域 bean 的依赖项注入

不同作用域的 bean 可以作为配置元数据中的协作者连接起来。例如，如果您有一个会话范围 bean 作为对`singleton`的依赖项，并且面临不一致性问题，那么会话范围 bean 的第一个实例将在所有用户之间共享。这可以用作用域代理代替作用域 bean 来解决：

```
<bean id="userPreferences" class="com...UserPreferences" scope="session">
   <aop:scoped-proxy />
</bean>
<bean id="taskService" class="com...TaskService">
   <constructor-arg ref="userPreferences"/>
</bean>
```

每次注入作用域 bean 时，Spring 都会围绕 bean 创建一个新的 AOP 代理，以便从确切的作用域中提取实例。前面清单的注释版本如下所示：

```
@Component
@Scope(value = "session", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class UserPreferences { ... }

public class AnnotatedTaskService implements TaskService {
...
   @Autowired
   private UserPreferences userPreferences;
...
}
```

## 创建自定义范围

有时，Spring 提供的范围不足以满足您的特定需求。Spring 允许您为场景创建自己的自定义范围。例如，如果希望在业务流程的整个生命周期中保留某些业务流程级别的信息，则需要创建一个新的流程范围。以下步骤将使您能够实现这一目标：

1.  创建一个扩展`org.springframework.beans.factory.config.Scope`的 Java 类。
2.  在应用程序上下文（XML 或注释）中将其定义为 Springbean。
3.  以编程方式或以 XML 方式向`CustomScopeConfigurer`注册`ApplicationContext`的作用域 bean。

# 与豆子生命周期挂钩

通常，在企业应用程序开发中，开发人员希望插入一些额外的功能，以便在构建之后和业务服务销毁之前执行。Spring 提供了多种方法来与 bean 生命周期中的这些阶段进行交互。

## 实现 InitializingBean 和 DisposableBean

Spring IoC 容器在任何 Spring bean 上调用`org.springframework.beans.factory.InitializingBean`的回调方法`afterPropertiesSet()`和`org.springframework.beans.factory.DisposableBean`的`destroy()`回调方法`afterPropertiesSet()`并实现它们：

```
public class UserServiceImpl implements UserService, InitializingBean, DisposableBean {
...
   @Override
   public void afterPropertiesSet() throws Exception {
      logger.debug(this + ".afterPropertiesSet() invoked!");
      // Your initialization code goes here..
   }

   @Override
   public void destroy() throws Exception {
      logger.debug(this + ".destroy() invoked!");
      // Your cleanup code goes here..
   }
...
}
```

## 在构件上标注施工后和施工前

Spring 支持注释支持的环境中的任何 SpringBean 上的 JSR250`@PostConstruct`和`@PreDestroy`注释，如下所示。Spring 鼓励采用这种方法来实现 Spring 特定的接口，如前一节所述：

```
@Service
public class AnnotatedTaskService implements TaskService {
...
   @PostConstruct
   public void init() {
      logger.debug(this.getClass().getName() + " started!");
   }

   @PreDestroy
   public void cleanup() {
      logger.debug(this.getClass().getName() + " is about to destroy!");
   }
...
}
```

## <bean/>的 init method 和 destroy method 属性

如果您使用的是仅 XML 的 bean 配置元数据，那么最好的选择是在`<bean/>`标记上声明`init-method`和`destroy-method`属性：

```
<bean id="xmlTaskService" class="com...XmlDefinedTaskService" init-method="init" destroy-method="cleanup">
...
</bean>
```

# 容器级默认初始化方法和默认销毁方法

您甚至可以设置容器级别的默认`init`和`destroy`方法，这样您就不需要为每个 bean 设置它。容器仅在 bean 上存在以下方法时才会调用这些方法：

```
<beans default-init-method="init" default-destroy-method="cleanup">
...
</beans>
```

# 使用 bean 定义配置文件

对于商业项目，通常要求能够维护两个或多个特定于环境的配置和 bean，仅在相应的环境中选择性地激活。例如，数据源、电子邮件服务器和安全设置等对象在开发、测试和生产环境中可能会有所不同。您可能希望在不接触应用程序代码的情况下以声明方式切换它们，并将其保留在外部。开发人员通常使用单独的构建来编写复杂的脚本和属性文件来完成这项工作。Spring 通过使用 bean 定义概要文件和属性进行环境抽象来拯救您。

Bean 定义概要文件是一种机制，通过该机制，应用程序上下文可以针对不同的环境进行不同的配置。您可以在 XML 中的命名概要文件下或使用注释将 bean 定义分组，并在每个环境中激活一个或多个概要文件。如果未明确指定默认配置文件，则可以将其设置为启用。

让我们来看看下面的示例清单，该列表为开发和生产环境配置数据源：

```
@Configuration
@ComponentScan(basePackages = "com.springessentialsbook")
public class ProfileConfigurator {

   @Bean
   @Profile("dev")
   public DataSource devDataSource() {
      return new EmbeddedDatabaseBuilder()
         .setType(EmbeddedDatabaseType.HSQL) .addScript("scripts/tasks-system-schema.sql") .addScript("scripts/tasks-master-data.sql") .build();
   }
   @Bean
   @Profile("prod")
   public DataSource productionDataSource() throws Exception {
      Context ctx = new InitialContext();
      return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource/tasks");
   }
}
```

实际上，对于生产环境，将此概要文件配置外部化为 XML 将是一个更好的主意，您可以允许您的 DevOps 团队针对不同的环境修改它，并禁止他们接触您的 Java 代码。XML 配置如下所示：

```
<?xml version="1.0" encoding="UTF-8"?>
<beans 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:jdbc="http://www.springframework.org/schema/jdbc"
  xmlns:jee="http://www.springframework.org/schema/jee"
  xsi:schemaLocation="...">
  <!-- other bean definitions -->
  <beans profile="dev">
    <jdbc:embedded-database id="dataSource">
      <jdbc:script location="classpath:scripts/tasks-system-schema.sql"/>
      <jdbc:script location="classpath:scripts/tasks-master-data.sql"/>
    </jdbc:embedded-database>
  </beans>

  <beans profile="production">
    <jee:jndi-lookup id="dataSource" jndi-name="java:comp/env/jdbc/datasource"/>
  </beans>
</beans>
```

您可以根据需要创建任意多个配置文件；每个开发人员维护自己的配置是很常见的，配置文件以他们自己的名字命名，比如说`@Profile("mary")`。您也可以同时激活多个配置文件；这取决于您如何在配置文件之间组织它们，而不存在冲突或重复的 bean 定义。

现在您可以使用以下任一方法在每个（`dev`、`test`或`prod`环境中根据需要激活一个或多个配置文件：

1.  以编程方式调用`ctx.getEnvironment().setActiveProfiles("p1", "p2", ..)`。
2.  设置属性`spring.profile.active`-`web.xml`中以逗号分隔的配置文件名称作为环境变量、JVM 系统属性或 Servlet 上下文参数的值。
3.  启动应用程序时，将`-Dspring.profile.active="p1,p2, .."`添加为命令行或 Java 参数。

# 向弹簧环境中注入特性

除了使用概要文件分离特定于环境的配置之外，您还需要将许多属性外部化，例如属性文件中的数据库 URL、电子邮件和日期格式，以便于处理。然后，这些属性要么直接注入 bean，要么在运行时由 bean 从环境中读取。Spring 的环境抽象以及`@PropertySource`注释使这在 Spring 应用程序中成为可能。

`@PropertySource`注释为向 Spring 环境中添加`PropertySource`提供了一种方便的声明机制：

```
@Configuration
@PropertySource("classpath:application.properties")
@ComponentScan(basePackages = "com.springessentialsbook")
public class SpringJavaConfigurator {
...
   @Autowired
   @Lazy
   private SystemSettings systemSettings;

   @Autowired
   private Environment env;

   @Bean
   public SystemSettings getSystemSettings() {
      String dateFormat = env.getProperty("system.date-format");
      String appDisplayName = env.getProperty("app.displayname");

      return new SystemSettings(dateFormat, appDisplayName);
   }
…
}
```

# 使用 PropertyPlaceHolder 配置器将属性外部化

`PropertyPlaceholderConfigurer`是另一个方便的实用程序，可将 bean 定义中的属性值外部化到使用标准`java.util.Properties`格式的单独文件中。它用配置的属性文件中匹配的属性值替换 XMLBean 定义中的占位符，如下所示。这是外部化配置文件或特定于环境的信息（如数据源配置、电子邮件设置等）的最佳方法。DevOps 团队只需编辑这些属性文件，而不会弄乱您的代码：

```
<bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
    <property name="locations" value="classpath:datasource.properties"/>
</bean>

<bean id="dataSource" destroy-method="close"
        class="org.apache.commons.dbcp.BasicDataSource">
    <property name="driverClassName" value="${jdbc.driverClassName}"/>
    <property name="url" value="${jdbc.url}"/>
    <property name="username" value="${jdbc.username}"/>
    <property name="password" value="${jdbc.password}"/>
</bean>
```

以下是`PropertyPlaceholder`的另一个更简单的声明：

```
<context:property-placeholder location="classpath:datasource.properties"/>
```

# 处理资源

Spring 框架为访问底层资源提供了极好的支持，从而解决了 Java 标准`java.net.URL`和标准处理程序的许多限制。AuthT1 包及其许多具体的实现为 Spring 框架的健壮的资源处理奠定了坚实的基础。

资源抽象在 Spring 本身中被广泛使用，在`ApplicationContext`的许多实现中——实际上，在您自己的代码中作为一个通用实用程序类使用它来访问资源是非常有用的。您将在 Spring 中发现以下即时提供的资源实现：

<colgroup><col> <col></colgroup> 
| 

资源实施

 | 

描述

 |
| --- | --- |
| `UrlResource` | 它包装了`java.net.URL`，可用于访问任何可以通过 URL 访问的内容，例如文件（`file:///`）、HTTP 目标（`http://`）和 FTP 目标（`ftp://`）。 |
| `ClassPathResource` | 用于使用前缀`classpath:`从类路径访问任何资源 |
| `FileSystemResource` | 这是`java.io.File`的资源实现。 |
| `ServletContextResource` | 这是用于从父 bean 定义继承配置数据的父 bean。 |
| `InputStreamResource` | 这是给定`InputStream`的资源实现。 |

通常，您不会直接实例化这些资源中的任何一个；相反，您使用`ResourceLoader`接口为您完成该工作。所有`ApplicationContext`实现`ResourceLoader`接口；因此，任何`ApplicationContext`都可以用来获取资源实例。其代码如下：

```
ApplicationContext context = new ClassPathXmlApplicationContext(new String[] {"application-context.xml"});
Resource classPathResource = ctx.getResource("classpath:scripts/tasks-schema.sql");

Resource fileResource = ctx.getResource("file:///scripts/master-data.sql");

Resource urlResource = ctx.getResource("http://country.io/names.json");
```

只需将资源的文件名或 URL 作为参数传递，就可以将资源注入 bean，如下所示。`ApplicationContext`是一个`ResourceLoader`接口，它将根据您提供的 URL 创建适当资源实现的实例：

```
@Value("http://country.io/names.json")
private Resource countriesResource;
```

以下是注入资源的 XML 版本：

```
<property name="countriesResource" value="http://country.io/names.json"/>
```

# 弹簧表达语言

表达式语言通常用于在非面向对象上下文中操作对象图的简单脚本。例如，如果我们想从 JSP、XML 或 XHTML 页面读取数据或调用 Java 对象的方法，JSP EL 和**统一表达式语言（UEL）**就可以起到帮助作用。这些表达式语言允许页面作者以简单易用的方式访问外部数据对象，与基于标记的语言（如 XML 和 HTML）兼容。

**Spring 表达式语言**（**SpEL**的语言语法类似于 UEL，是一种强大的表达式语言，用于在运行时查询和操作对象图。它提供了额外的特性，最显著的是方法调用和基本的字符串模板功能。

SpEL 可以用于 Spring 系列项目中的各种技术以及与 Spring 集成的许多技术。它可以直接在 Spring 配置元数据文件中使用，既可以是 XML 格式，也可以是 Java 注释格式的`#{expression-string}`。当与相应的技术（如 JSF、JSP 和 XHTML）集成时，您可以在许多视图技术（如 JSP、XML 和 XHTML）中使用 SpEL。

## SpEL 特征

SpEL 表达式语言支持以下现成功能：

*   布尔运算符、关系运算符和三元运算符
*   正则表达式和类表达式
*   访问属性、数组、列表和映射
*   方法和构造函数调用
*   变量、赋值和 bean 引用
*   数组构造、内联列表和映射
*   用户定义函数和模板化表达式
*   收集、投影和选择

## SpEL 注释支持

SpEL 可以用于使用`@Value`注释为字段、方法和方法或构造函数参数指定默认值。下面的示例列表包含在字段级别对 SpEL 表达式的一些出色用法：

```
@Component
@Scope("prototype")
public class TaskSnapShot {

   Value("#{taskService.findAllTasks().size()}")
   private String totalTasks;

   @Value("#{taskService.findAllTasks()}")
   private List<Task> taskList;

   @Value("#{ new java.util.Date()}")
   private Date reportTime;

   @Value("#{taskService.findAllTasks().?[status == 'Open']}")
   private List<Task> openTasks;
...

}
```

同样的方法也可以用于 XMLBean 定义。

## SpEL API

通常，大多数用户使用 SpEL 来计算嵌入 XML、XHTML 或注释中的表达式。虽然 SPEL 是在 Spring 组合中进行表达式求值的基础，但它可以使用 SPELAPI 在非弹性环境中独立使用。SPELAPI 提供了引导基础设施，可以在任何环境中以编程方式使用 SpEL。

SpEL API 类和接口位于`org.springframework.expression`下的（子）包中。它们提供了可以直接使用或扩展的规范和默认 SpEL 实现。

下面的接口和类 Syt0 构成 SPEL API 的基础：

<colgroup><col> <col></colgroup> 
| 

类/接口

 | 

描述

 |
| --- | --- |
| `Expression` | 一种表达式规范，它能够根据上下文对象对自身进行求值，而不依赖于任何语言，如 OGNL 或 UEL。它封装了以前解析的表达式字符串的详细信息。 |
| `SpelExpression` | 一种符合 SpEL 的已解析表达式，可以单独或在指定上下文中进行计算。 |
| `ExpressionParser` | 将表达式字符串（模板以及标准表达式字符串）解析为可计算的编译表达式。 |
| `SpelExpressionParser` | SpEL 解析器。实例是可重用和线程安全的。 |
| `EvaluationContext` | 表达式在计算上下文中执行，在计算表达式期间遇到引用时将解析引用。 |
| `StandardEvaluationContext` | 默认的`EvaluationContext`实现，使用反射解析对象的属性/方法/字段。如果这还不足以供您使用，您可以扩展此类以注册自定义`ConstructorResolver`、`MethodResolver`和`PropertyAccessor`对象，并重新定义 SpEL 计算表达式的方式。 |
| `SpelCompiler` | 将常规解析表达式（而非解释形式）编译为包含字节码的类以进行计算。这是一种速度快得多的方法，但仍处于早期阶段，从 Spring4.1 开始，它还不支持所有类型的表达式。 |

让我们来看一个使用 SPELAPI 评估表达式的例子：

```
@Component
public class TaskSnapshotBuilder {

   @Autowired
   private TaskService taskService;

   public TaskSnapShot buildTaskSnapShot() {
      TaskSnapShot snapshot = new TaskSnapShot();

      ExpressionParser parser = new SpelExpressionParser();
      EvaluationContext context = new StandardEvaluationContext(taskService);
      Expression exp = parser.parseExpression("findAllTasks().size()");
      snapshot.setTotalTasks(exp.getValue(context).toString());

      exp = parser.parseExpression("findAllTasks()");
      snapshot.setTaskList((List<Task>)exp.getValue(context));

      exp = parser.parseExpression("new java.util.Date()");
      snapshot.setReportTime((Date)exp.getValue(context));

      exp = parser.parseExpression("findAllTasks().?[status == 'Open']");
      snapshot.setOpenTasks((List<Task>)exp.getValue(context));

      return snapshot;
   }

}
```

在正常情况下，您不需要在 Spring 应用程序中直接使用 SpEL API；带有注释或 XMLBean 定义的 SpEL 将是更好的候选者。SPELAPI 主要用于在运行时动态加载外部化的业务规则。

# 面向方面编程

大多数软件应用程序通常具有一些次要但关键的功能，例如跨多个逻辑模块的安全性、事务和审计日志记录。最好不要将这些交叉关注点混入您的核心业务逻辑中。**面向方面编程**（**AOP**帮助您实现这一点。

**面向对象编程**（**OOP**）是关于复杂软件程序的模块化，对象是承载核心业务逻辑和数据的基本单元。AOP 补充了 OOP，在应用程序的各个模块之间透明地添加更复杂的功能，而不会污染原始对象结构。AOP 在编译时或运行时将横切关注点缝合（编织）到程序中，而不修改基本代码本身。AOP 让面向对象的程序保持干净，只考虑核心业务问题。

## 静态和动态 AOP

在 AOP 中，框架将横切关注点透明地编织到主程序中。这种编织过程有两种不同的风格：静态和动态。在静态 AOP 的情况下，顾名思义，方面在编译时直接编译成静态文件，即 Java 字节码。这种方法性能更好，因为在运行时没有特殊的拦截。但缺点是每次更改代码时都需要重新编译整个应用程序。AspectJ 是最全面的 AOP 实现之一，提供方面的编译时编织。

在动态 AOP 的情况下，编织过程在运行时动态执行。不同的框架以不同的方式实现这一点，但实现这一点的最常用方法是为建议对象使用代理或包装器，允许根据需要调用建议。这是一种更灵活的方法，因为您可以根据数据在运行时应用不同行为的 AOP，这在静态 AOP 的情况下是不可能的。如果使用 XML 文件定义 AOP 结构（基于模式的方法），则无需重新编译主应用程序代码。动态 AOP 的缺点是，由于额外的运行时处理，性能损失可以忽略不计。

SpringAOP 是基于代理的，也就是说，它遵循 AOP 的动态风格。Spring 也通过与 AspectJ 集成提供了使用静态 AOP 的工具。

## AOP 概念和术语

理解 AOP 概念和术语为您提供了一个良好的 AOP 起点；它可以帮助您可视化 AOP 在应用程序中的应用方式和位置：

*   **方面**：跨越多个类或模块的关注点。事务和安全就是例子。Spring 事务作为方面实现。
*   **连接点**：程序执行期间的一个点，您希望在该点使用 AOP 插入附加逻辑。方法执行和类实例化是示例。
*   **通知**：方面（执行的代码或方法）在特定连接点采取的操作。不同类型的建议包括`before`、`after`和`around`建议。通常，一个方面有一个或多个建议。
*   **切入点**：定义或匹配一组连接点的表达式。与切入点关联的通知在其匹配的任何连接点执行。Spring 默认支持 AspectJ 切入点表达式语言。一个例子是`execution(* com.xyz.service.*.*(..))`。
*   **目标对象**：建议对象。如果使用动态 AOP，这将是一个代理对象。
*   **编织**：将方面插入到目标对象中，使其在编译时、加载时或运行时得到建议。AspectJ 在运行时支持编译时编织和 Spring 编织。
*   **简介**：向建议对象添加新方法或字段的过程，无论是否使其实现接口。

## Spring AOP–定义和配置样式

Spring 提供了纯 Java 开发的基于代理的 AOP 动态实现。它既不需要像 AspectJ 这样的特殊编译过程，也不控制类加载器层次结构，因此它可以部署在任何 Servlet 容器或应用程序服务器中。

尽管不像 AspectJ 那样是一个成熟的 AOP 框架，Spring 提供了一个简单易用的 AOP 大多数常见特性的抽象。它只支持方法执行连接点；未实施现场拦截。Spring 提供了与 AspectJ 的紧密集成，以防您希望通过添加更多 AspectJ 特有的特性而不破坏 Spring AOP 的核心 API 来建议 Spring AOP 无法涵盖的非常细粒度的方面定向。

SpringAOP 默认使用标准 JDK 动态代理进行方面定向。JDK 动态代理允许代理任何接口（或一组接口）。如果要代理类而不是接口，可以切换到 CGLIB 代理。如果目标对象没有实现接口，Spring 会自动切换到使用 CGLIB。

从 Spring2.0 开始，您可以采用基于模式的方法或`@AspectJ`注释样式来编写自定义方面。这两种风格都提供了全类型的建议和 AspectJ 切入点语言的使用，同时仍然使用 SpringAOP 进行编织。

## 基于 XML 模式的 AOP

当使用基于模式的 AOP 时，您需要将`aop`名称空间标记导入您的`application-context`文件中，如下所示：

```
<beans 
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop" 
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd">
<!-- bean definitions here -->
</beans>
```

## 基于 AOP 的@AspectJ 注释

`@AspectJ`将指的是一种风格，将方面声明为带注释的常规 Java 类。Spring 使用 AspectJ 提供的用于切入点解析和匹配的库来解释与 AspectJ 5 相同的注释。不过，SpringAOP 并不依赖 AspectJ 编译器或 weaver。

当使用`@AspectJ`注释样式时，您首先需要在 Spring 配置中启用`@AspectJ`支持，无论它是否在 XML 或 Java 配置中。此外，您需要确保在类路径中添加`aspectjweaver.jar`。在 Java`@Configuration`注释中添加`@EnableAspectJAutoProxy`注释将在项目中启用`@AspectJ`支持：

```
@Configuration
@ComponentScan(basePackages = "com.springessentialsbook")
@EnableAspectJAutoProxy
public class AOPJavaConfigurator {
...
}
```

或者，如果使用基于 XML 的配置，`@AspectJ`支持可以通过在`application-context`文件中添加`<aop:aspectj-autoproxy/>`元素来启用。

## 声明@Aspect 注释

你的相位是一个简单的 POJO，在你的`application-context`XML 文件的`<aop:config>`部分用`@Aspect`（`org.aspectj.lang.annotation.Aspect`注释或声明为`<aop:aspect/>`。记住，标记为`@Aspect`的类应该在应用程序上下文 XML 文件中使用注释或`<bean/>`声明声明声明为 Springbean。

这是一个被注释的方面，一个被注释为`@Aspect`的弹簧组件：

```
@Component("auditLoggerAspect")
@Aspect
public class AuditLoggerAspect {
...
}
```

注意，`@Aspect`也是一个弹簧豆。它可以是`@Component`的任何专业。

现在，让我们看一看 XML 声明的方面声明：

```
<aop:config>
   <aop:aspect id="audLogAspect" ref="auditLoggerAspect">
</aop:config>
<bean id="auditLoggerAspect" class="com...AuditLoggerAspect"/>
```

方面可能有方法和字段，就像任何其他类一样。它们还可能包含切入点、通知和介绍（类型间）声明。方面本身不能成为其他方面建议的目标；它们被排除在自动代理之外。

### 切入点

切入点由两部分组成，如下面的代码片段所示：一个方法签名（在`Aspect`类中有一个`void`返回类型的空方法）和一个与我们感兴趣的确切方法执行相匹配的表达式。记住，Spring AOP 只支持方法执行连接点：

```
@Pointcut("execution(* com.springessentialsbook.service.TaskService.createTask(..))") //Pointcut expression
private void createTaskPointCut() {} //Signature
```

切入点表达式遵循标准 AspectJ 格式。有关详细语法，您可以参考 AspectJ 切入点表达式参考。下面的部分为您构建 Spring AOP 的切入点提供了坚实的基础。

#### 切入点指示符

Spring AOP 仅支持在切入点表达式中使用的原始 AspectJ**切入点指示符**（**PCD**）的子集，如下表所示：

<colgroup><col> <col></colgroup> 
| 

PCD

 | 

描述

 |
| --- | --- |
| `execution` | 方法执行连接点；Spring AOP 的默认 PCD |
| `within` | 匹配一系列类型、包等中的方法 |
| `this` | 匹配给定类型的代理实例 |
| `target` | 将目标对象与给定类型匹配 |
| `args` | 将方法与给定的参数类型匹配 |
| `@target` | 匹配具有给定注释的类的方法 |
| `@args` | 将具有参数的方法与给定注释匹配 |
| `@within` | 匹配具有给定注释的类型中的方法 |
| `@annotation` | 将方法与给定注释匹配 |

除了上表中的之外，Spring 还支持一个额外的非 AspectJ PCD`bean`，这对于使用`bean(idsOrNamesOfBean)`直接引用一个 Spring bean 或一组具有逗号分隔的 bean 列表的 bean 非常有用。

注意，由于 SpringAOP 的代理性质，切入点只截取`public`方法。如果你想拦截 AutoT1 和 Ty2 T2 方法甚至构造函数，请考虑使用 AspectJ 编织（与 Spring 本身集成）。

#### 切入点示例

切入点表达式可以使用`&&`、`||`和`!`组合。您也可以按名称引用切入点表达式。让我们看几个例子：

```
@Pointcut("execution(* com.taskify.service.*.*(..))")
private void allServiceMethods() {}

@Pointcut("execution(public * *(..))")
private void anyPublicOperation() {}

@Pointcut("anyPublicOperation() && allServiceMethods()")
private void allPublicServiceMethods() {}

@Pointcut("within(com.taskify.service..*)")
private void allServiceClasses() {}

@Pointcut("execution(* set*(..))")
private void allSetMethods() {}

@Pointcut("execution(* com.taskify.service.TaskService.*(..))")
private void allTaskServiceMethods() {}

@Pointcut("target(com.taskify.service.TaskService)")
private void allTaskServiceImplMethods() {}

@Pointcut("@within(org.springframework.transaction.annotation.Transactional)")
private void allTransactionalObjectMethods() {}

@Pointcut("@annotation(org.springframework.transaction.annotation.Transactional)")
private void allTransactionalAnnotatedMethods() {}

@Pointcut("bean(simpleTaskService)")
private void allSimpleTaskServiceBeanMethods() {}
```

切入点定义的 XML 版本如下所示：

```
<aop:config>
  ...
   <aop:pointcut id="allTaskServicePointCut"
         expression="execution(*com.taskify.service..TaskService.*(..))"/>
</aop:config>
```

### 建议

通知是在切入点表达式匹配的方法执行之前、之后或周围注入的操作。与通知关联的切入点表达式可以是命名的或定义的切入点，如上述示例所示，也可以是就地声明的切入点表达式，即通知和切入点可以一起声明。

让我们看一个引用名为`Pointcut`的切入点表达式的通知示例：

```
@Pointcut("execution(* com.taskify.service.TaskService.*(..))")
private void allTaskServiceMethods() {}

@Before("allTaskServiceMethods()")
private void logBeforeAllTaskServiceMethods() {
  logger.info("*** logBeforeAllTaskServiceMethods invoked ! ***");
}
```

下面的代码清单一次性组合了连接点和通知。这是最常见的方法：

```
@After("execution(* com.taskigy.service.TaskService.*(..))")
private void logAfterAllTaskServiceMethods() {
  logger.info("***logAfterAllTaskServiceMethods invoked ! ***");
}
```

下表列出了可用的建议注释：

<colgroup><col> <col></colgroup> 
| 

通知注释

 | 

描述

 |
| --- | --- |
| `@Before` | 在方法执行之前运行。 |
| `@After` | 在方法退出后运行（最终）。 |
| `@AfterReturning` | 在方法返回后运行，无异常。您可以将返回值与作为方法参数的通知绑定。 |
| `@AfterThrowing` | 通过引发异常在方法退出后运行。可以将异常与通知绑定为方法参数。 |
| `@Around` | 目标方法实际上在这个通知中运行。它允许您在 Advice 方法中操纵方法的执行。 |

#### 周围的建议

`@Around`通知为您提供了对方法执行的更多控制，因为截获的方法基本上在您的通知方法内部运行。通知的第一个参数必须是`ProceedingJoinPoint`。您需要在通知体内部调用`ProceedingJoinPoint`的`proceed()`方法才能执行目标方法；否则，将不会调用该方法。在方法执行返回给您并返回给您的建议后，不要忘记在您的建议方法中返回结果。看一看样本`@Around`建议：

```
@Around("execution(* com.taskify.service.**.find*(..))")
private Object profileServiceFindAdvice(ProceedingJoinPoint jPoint) throws Throwable {
    Date startTime = new Date();
    Object result = jPoint.proceed(jPoint.getArgs());
    Date endTime = new Date();
    logger.info("Time taken to execute operation: " + jPoint.getSignature() + " is " + (endTime.getTime() - startTime.getTime()) + " ms");
    return result;
}
```

#### 访问通知参数

有两种不同的方式访问您在建议方法中建议的方法的参数：

*   将连接点声明为第一个参数
*   切入点定义中的绑定`args`

让我们看看第一种方法：

```
@Before("execution(* com.taskify.service.TaskService.createTask(..)")
private void logBeforeCreateTaskAdvice(JoinPoint joinpoint) {
   logger.info("***logBeforeCreateTaskAdvice invoked ! ***");
   logger.info("args = " + Arrays.asList(joinpoint.getArgs()));
}
```

您可以看到，`joinpoint.getArgs()`返回传递给截取方法的所有参数的`Object[]`。现在，让我们看看如何将命名参数绑定到 Advice 方法：

```
@Before("createTaskPointCut() and args(name, priority, createdByuserId, assigneeUserId)")
private void logBeforeCreateTaskAdvice(String name, int priority, int createdByuserId, int assigneeUserId) {

  logger.info("name = " + name + "; priority = " + priority + ";
  createdByuserId = " + createdByuserId);
}
```

注意，`joinpoint`表达式按名称匹配参数。您可以在方法签名中将`joinpoint`对象作为可选的第一个参数，而无需在表达式中指定它：您将同时拥有`joinpoint`和参数，从而实现更多的操作。

# 弹簧试验

可测试性的程度显示了任何框架的优雅和成熟。更易于测试的系统更易于维护。Spring 框架为单元测试和集成测试的应用程序端到端测试提供了全面的支持。Spring 促进了**测试驱动开发**（**TDD**），促进了集成测试，并为 bean 的单元测试倡导了一套最佳实践。这是使用 Spring 构建严肃应用程序的另一个令人信服的原因。

基于 Pojo 的编程模型和 Spring bean 的松散耦合性质使得即使没有中间的弹簧也能更容易地参与 JUnit 和 TestNG 测试。除此之外，Spring 还提供了许多测试支持组件、实用程序和模拟对象，以简化测试。

## 模拟对象

Spring 提供了许多特定于容器的组件的模拟实现，以便可以在服务器或容器环境之外测试 bean。`MockEnvironment`和`MockPropertySource`对于测试依赖于环境的 bean 非常有用。为了测试依赖 HTTP 通信的 bean，Spring 在`org.springframework.mock.http`和`org.springframework.mock.http.client`包中为客户端和服务器端提供了模拟类。

在`org.springframework.mock.jndi`下可以找到另一组有用的类来运行依赖于 JNDI 资源的测试套件。`org.springframework.mock.web`包包含基于 Servlet 3.0 的 web 组件的模拟对象，例如 web 上下文、过滤器、控制器和异步请求处理。

## 单元和集成测试实用程序

Spring 为单元和集成测试提供了某些通用和特定于上下文的实用程序。`org.springframework.test.util`包包含一组用于各种测试目的的实用程序类，包括反射、AOP、JSON 和 XML 操作。`org.springframework.test.web`及其嵌套子目录下的类包含一组全面的实用程序类，用于测试依赖于 web 环境的 bean。在`org.springframework.test.context`及其子包下可以找到另一组针对`ApplicationContext`特定用法的有用类。它们的支持包括在测试环境中加载和缓存 web、portlet 或应用程序上下文；解析剖面图；加载属性源和 SQL 脚本；管理测试环境的事务；等等

前面列出的包下的支持类和注释有助于轻松自然地测试 Spring 应用程序。关于 Spring 测试支持的全面讨论超出了本书的范围。然而，为了使用 Spring 开发优雅的代码和可维护的应用程序，深入了解 Spring 对单元和集成测试的全面支持是至关重要的。

# 总结

在本章中，我们成功地介绍了核心 Spring 框架的所有主要技术和概念。我们现在能够在强大的 SpringIOC 容器中开发由松散耦合的 bean 组成的健壮、独立的 Spring 应用程序。我们知道如何使用 SpringAOP 非常灵活的切入点表达式，透明地跨应用程序的不同层应用横切关注点。我们可以使用 SpringExpressionLanguage 操作 Springbean，这有助于保持代码的干净性和高度可维护性。我们学习了如何使用 bean 定义概要文件维护多个特定于环境的 bean 配置和属性文件。现在，我们都为专业的春季开发做好了准备。

本章提供的源代码包含多个 Spring 项目，这些项目演示了配置 Spring 的不同方法以及使用场景。本章中列出的示例是从中提取出来的。

在下一章中，我们将探讨 SpringWeb 模块，在基于 Web 的环境中利用我们在本章中学到的所有知识。我们在本章中所学的主题将是下面章节中将涵盖的所有高级主题的基础。