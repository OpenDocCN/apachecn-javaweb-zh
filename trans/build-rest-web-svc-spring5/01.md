# 一、一些基本知识

随着世界进入大数据时代，收集和处理数据已经成为我们大多数 web 应用程序的主要部分，web 服务也是如此，因为 web 服务只处理数据，而不处理用户体验、外观和感觉的其他部分。尽管用户体验对于所有 web 应用程序都非常重要，但 web 服务通过使用客户端的服务在处理数据方面发挥着重要作用。

在 web 服务的早期，**简单对象访问协议**（**SOAP**）是所有处理 web 服务消费的后端开发人员的默认选择。SOAP 主要用于 HTTP 和**简单邮件传输协议**（**SMTP**）中，用于跨相同或不同平台的消息传输。当 web 服务没有可用的**JavaScript 对象表示法**（**JSON**格式）时，XML 曾经是 SOAP 用于 web 服务消费的唯一可用格式。

然而，在 JSON 时代，**代表性状态转移**（**REST**）开始主导基于 web 服务的应用程序，因为它支持多种格式，包括 JSON、XML 和其他格式。REST 比 SOAP 简单，REST 标准易于实现和使用。另外，与 SOAP 相比，REST 是轻量级的。

在本章中，我们将介绍以下主题：

*   REST&一个基本的理解
*   反应式编程及其基础，包括反应式编程的好处
*   Spring5 基础知识与反应式编程
*   一个示例 RESTful web 服务，将用作本书其余部分的基础

# 休息——一种基本的理解

与流行的观点相反，REST 不是协议，而是管理状态信息的体系结构原则。它主要用于 web 应用程序。REST 由 royfielding 引入，以克服 SOAP 中的实现困难。Roy 的博士论文为检索数据提供了一种简便的方法，无论使用何种平台。在以下部分中，您将看到 RESTfulWeb 服务的所有组件。

# 均匀界面

在 REST 原则中，所有资源都由**统一资源标识符**（**URI**标识）。

HTTP REST 资源以一些媒体类型表示，如 XML、JSON 和 RDF。另外，RESTful 资源是自描述性的，这意味着提供了足够的信息来描述如何处理请求。

在另一个 REST 原则中，客户端通过服务器动态提供的超媒体与服务器交互。除了端点，客户机不需要知道如何与 RESTful 服务交互。此原理称为**超媒体作为应用状态**（**HATEOAS**的引擎。

# 客户端和服务器

通过分离 REST 实体（如客户端和服务器），我们可以降低 REST 原则的复杂性，这将显示服务器和客户端之间的清晰边界。这种分离将帮助开发人员独立地专注于客户机和服务器。此外，它还有助于管理客户端和服务器的不同角色。

# 无国籍

在 REST 原则中，服务器不会在服务器端保留关于客户端会话的任何状态；因此，它是无状态的。如果从一个客户端向服务器发出两个调用，服务器将无法识别这两个调用是否来自同一个客户端。就服务器所知，每个请求都是独立的和新的。根据 URL、HTTP 头和请求体（包括参数），可以在服务器端更改操作。

# 可缓存

使用 RESTfulWeb 服务，客户机可以缓存来自服务器的任何响应。服务器可以说明如何缓存响应，以及可以缓存多长时间。通过缓存选项，客户端可以使用响应，而不是再次联系服务器。此外，缓存将通过始终避免客户端-服务器交互来提高可伸缩性和性能。

这一原则在可伸缩性方面具有显著优势。缓存技术将在[第 8 章](08.html)、*性能*中讨论。

由于 REST 通常利用 HTTP，因此它继承 HTTP 提供的所有缓存属性。

# 分层系统

通过提供分层系统，服务器可以隐藏其身份。通过这样做，客户机将不知道他们正在处理的是哪台服务器。此策略通过提供中间服务器提供更多安全控制，并支持负载平衡功能。此外，中间服务器还可以通过负载平衡和共享缓存提高可伸缩性和性能。

# 按需编码（COD）

**按需编码**（**COD**视为可选原则。服务器可以通过传输可执行代码来扩展客户端的功能。例如，可以向基于 web 的客户端提供 JavaScript 来定制功能。由于按需编码降低了客户端的可见性，因此此约束是可选的。此外，并非所有 API 都需要此功能。

# 更多关于休息

在 web 应用程序中，REST 通常通过 HTTP 使用。REST 不需要绑定到任何特定的协议。在 HTTP REST 中，我们主要使用`GET`、`POST`、`PUT`和`DELETE`方法来更改我们访问的资源的状态。其他 HTTP 方法，如`OPTIONS`、`HEAD`、`CONNECT`和`TRACE`可用于更高级的操作，例如缓存和调试目的。大多数服务器出于安全和简单的原因禁用了高级方法；但是，您可以通过调整服务器配置文件来启用它们。由于 JSON 被用作主要应用程序的主要媒体类型，因此我们也只在 web 服务调用中使用 JSON 媒体类型。

# 命令式和反应式编程

让我们看看命令式编程和反应式编程之间的一个小比较：*x=y+z。*

在前面的表达式中，假设*y=10*和*z=15*。在这种情况下，*x*值将是*25*。将在表达式*x=y+z*时分配*x*的值。*x*的值在该表达式之后不会改变。

这在传统编程世界中是完全正确的。但是，我们可能需要一个场景，在该场景中，当我们更改*y*或*z*的值时，我们应该能够跟踪*x*。

我们新的基于情景的价值观是：

*   当*y=20*和*z=15 时，*则*x=35*
*   当*y=20*和*z=25 时，*则*x=45*

前面的场景在命令式编程中是不可能的，我们经常在日常编程中使用命令式编程。但在某些情况下，我们可能需要更新*x*的值，对应于*y*或 z 的变化。反应式编程是这个场景的完美解决方案。在反应式编程中，*x*的值会自动更新，对应于*y*或*z*的变化。

电子表格参考单元格是反应式编程的最佳示例。如果单元格值发生更改，则引用的单元格值将自动更新。另一个例子可以在模型-视图-控制器体系结构中找到，反应式编程可以自动更新连接到模型的视图。

反应式编程遵循观察者模式来操作和转换数据流，其中发布者（可观察者）根据订阅者的需要发出项目。当发布者发出项目时，订阅者将使用发布者发出的项目。与迭代器拉取项目不同，在这里，发布者将项目推送到订阅者。

由于反应式是非阻塞体系结构的一部分，因此当我们扩展应用程序时，它将非常有用。此外，在非阻塞体系结构中，所有内容都被视为事件流。

在本章后面，我们将进一步讨论 Java 和 Spring 中的 Reactive。

# 反应流

反应流都是关于处理数据项的异步流，应用程序在接收数据项时对其作出反应。此模型的内存效率更高，因为它不依赖任何内存中的数据。

反应流有四个主要组成部分：

1.  出版商
2.  订阅人
3.  订阅
4.  加工机

发布者发布订阅服务器异步订阅的数据流。处理器转换数据流，而无需更改发布服务器或订阅服务器。处理器（或多个处理器）位于发布服务器和订阅服务器之间，用于将一个数据流转换为另一个数据流。

# 反应式编程的好处

Netflix、Pivotal、Twitter、Oracle 和 TypeSafe 的工程师支持反应流方法。特别是，TypeSafe 对反应流的贡献更大。就连 Netflix 的工程师也用自己的话说：

“使用 RxJava 的反应式编程使 Netflix 开发人员能够利用服务器端并发性，而不必担心典型的线程安全和同步问题。”

以下是反应式编程的好处：

*   关注业务逻辑
*   流处理会提高内存效率
*   克服了低级线程、同步和并发问题

反应式原则用于实时情况，如实时数据库查询、大数据、实时分析、HTTP/2 等。

# Java 和 Spring5 中的反应式编程

Netflix 工程师引入 RxJava，以支持 Java8 中的反应式模型，并提供到反应式流的桥接。然而，Java 开始用 Java9 支持反应式模型，反应式流已经作为 Java9 中的`java.util.concurrent.Flow`被合并到 JDK 中。

此外，Pivotal 还介绍了反应器框架，该框架直接构建在反应流上，避免了反应流的外部桥接。反应器被视为第*4<sup>第</sup>代*库。

最后，SpringFramework5.0 添加了内置的反应式功能，包括 HTTP 服务器和客户端工具。Spring 用户在处理 HTTP 请求时会发现注释和控制器非常方便，特别是在向框架发送响应请求和背压问题时。

反应式模型在资源利用率方面似乎很有效，因为它可以用更少的线程处理更高的负载。然而，反应式模型可能不是所有问题的正确解决方案。在某些情况下，如果我们在错误的区域使用Reactor，情况可能会变得更糟。

# 我们的 RESTful web 服务体系结构

由于我们假设读者熟悉 Spring 框架，我们将直接关注我们将要构建的示例服务。

在本书中，我们将构建一个**票务管理系统**。为了清楚地了解票证管理系统以及如何使用它，我们将提出一个场景。

假设我们有一个由客户 Peter 和 Kevin 使用的银行 web 应用程序，我们的管理员 Sammy 和**客户服务代表**（**CSR**）Chloe 在出现任何银行应用程序问题时提供帮助。

如果 Kevin/Peter 在 web 应用程序中遇到问题，他们可以在我们的票证管理系统中创建票证。此票证将由管理员处理并发送给 CSR，后者负责处理票证。

CSR 从用户处获得更多信息，并将信息转发给技术团队。一旦 CSR 解决了问题，他们就可以解决问题。

在我们的票证管理系统中，我们将使用以下组件：

| **票** | 

*   `ticketid`
*   `creatorid`

*   `content`
*   `severity`(轻微、正常、重大、严重）
*   `status`(开放、进行中、解决、重新开放）

 |
| **用户** | 

*   `userid`
*   `username`
*   `usertype`(管理员、一般用户、企业社会责任]

 |

在本票务管理系统中，我们将重点关注：

1.  由用户创建票证。
2.  用户正在更新票据。
3.  管理员正在更新票据状态。
4.  由 CSR 更新票证状态。
5.  由用户和管理员删除票据。

在最初的几章中，我们将讨论用户管理，以便在处理 AOP、SpringSecurity和 WebFlux 等主题时简化业务逻辑。但是，我们将在[第 13 章](13.html)、*票务管理-高级 CRUD*中讨论票务管理系统，并实现前面提到的所有业务需求。在[第 13 章](13.html)*票务管理-高级 CRUD*中，您将使用其他章节中使用的所有高级技术来完成我们的业务需求。

# 总结

到目前为止，我们已经学习了 REST 和反应式编程的基础知识以及反应式流的必要性。我们已经在Reactor的支持下度过了春天 5 号。此外，我们还定义了将在本书其余部分中使用的业务示例和体系结构。

在下一章中，我们将讨论使用 Maven 和简单 RESTAPI 创建简单项目。此外，我们还将讨论 Maven 文件结构和依赖关系，包括示例。