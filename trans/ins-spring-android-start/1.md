# 第一章安卓启动器瞬间弹簧

欢迎来到 Android 初学者的即时*春季。这本书专门为您提供了使用 Spring for Android 简化 Android 开发所需的所有信息。您将学习 Spring 为 Android 提供的不同功能，并开始使用这些功能构建您的第一个应用程序。*

本书包含以下章节：

*那么，Android 的春天是什么？*描述了 Spring for Android 对 Spring 框架的扩展，有助于简化本机 Android 应用程序的开发；它目前（版本 1.0.0.RELEASE）具有 REST 客户端（RestTemplate）和 OAuth 支持（SpringSocial）。

*将其集成到 Android 应用程序*教授如何将 Spring for Android 与 Eclipse IDE 和 ADT（Android 开发工具）以及 Maven 集成。

*快速入门–Rest 模板*将向您展示如何在 Android Rest 模板模块中使用 Spring 的一些核心功能；例如，创建一个 REST 客户机。在本节结束时，您将能够使用消息转换器和/或 HTTP 基本身份验证检索、更新、创建和删除 REST 资源。

*快速入门–OAuth*将向您展示如何在 Android Auth 模块中使用 Spring 的一些核心功能；例如，创建到 Google+的 OAuth 连接以读取用户配置文件。在本节结束时，您将能够建立 OAuth 连接来验证您的用户和应用程序。

*你应该了解的人和地方*——每个开源项目都以社区为中心。本节为您提供了许多有用的项目页面和论坛链接，以及一些有用的文章、教程和博客，此外还有针对 Android 超级贡献者的 Spring 推特提要。

# 那么，Android 的春天是什么？

在第一节中，我们将介绍 Android 版 Spring 的主要方面：`RestTemplate`、`Auth`以及 Android 版 Spring 的不同之处。

## REST 模板

`RestTemplate`模块是基于 Java 的 REST 客户端`RestTemplate`的一个端口，它最初出现在 2009 年春季的 MVC 上。与其他 Spring 模板对应物（`JdbcTemplate`、`JmsTemplate`等）一样，它的目标是为 Java 开发人员（以及 Android 开发人员）带来底层 javaapi 的高级抽象；在这种情况下，它简化了 HTTP 客户端的开发。

在 Android 版本中，`RestTemplate`依赖于核心 Java HTTP 设施（`HttpURLConnection`或 Apache HTTP 客户端。根据您运行应用程序时使用的 Android 设备版本，`RestTemplate`for Android 可以为您选择最合适的版本。这是根据安卓开发者的建议。

### 注

参见[http://android-developers.blogspot.ca/2011/09/androids-http-clients.html](http://android-developers.blogspot.ca/2011/09/androids-http-clients.html) 。这篇博文解释了为什么在某些情况下，Apache HTTP 客户端比`HttpURLConnection`更受欢迎。

`RestTemplate`for Android 还支持 gzip 压缩和不同的消息转换器，以将 Java 对象转换为 JSON、XML 等。

## 认证/春季社交

Spring Android`Auth`模块的目标是让 Android 应用程序通过**OAuth**（版本 1 或 2）获得对 web 服务提供商的授权。

OAuth 可能是最流行的授权协议（值得一提的是，它是一个开放标准），目前 Facebook、Twitter、Google 应用程序（以及许多其他应用程序）都使用 OAuth 来允许第三方应用程序访问用户帐户。

Spring for Android`Auth`模块基于多个 Spring 库，因为它需要安全地（通过加密）持久化（通过 JDBC）通过 HTTP 获得的令牌；以下是 OAuth 所需库的列表：

*   **Spring 安全加密**：对令牌进行加密
*   **Spring Android OAuth**：这扩展了`Spring Security Crypto`为 Android 添加了一个专用的加密程序，以及基于 SQLite 的持久性提供程序
*   **Spring Android Rest 模板**：与 HTTP 服务交互
*   **Spring 社会核心**：OAuth 工作流抽象

在执行 OAuth 工作流时，我们还需要浏览器将用户带到服务提供商身份验证页面，例如，以下是 Twitter OAuth 身份验证对话框：

![Auth/Spring Social](graphics/1905_01_02.jpg)

## Android 的春天不是什么

SpringSource（Android 的 Spring 背后的公司）在 Java 开发人员中非常有名。他们最流行的产品是 SpringFramework for Java，它包括一个依赖注入框架（也称为控制反转框架）。springforandroid 不会给 Android 平台带来控制反转。

在其第一个版本（1.0.0.M1）中，Spring for Android 为 Android 带来了一个通用的日志外观；作者在下一版本中将其删除。

# 将其集成到 Android 应用程序中

springforandroid 包含在多个 JAR 库中，这些 JAR 库应该链接到项目。这些 JAR 库不是标准 Android 发行版的一部分。例如，我们需要以下 JAR 库来使用 Spring For Android 的 JSON REST API`RestTemplate`：

![Integrating it in an Android app](graphics/1905_02_01.jpg)

## 添加或使用 RestTemplate 的最小依赖项

您可以使用 IDE 手动满足依赖项（及其可传递依赖项）。手动依赖关系管理的替代方案是使用**Maven**自动构建项目。我们将在本节后面解释 Maven building。

## Android 的 Eclipse 和 Spring 入门

Eclipse 无疑是开发 Android 应用程序最流行的 IDE；之所以如此，原因之一是由谷歌维护的**Android 开发工具**（**ADT**）提供了 Eclipse 插件以简化 Android 开发（调试器、自定义 XML 编辑器等）。

### 注

IntelliJ IDEA 社区版为 Android 提供开箱即用的支持；Netbeans 还允许您安装`nbandroid`插件，以促进 Android 应用程序的开发。

我们需要执行以下步骤来开始使用 Eclipse：

1.  从[下载最新版本 http://www.eclipse.org/downloads](http://www.eclipse.org/downloads) （ADT 与 3.6.2 版的 Eclipse 兼容；在撰写本文时，4.2 Juno 是最新版本）。与其他可用版本相比，更喜欢用于 Java 开发人员的*EclipseIDE*。
2.  一旦你下载并解包到你的机器上，启动它。选择一个工作区位置（您的项目所在地）并安装 ADT 插件：点击**帮助****Eclipse Marketplace。。。**并在文本框中输入**adt**（如下图所示），然后按*回车*；现在点击**安装**按钮，选择**Android Eclipse 开发工具**。

### 注

您不必选择 NDK 支持特性，它支持自原生 Android 开发（使用 C 或 C++语言），因为 Spring 对于 Android 库来说是 java 唯一的库。

![Getting started with Eclipse and Spring for Android](graphics/1905_02_02.jpg)

### 安装 ADT 插件

Eclipse 将多次提示您有关许可证的信息，并最终要求您重新启动许可证。

1.  When you're back in your workspace, make sure you have an (up-to-date) Android SDK installed on your machine: click on the icon with an Android robot coming out of a box, and install or update the Android SDK (you don't need all Android versions, you can just install the most popular ones such as 2.2 aka Froyo, 2.3.3 aka Gingerbread, 4.0.3 aka Ice Cream Sandwich and 4.1 aka Jelly Bean); restart Eclipse when you're done.

    ![Installing the ADT plugin](graphics/1905_02_03.jpg)

    Android SDK 管理器用于管理 Android 工具和平台

2.  If you haven't done so already, you also need to create an **Android Virtual Device** (**AVD**) so that you can deploy your Android apps to it (you could also connect your phone or tablet via USB to deploy your apps on it); for that matter, click on the icon representing an Android robot in a device screen and create a new AVD, as shown in the following screenshot:

    ![Installing the ADT plugin](graphics/1905_02_04.jpg)

    创建新的 AVD

    ### 注

    有关 ADT 插件的更多详细信息，请访问官方网站：[http://developer.android.com/tools/sdk/eclipse-adt.html](http://developer.android.com/tools/sdk/eclipse-adt.html) 。

3.  We finally need to download the Spring for Android JARs, go to the Spring for Android website: [http://www.springsource.org/spring-android](http://www.springsource.org/spring-android) and click on the **Download** button (you can skip the registration in the following screen). Now choose the latest Spring for Android release (at the time of writing: 1.0.1.RELEASE) and unzip it on your machine; we will need the libraries in the next step:

    ![Installing the ADT plugin](graphics/1905_02_04_bis.jpg)

    Android 的 Spring 官方下载页面

### 第一个示例应用程序

现在，我们准备使用 Spring for Android 创建我们的第一个应用程序：

1.  Click on **File** | **New...** | **Android Application**, give your project name and accept the defaults in the following dialogs:

    ![First example app](graphics/1905_02_05.jpg)

2.  A new window named **New Android Application** will pop up, as shown in thefollowing screenshot:

    ![First example app](graphics/1905_02_05.jpg)

    从 Eclipse 创建 Android 应用程序

3.  When asked for a new activity, choose the default **BlankActivity**, as shown in the following screenshot:

    ![First example app](graphics/1905_02_05-bis.jpg)

4.  Now copy the JARs `spring-android-core-{version}.jar` and `spring-android-rest-template-{version}.jar` from the Spring for Android ZIP file you downloaded before, to the `$Project_home/libs` folder of your new project; you should have the following project structure:

    ![First example app](graphics/1905_02_06.jpg)

    第一个示例应用程序

5.  For this first sample app to use Spring for Android to request a web service (we will use [http://ifconfig.me/all](http://ifconfig.me/all)), we will just need to perform a `GET` method on this URL and we will receive the client info: IP, User Agent, and so on. We will then need to declare our intention to access the network. This works by adding the following `permission` tag just before the `application` tag in the Android manifest file:

    ```
    (...)<uses-sdk
            android:minSdkVersion="8"
            android:targetSdkVersion="15" />
    <uses-permission android:name="android.permission.INTERNET"/>
    <application (...)
    ```

    ### 提示

    Android 清单位于项目的根目录下：`AndroidManifest.xml`。

    忘记这样做会导致日志 cat 视图（所有日志都收集在该视图中）中出现模糊消息，如`Fatal Exception`；参见[http://developer.android.com/guide/topics/security/permissions.html](http://developer.android.com/guide/topics/security/permissions.html) 了解有关权限的更多信息。

    HTTP 协议定义了方法或动词，以指示要在远程资源上执行的操作：`GET`获取资源、`POST`存储资源、`PUT`更新资源、`DELETE`删除资源都是 HTTP 动词的示例，您可以通过阅读本文了解更多关于它们的信息： [http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol](http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) 。

6.  Then, we adjust the activity layout by removing the default "hello world" (`android:text="@string/hello_world"`) and replacing it by an anchor that we will use to print the response of the web service (`android:id="@+id/hello_text"`):

    ```
    <RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        android:layout_width="match_parent"
        android:layout_height="match_parent" >
        <TextView
            android:id="@+id/result_text"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_centerHorizontal="true"
            android:layout_centerVertical="true"
            tools:context=".MainActivity" />
    </RelativeLayout>
    ```

    活动布局位于`res/layout/activity_main.xml`处。

7.  Finally, we can rework `MainActivity` itself (only the `onCreate()` method needs to be updated):

    ```
      @Override
      public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        final TextView resultTextView = 
                (TextView) findViewById(R.id.result_text);
        AsyncTask<String, Void, String> simpleGetTask =  
                    new AsyncTask<String, Void, String>() {
          @Override
          protected String doInBackground(String... params) {
            //executed by a background thread

           //create a new RestTemplate instance
            RestTemplate restTemplate = new RestTemplate();

            //add the String message converter, since the result of
                 // the call will be a String
            restTemplate.getMessageConverters().add(
                         new StringHttpMessageConverter());

            // Make the HTTP GET request on the url (params[0]),
                 // marshaling the response to a String
            return
                    restTemplate.getForObject(params[0],String.class);
            }

          @Override
          protected void onPostExecute(String result) {
            // executed by the UI thread once the background 
                 // thread is done getting the result
            resultTextView.setText(result);
          }
        };
        String url = "http://ifconfig.me/all";
        // triggers the task; it will update the resultTextView once
          // it is done
        simpleGetTask.execute(url);
      }
    ```

    ### 注

    如果 Eclipse 投诉缺少导入，请同时按*Shift*+*Ctrl*+*O*自动添加所需的导入。

    在这个片段中，我们首先获得了对`result_text`文本视图的引用，并将其设置为名为`resultTextView`（`final`的`final`变量，因为我们需要通过内部类访问它）。

    接下来，我们创建了一个匿名内部类，扩展了`AsyncTask`来实现命中 web 服务的所有逻辑（创建`RestTemplate`实例，添加`String`转换器，调用`getForObject`，并将结果设置到文本视图（使用`setText`方法）。当我们调用`simpleGetTask.execute(url)`时，URL 被添加到`doInBackground(String... params)`中的参数数组中（所以在本例中`params[0]`是`url`。

    ### 注

    如果我们直接编写代码，在`onCreate()`方法中命中 web 服务，应用程序甚至无法启动，因为 Android 平台阻止开发人员在 UI（主）线程中执行 HTTP 请求（有一个很好的理由：那些与网络相关的操作通常需要时间才能完成，并且在操作进行时会冻结 UI）。

    ```
    @Override
    public void onCreate(Bundle savedInstanceState) {
     TextView resultTextView = (TextView) findViewById(R.id.result_text);
     String url = "http://ifconfig.me/all";
     RestTemplate restTemplate = new RestTemplate();
     RestTemplate.getMessageConverters().add(new  StringHttpMessageConverter());
     String result = restTemplate.getForObject(url, String.class);
     resultTextView.setText(result);
    }
    ```

    ### 提示

    不要这样做！无法从 UI（主）线程执行 HTTP 相关调用。

    ### 注

    有关`AsyncTasks`的更多信息，请参见官方文件：[http://developer.android.com/reference/android/os/AsyncTask.html](http://developer.android.com/reference/android/os/AsyncTask.html) 以及 Android 中的线程和进程：[http://developer.android.com/guide/components/processes-and-threads.html](http://developer.android.com/guide/components/processes-and-threads.html) 。

8.  We are now ready to launch this first Spring for Android based app!

    右键单击项目名称并选择**运行方式。。。****安卓应用**：

    ![First example app](graphics/1905_02_06-bis.jpg)

9.  Eclipse will start your previously created AVD and will automatically run the app, you should see something similar to the following screenshot:

    ![First example app](graphics/1905_02_07.jpg)

    AVD 中的 MainActivity 屏幕截图

祝贺您已经成功运行了第一个基于 Android 的 Spring 应用程序！

## 使用 Maven 为 Android 应用程序构建 Spring

在前面的示例中，我们只向`libs`文件夹添加了两个 JAR；但是，如果您需要其他依赖项，例如`MessageConverters`（解组 JSON、XML 响应）、`Auth`模块或项目中的任何其他现有库，那么管理依赖项很快就会成为一个负担！

Maven 可以帮助您管理依赖项（简而言之，您在一个名为`pom.xml`的文件中指定它们，它将自动从 Internet 获取它们，包括它们的可传递依赖项）以及更多：发布操作、测试运行、头生成，等等。Maven 是一个模块化的开源构建工具，包含大量插件！

### 注

当使用 Android Maven 插件时，您应该向您的环境中添加以下变量`ANDROID_HOME`（链接您的 Android 主目录），并将`ANDROID_HOME/platform-tools`添加到您的路径中。这在[中有详细说明 https://code.google.com/p/maven-android-plugin/wiki/GettingStarted](https://code.google.com/p/maven-android-plugin/wiki/GettingStarted) 。

首先，让我们将**m2e**（Maven To Eclipse）插件添加到 Eclipse 中：就像我们对 ADT 插件所做的那样，打开**帮助****Eclipse**市场并搜索**Maven**；选择**Maven Integration for Eclipse**，点击**安装**确认对话框；在进程结束时重新启动 IDE。

![Using Maven to build a Spring for Android app](graphics/1905_02_08.jpg)

为 Eclipse 安装 Maven 集成

现在将名为`spring-for-android-first-example-maven`的项目导入您的工作区：您可以从 GitHub 克隆它，也可以解压`examples.zip`归档文件；然后，在 Eclipse 中点击**文件****导入……**并选择**现有 Maven 项目**，点击**下一步**。

![Using Maven to build a Spring for Android app](graphics/1905_02_09.jpg)

导入现有 Maven 项目

浏览到克隆或解压项目的目录，点击**下一步**按钮：

![Using Maven to build a Spring for Android app](graphics/1905_02_10.jpg)

浏览到您的 maven 项目

M2e 将向您显示将基于 Maven 的项目集成到 IDE 中所需的 M2e 连接器列表（基本上，这些连接器告诉 M2e 如何生成和编译源代码）；点击**完成**并接受以下对话框；重新启动 Eclipse。

### 注

这里最重要的连接器是 m2e android 连接器：它使 m2e 能够与 ADT 集成，更多信息参见[http://rgladwell.github.com/m2e-android/](http://rgladwell.github.com/m2e-android/) 。

该项目应该可以很好地导入，并且您可以使用与上一个项目相同的方式在 AVD 上部署该项目（右键单击该项目，然后选择**作为****Android 应用程序**运行）。

让我们看一下`pom.xml`文件（与上一个项目相比唯一的附加文件），右键单击该文件并选择**打开并使用……****Maven POM 编辑器**；单击视图底部的**pom.xml**选项卡。

```
(...)<dependencies>
        <dependency>
            <groupId>com.google.android</groupId>
            <artifactId>android</artifactId>
            <version>4.0.1.2</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
          <groupId>org.springframework.android</groupId>
          <artifactId>spring-android-rest-template</artifactId>
          <version>${spring-android-version}</version>
        </dependency>
    </dependencies>
    <build>
        <finalName>${project.artifactId}</finalName>
        <sourceDirectory>src</sourceDirectory>
        <plugins>
            <plugin>
        <groupId>com.jayway.maven.plugins.android.generation2</groupId>
                <artifactId>android-maven-plugin</artifactId>
                <version>3.3.0</version>
                <extensions>true</extensions>
                <configuration>
                    <sdk>
                        <!-- platform or api level (api level 4 = platform 1.6)-->
                        <platform>15</platform>
                    </sdk>
                </configuration>
            </plugin>
        </plugins>
    </build>(...)
```

您可以在依赖项部分看到；Android 平台和 Spring for Android`RestTemplate`工件（无需为 Android core 指定 Spring！记住，Maven 会自动获取可传递的依赖项）以及插件部分中的 Android Maven 插件（由于`extensions=true`属性，它扩展了 Maven for Android 项目），配置为需要 Android 4.0.3（API 等级 15）。

Maven 的核心是一个命令行工具，如果您在机器上下载并解压缩 Maven，您可以转到 Maven 项目的根目录（其中`pom.xml`驻留），并键入具有不同目标的 Maven 命令：

*   `mvn clean install`：编译、运行测试和打包
*   `mvn clean install android:run`：在 AVD 中启动应用程序

### 注

要查看所有可用的目标，您可以键入`mvn help:describe -Dplugin=com.jayway.maven.plugins.android.generation2:maven-android-plugin`。

您还可以从 Eclipse 内部模拟命令行 Maven，右键单击项目并选择**以**运行**Maven build。。。**，并指定您的目标。

Maven 安装说明可在线找到：[http://www.sonatype.com/books/mvnref-book/reference/installation-sect-maven-install.html](http://www.sonatype.com/books/mvnref-book/reference/installation-sect-maven-install.html) 。

要了解更多关于 Maven 的信息，我强烈建议您阅读免费的在线 Maven 书籍[http://www.sonatype.com/books/mvnref-book/reference/](http://www.sonatype.com/books/mvnref-book/reference/) 甚至有一个特定的安卓章节。

现在，我们准备为基于 Android 的应用程序开发一些更丰富的 Spring！

# 快速启动–REST 模板

现在我们的工作区已经建立，我们已经成功部署了第一款基于 Android`RestTemplate`的 Spring 应用程序，让我们来探索`RestTemplate`的更多功能。

本节依赖于几个示例应用程序。我们将讨论每个代码示例的所有要点。可以将项目导入 IDE 并浏览代码。

### 注

从现在起，我将使用 Maven 来管理依赖项，但您不必这样做。每个项目的`README.md`文件中都有一个依赖项列表：下载它们（或从 Spring for Android ZIP archive`libs`文件夹中获取），然后将它们添加到`libs`文件夹中！

## 不同的消息转换器

在上一节中，我们已经使用了一个消息转换器：`StringHttpMessageConverter`。每个消息转换器支持读取和写入某些媒体类型（通常称为 MIME 类型）；`StringHttpMessageConverter`支持读取各种文档（MIME*/*）和写入文本（MIME text/plain）。让我们来了解更复杂的消息转换器。

### 注

**MIME**（**多用途互联网邮件扩展**），不仅用于描述电子邮件内容，还广泛用于描述通过 HTTP 交换的文档内容（[http://en.wikipedia.org/wiki/MIME](http://en.wikipedia.org/wiki/MIME) ）。

### 映射 JacksonHttpMessageConverter

JSON 消息在 RESTWeb 服务中非常常见。最初设计用于 JavaScript 语言（`JavaScriptObjectNotation`）；它们是轻量级的，也是可读的。

`Ifconfig.me`可以返回 JSON 响应，如果您使用此 URL:[http://ifconfig.me/all.json](http://ifconfig.me/all.json) 。

在我们第一个示例中的代码中，让我们将`StringHttpMessageConverter`替换为`MappingJacksonHttpMessageConverter`：

```
AsyncTask<String, Void, IfConfigMeJson> simpleGetTask =  
  new AsyncTask<String, Void, IfConfigMeJson>() {
  @Override
  protected IfConfigMeJson doInBackground(String... params) {
    String url = params[0];
    RestTemplate restTemplate = new RestTemplate();
    MappingJacksonHttpMessageConverter jacksonConverter = 
         new MappingJacksonHttpMessageConverter();
    restTemplate.getMessageConverters().add(jacksonConverter);
    return restTemplate.getForObject(url,
           IfConfigMeJson.class);
  }

  @Override
  protected void onPostExecute(IfConfigMeJson result) {
    String resultAsString =  new StringBuilder()
                      .append("Your current IP is : ")
                      .append(result.getIpAddr()).toString();
    resultTextView.setText(resultAsString );
  }

};

String url = "http://ifconfig.me/all.json";
//triggers the task
simpleGetTask.execute(url);
```

如您所见，我们还引入了一个名为`IfConfigMeJson`的模型类：该类定义了 JSON 消息属性（`{"connection":"keep-alive","ip_addr":"70.30.43.43", [..]}`和**POJO**（**普通旧 Java 对象**：一个带有成员变量及其访问器的简单类）之间的映射，以便我们可以轻松访问响应的每个属性（在下面的示例中：`result.getIpAddr()`）在我们的 Java 代码中：

```
public class IfConfigMeJson {
  private String connection;
  @JsonProperty("ip_addr")
  private String ipAddr;
  public String getConnection() {
    return connection;
  }
  public void setConnection(String connection) {
    this.connection = connection;
  }
  public String getIpAddr() {
    return ipAddr;
  }
  public void setIpAddr(String opAddr) {
    this.ipAddr = opAddr;
  }
```

### 注

Jackson 会自动将 JSON 属性与 Java 字段匹配，只要它们的名称相同（Java 中的 CamelCase，JSON 中的下划线）。您肯定已经注意到，我们将 JSON 属性`ip_addr`映射到字段`ipAddr`，以遵守 Java 命名约定，这要感谢 Jackson 在字段定义之前的`@JsonProperty`注释。另一方面，我们可以将类的字段声明为 public，并删除访问器。

运行应用程序时，您将只看到以下屏幕截图：

![MappingJacksonHttpMessageConverter](graphics/1905_03_01.jpg)

使用`MappingJacksonHttpMessageConverter`的应用程序

在本节中，我们在`pom.xml`文件中向`jackson-mapper-asl`添加了一个依赖项：

```
<dependency>
<groupId>org.codehaus.jackson</groupId>
  <artifactId>jackson-mapper-asl</artifactId>
  <version>${jackson-version}</version>
</dependency>
```

### 注

还有另一个可用的 JSON 消息转换器，`GsonHttpMessageConverter`，使用 Google Gson 库而不是 Jackson，可以替代使用。

### SimpleXmlHttpMessageConverter

另一个值得一提的消息转换器是`SimpleXmlHttpMessageConverter`：它将 XML 响应和请求映射到 POJO，与`MappingJacksonHttpMessageConverter`处理 JSON 的方式相同。

例如，让我们请求`Ifconfig.me`XML 服务：[http://ifconfig.me/all.xml](http://ifconfig.me/all.xml) 。

在前面示例中的`MainActivity`类中，让我们将`MappingJacksonHttpMessageConverter`替换为`SimpleXmlHttpMessageConverter`：

```
AsyncTask<String, Void, IfConfigMeXml> simpleGetTask =  
   new AsyncTask<String, Void, IfConfigMeXml>() {
   @Override
   protected IfConfigMeXml doInBackground(String... params) {
      String url = params[0];
RestTemplate restTemplate = new RestTemplate();
      SimpleXmlHttpMessageConverter xmlConverter = 
           new SimpleXmlHttpMessageConverter();
      restTemplate.getMessageConverters().add(xmlConverter);
      return restTemplate.getForObject(url, IfConfigMeXml.class);
   }

   @Override
   protected void onPostExecute(IfConfigMeXml result) {
       String resultAsString =  new StringBuilder()
                  .append("Your current IP is : ")	
                  .append(result.getIpAddr()).toString();
       resultTextView.setText(resultAsString );
   }

};

String url = "http://ifconfig.me/all.xml";

```

您会再次注意到，我们依赖一个名为`IfConfigMeXml.java`的类来允许`SimpleXml`在 XML 响应和 Java 代码之间进行映射。以下是 XML 响应：

```
<info>
<forwarded/>
<ip_addr>70.43.43.43</ip_addr>
[...]
</info>
```

以下是 Java 代码：

```
@Root (name="info")
public class IfConfigMeXml {

  @Element(required=false)
  private String forwarded;

  @Element(name="ip_addr")
  private String ipAddr;
  [...]
}
```

注释与我们用于 JSON 消息转换器的注释类似。

`@Root`注释定义了根 XML 标记的名称：`info`在本例中。

在每个字段之前添加`@Element`注释，让`SimpleXml`知道这些字段映射到 XML 标签：如果`required`设置为 false，则表示标签可以为空；如果指定了`name`，则表示 POJO 字段与 XML 标记名不匹配。

如果您运行应用程序，您将获得与前面示例中完全相同的输出。

### 注

在本节中，我们向`SimpleXml`框架添加了一个依赖项。不幸的是，这种依赖关系具有到 stax 和 xpp3 的可传递依赖关系，而 Android 应用程序不需要这些依赖关系。

我们必须显式地过滤一些可传递的依赖项，让 Maven 知道不要将它们添加到类路径中。

```
<dependency>
  <groupId>org.simpleframework</groupId>
  <artifactId>simple-xml</artifactId>
  <version>${simple-version}</version>
  <exclusions>
    <!-- StAX is not available on Android -->
    <exclusion>
      <artifactId>stax</artifactId>
      <groupId>stax</groupId>
    </exclusion>
    <exclusion>
      <artifactId>stax-api</artifactId>
      <groupId>stax</groupId>
    </exclusion>
    <!-- Provided by Android -->
    <exclusion>
      <artifactId>xpp3</artifactId>
      <groupId>xpp3</groupId>
    </exclusion>
  </exclusions>
</dependency>
```

### RssChannelHttpMessageConverter

这个消息转换器是关于解析 RSS 提要的；像往常一样，我们将把它注入到我们的`RestTemplate`实例中，但这次我们将从博客提要中读取条目。

```
final WebView resultTextView = (WebView) findViewById(R.id.result_text);
AsyncTask<String, Void, Channel> simpleGetTask =  new AsyncTask<String, Void, Channel>() {
   @Override
   protected Channel doInBackground(String... params) {
      RestTemplate restTemplate = new RestTemplate();
      // Configure the RSS message converter.
       RssChannelHttpMessageConverter rssChannelConverter = new RssChannelHttpMessageConverter();
      rssChannelConverter.setSupportedMediaTypes(
         Collections.singletonList(MediaType.TEXT_XML));

        // Add the RSS message converter to the RestTemplate instance
        restTemplate.getMessageConverters().add(rssChannelConverter);

      // Make the HTTP GET request on the url (params[0]), marshaling //the response to a String
      return restTemplate.getForObject(params[0], Channel.class);
   }

   @Override
   protected void onPostExecute(Channel result) {
      //get the latest article from the blog
      Item item = (Item) result.getItems().get(0);

      // load the content of the article into the WebView
      resultTextView.loadData(item.getContent().getValue(), "text/html", "UTF-8");
   }
};
String url = "http://blog.dahanne.net/feed/";
```

由于 POT0 提供的映射语言与我们要在这里发布的类不同，因此我们不会在这里使用【POT0】的属性来创建类。在这个例子中，我们只阅读第一个项目的内容——我博客上的最新文章！

提要如下所示：

```
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
<channel>
   <title>Anthony Dahanne's blog</title>
   <description>A blog</description>
   [...]
   <item>
      <title>Article 1</title>
      <description>content of the article</description>
      [...]
   </item>
   [...]
</channel>
</rss>
```

在该装置上的结果如下：

![RssChannelHttpMessageConverter](graphics/1905_03_02.jpg)

RSS 源的第一项的内容

### 注

您可能已经注意到，我将以前的 TextView 切换为 WebView，它能够解释 HTML 代码，例如超链接。

`RssChannelHttpMessageConverter`没有默认支持的类型，所以我们添加了媒体类型`text/xml`作为支持的类型。

### 注

我们必须为这个 RSS 提要示例添加对 Android ROME 提要阅读器的依赖；这个库没有发布在 Maven Central 上，这意味着我们还必须声明其工件部署到的存储库。

```
<dependency>
   <groupId>com.google.code.android-rome-feed-reader</groupId>
   <artifactId>android-rome-feed-reader</artifactId>
   <version>${android-rome-version}</version>
</dependency>

<repositories>
   <repository>
      <id>android-rome-feed-reader-repository</id>
      <name>Android ROME Feed Reader Repository</name>
      <url>https://android-rome-feed-reader.googlecode.com/svn/maven2/releases</url>
   </repository>
</repositories>
```

## Gzip 加密

为了在传输过程中节省带宽，作为每个请求的一部分，您可以告诉服务器您支持 gzip 加密。如果服务器支持 gzip 响应，它将这样做。

Android`RestTemplate`的 Spring 依赖 Android`java.net.HttpURLConnection`，因为姜饼（2.3）默认发送`Accept-Encoding : gzip`头；因此 gzip 压缩在默认情况下是打开的。

否则，您只需要在请求的头中指定您可以支持 gzip。让我们看一个具体的例子——Jackson 例子，这次我们只展示客户端支持的编码机制：

```
@Override
protected IfConfigMeJson doInBackground(String... params) {

   HttpHeaders requestHeaders = new HttpHeaders();
   requestHeaders.setAcceptEncoding(ContentCodingType.IDENTITY);
// Add the gzip Accept-Encoding header   
//requestHeaders.setAcceptEncoding(ContentCodingType.GZIP);
   HttpEntity<?> requestEntity = 
        new HttpEntity<Object>(requestHeaders);
   RestTemplate restTemplate = new RestTemplate();
   MappingJacksonHttpMessageConverter jacksonConverter = 
        new MappingJacksonHttpMessageConverter();
   restTemplate.getMessageConverters().add(jacksonConverter);
   ResponseEntity<IfConfigMeJson> response = 
        restTemplate.exchange(params[0], HttpMethod.GET, 
                      requestEntity, IfConfigMeJson.class);
   return response.getBody();
}
```

使用`Identity`，我们声明除原始文本外，我们不支持任何其他内容。

### 注

当您显式或隐式地请求 gzip 时，`java.util.zip.GzipInputStream`将自动用于解码响应。

你有没有注意到我们用了`exchange(url,GET,requestEntity,Pojo.class)`而不是`getForObject(url,Pojo.class)`？`exchange()`方法是一种更通用的方法，允许定制请求。

让我们看看在执行此代码期间交换的请求/响应：

<colgroup><col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

请求（标识，然后是 GZIP）

 | 

响应（标识，然后是 GZIP）

 |
| --- | --- |
| `GET/all.json HTTP/1.1``Accept: application/json``Accept-Encoding: identity``Content-Length: 0``Host: ifconfig.me:80``Connection: Keep-Alive` | `HTTP/1.1 200 OK``Date: Fri, 02 Nov 2012 02:41:04 GMT``Server: Apache``Vary: Accept-Encoding``Connection: close``Transfer-Encoding: chunked``Content-Type: application/json``13c``{"connection":"Keep-Alive","ip_addr:[...],"encoding":"identity"}``0` |
| `GET /all.json HTTP/1.1``Accept: application/json``Accept-Encoding: gzip``Content-Length: 0``User-Agent: Dalvik/1.6.0 (Linux; U; Android 4.0.4; sdk Build/MR1)``Host: ifconfig.me:80``Connection: Keep-Alive``X-Forwarded-For: 192.168.1.111` | `HTTP/1.1 200 OK``—îPq``Date: Fri, 02 Nov 2012 02:42:08 GMT``Server: Apache``Vary: Accept-Encoding``Content-Encoding: gzip``Content-Length: 258``Connection: close``Content-Type: application/json``­ã/%êAOÑ0 ÖÔ˛``"ì&À–"ß5ﬁ'ãâg2€él•¥§4�ˇªÖΩÕ&#124;3ÔeÊ˝2È¨%9kgŸ/{&ö"ì—+±/"SáJ˘àk` |

### 注

分析来回于设备的请求和响应通常很方便；您可以使用开源软件 Membrane 作为 HTTP 代理（[http://www.membrane-soa.org/soap-monitor/](http://www.membrane-soa.org/soap-monitor/) ）创建一个新的简单代理，用于侦听 localhost:2000 并重定向到目标 web 服务（例如，[http://ifconfig.me](http://ifconfig.me) ）。

在 Android 代码中，只需将您的 web 服务 URL 替换为`computer_ip:2000`（可以是`192.168.1.1:2000`）：您将看到 Android 应用程序和 web 服务 URL 之间的所有流量。

## HTTP 基本认证

顾名思义，此身份验证方案非常基本且不安全。您只需提供用户名和密码即可访问某个领域（通常是网站的一部分）。

正如我们对编码所做的那样，我们可以通过一个头提供凭证：用户名和密码将被 Base64 编码。

### 注

Base64 编码决不能提供安全性。你可以像编码一样轻松地解码它！参见[https://en.wikipedia.org/wiki/Base64](https://en.wikipedia.org/wiki/Base64) 了解有关 Base64 的更多信息。

例如，我们将尝试访问显示**Hello World**的网页；如果您发送了正确的凭据。页面为[http://restfulapp.appspot.com/helloworld](http://restfulapp.appspot.com/helloworld) ，凭证为用户名–`s4a`和密码–`s4a`（您可以在 web 浏览器中试用）。

让我们尝试使用 Spring for Android 的`RestTemplate`访问此页面！

```
AsyncTask<String, Void, String> simpleGetTask =  new AsyncTask<String, Void, String>() {
   @Override
   protected String doInBackground(String... params) {
      // Set the credentials for creating a Basic Auth request
      HttpAuthentication authHeader = 
          new HttpBasicAuthentication("s4a", "s4a");
      HttpHeaders requestHeaders = new HttpHeaders();
      requestHeaders.setAuthorization(authHeader);
      HttpEntity<?> requestEntity = 
          new HttpEntity<Object>(requestHeaders);

      RestTemplate restTemplate = new RestTemplate();

      restTemplate.getMessageConverters()
              .add(new StringHttpMessageConverter());

      try {
          // Make the GET request to the Basic Auth protected URL
          ResponseEntity<String> response = 
                restTemplate.exchange(params[0], HttpMethod.GET, 
                       requestEntity, String.class);
          return response.getBody();
      } catch (HttpClientErrorException e) {
         // Handle 401 Unauthorized response
         Log.e("MainActivity",e.getLocalizedMessage(),e);
         return "Wrong credentials";
      }
   }

   @Override
   protected void onPostExecute(String result) {
      // executed by the UI thread		 
      resultTextView.setText(result);
   }

};
```

按照前面示例中设置`Accepted-Encoding`的方式，我们将**HttpBasicAuthentication**头设置为`RestTemplate`头。

让我们看看在执行此代码期间交换的请求/响应：

<colgroup><col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

要求

 | 

回答

 |
| --- | --- |
| `GET/helloworld HTTP/1.1``Accept: text/plain, */*``Authorization: Basic czRhOnM0YQ==``Content-Length: 0``User-Agent: Dalvik/1.6.0 (Linux; U; Android 4.0.4; sdk Build/MR1)``Host: restfulapp.appspot.com:80``Connection: Keep-Alive``Accept-Encoding: gzip` | `HTTP/1.1 200 OK``Content-Type: text/plain; charset=iso-8859-1``Vary: Accept-Encoding``Date: Fri, 02 Nov 2012 03:33:06``Server: Google Frontend``Cache-Control: private``Transfer-Encoding: chunked``d``Hello, world``0` |

### 注

字符串`czRhOnM0YQ==`是`s4a:s4a`的 Base64 编码。

我们将在下一节*Quick Start–OAuth*中介绍一种更好的身份验证和授权用户及其应用程序的方法。

## RESTful 配方应用程序

让我们研究一下 restfulrecipe 应用程序：一个 Android 应用程序，它与 RESTful 服务交互，创建、更新、读取和删除食谱。

配方有点简单——它是一个具有以下字段的 POJO：

*   一个 ID（`Integer`）
*   标题（`String`）
*   配方说明（`String`
*   A 类：通常是主菜、主菜或甜点（`String`
*   作者（`String`

我们将用作后端服务的在线 web 应用程序是一个基于 Jersey（参考 JAX-RS 实现库）的 JAX-RS（REST 服务的 JEE 规范）应用程序，部署在 Google app Engine 上——它可以用 Ruby、Python 或任何其他语言编写。

### 注

如果您已经研究过记事本应用程序（Android 示例的一部分），您将熟悉 RESTful 配方应用程序：它是以记事本应用程序代码为基础编写的，将嵌入式 SQLite 数据库的持久性替换为 REST 在线服务。

### RecipeList 活动：列出服务器上存储的所有配方

当用户启动应用程序时，他想看到的第一件事就是可用配方的列表。

此活动使用`ListView`，以`ListAdapter`为背景向用户显示。

但首先，它需要从服务器获取它们：

*   我们需要一个模型（`Recipe.java`：

    ```
    public class Recipe {

       private Long id;
       private String title;
       private String description;
       private String type;
       private String author;
    }
    ```

*   以及嵌套在 AsyncTask 中的一个`RestTemplate`实例：

    ```
    private class GetRecipesTask extends RecipeAbstractAsyncTask <Void, Void, List<Recipe>> {

       @Override
       protected void onPreExecute() {
          showProgressDialog("Loading recipes. Please wait...");
       }

       @Override
       protected List<Recipe> doInBackground(Void... params) {
          HttpHeaders requestHeaders =  
                   prepareHeadersWithMediaTypeAndBasicAuthentication();

          // Populate the headers in an HttpEntity object		
          HttpEntity<?> requestEntity = 
                   new HttpEntity<Object>(requestHeaders);

          // Create a new RestTemplate instance
          RestTemplate restTemplate = new RestTemplate();
          restTemplate.getMessageConverters()
    .add(new MappingJacksonHttpMessageConverter());

          try {
             // Perform the HTTP GET request
             ResponseEntity<Recipe[]> responseEntity = 
                restTemplate.exchange(
                   "http://www.restfulapp.appspot.com/rest/recipes/",
                   HttpMethod.GET, requestEntity,
       Recipe[].class);
             return Arrays.asList(responseEntity.getBody());
          }
          catch (RestClientException e) {
             Log.e(TAG, e.getMessage(), e);
             exception = e;
             return null;
          }
       }

       @Override
       protected void onPostExecute(List<Recipe> result) {
          dismissProgressDialog();
          if(result != null) {
             recipes = result;
          } else {
             String message = exception != null ? 
                exception.getMessage() : "unknown reason";
             Toast.makeText(RecipesList.this, 
                "A problem occurred during the reception of all recipes
                : " +message , Toast.LENGTH_LONG).show();
              recipes = new ArrayList<Recipe>();
          }
          ListAdapter adapter = new RecipeAdapter(RecipesList.this, 
             R.layout.recipeslist_item, recipes ) ;
          setListAdapter(adapter );
       }
    }
    ```

每次我们需要更新配方列表时，都会执行此任务：

*   创建（或恢复）活动时：`onResume()`
*   当我们从成功的更新操作返回时：`onActivityResult()`

您可能已经注意到，此 AsyncTask 扩展了定义异常的类`RecipeAbstractAsyncTask`和实用程序方法`prepareHeadersWithMediaTypeAndBasicAuthentication()`：

```
protected HttpHeaders prepareHeadersWithMediaTypeAndBasicAuthentication() {
      HttpHeaders requestHeaders = new HttpHeaders();
      List<MediaType> acceptableMediaTypes = new ArrayList<MediaType>();
      acceptableMediaTypes.add(MediaType.APPLICATION_JSON);
      requestHeaders.setAccept(acceptableMediaTypes);
      HttpAuthentication authHeader = new HttpBasicAuthentication("s4a", "s4a");
      requestHeaders.setAuthorization(authHeader);
      return requestHeaders;
   }
```

顾名思义，它准备请求头，以包括所需的基本身份验证和来自服务器的所需`MediaType`对象。

回到`GetRecipesTask`：我们准备请求头，创建一个新的`RestTemplate`实例——配置为使用 Jackson（取消）序列化消息，然后执行 GET 请求：

```
// Perform the HTTP GET request
               ResponseEntity<Recipe[]> responseEntity = restTemplate.exchange(getString(R.string.recipe_resource_url), HttpMethod.GET, requestEntity, Recipe[].class);
```

### 注

`R.string.resource_url`值在`strings.xml`中定义，并定义为等于：[http://www.restfulapp.appspot.com/rest/recipes/](http://www.restfulapp.appspot.com/rest/recipes/) 。

因为我们想要得到一个配方列表，所以给`ResponseEntity`对象的类型是一个数组。

另一个需要注意的重要事项是异常处理程序：**RestClientException**与它的名称不同，它是一个包装服务器和客户端异常。如果你想告诉你的用户出了什么问题，你最好捕获这个异常并保存它，直到你在`onPostExecute()`方法中执行代码时回到 UI 线程。

### 注

注意，`RestClientException`是`RuntimeException`的一个子类，这就是为什么不需要显式捕获它。如果您不这样做，如果抛出此异常，它可能会杀死您的活动。

在用户界面方面，该任务使用其执行前和执行后方法，通过使用`ProgresDialogs`和`Toasts`让用户不断更新加载状态。

### 注

从应用程序外部手动调试 REST 资源可能很有用；**cURL**应用程序（可在[下载）http://curl.haxx.se/download.html](http://curl.haxx.se/download.html) 可能是最流行的工具。

对于本节中引发的每个 HTTP 请求，我现在将包括其匹配的 cURL 命令行。

```
curl --user s4a:s4a  -H "Accept: application/json" -i http://www.restfulapp.appspot.com/rest/recipes 
[{"id":0,"title":"Montreal's Poutine","description":"French fries are covered with fresh cheese curds, and topped with brown gravy.","type":"MAIN_DISH","author":"Anthony"},{"id":1,"title":"a title","description":"a description","type":"a type","author":"an author"}]
```

![RecipeList activity: listing all recipes stored on the server](graphics/1905_03_03.jpg)

菜谱列表活动概述

### 接受者活动

此活动负责获取、更新、创建和删除食谱。

![RecipeEditor activity](graphics/1905_03_04.jpg)

RecipeEditor 活动处于更新模式

*   GETting a recipe

    当用户点击 RecipeList 活动的创建图标或配方标题时，他/她将被引导到 RecipeEditor 活动。

    如果用户想要创建一个新的配方，他/她将看到空字段，但如果他/她想要看到一个配方，他们将首先从服务器上获取它，然后再填充字段；感谢内部`GetRecipeTask`：

    ```
    // Perform the HTTP GET request
    Log.i(TAG,"Getting the recipe with id : "+params[0] + " : " +url + params[0]);
    ResponseEntity<Recipe> responseEntity = restTemplate.exchange(url + params[0], HttpMethod.GET, requestEntity,	Recipe.class);
    return responseEntity.getBody();
    ```

    这里没有什么新东西，我们想得到一个单一的配方，由它的 ID（`params[0])`标识。

    ```
    curl --user s4a:s4a  -H "Accept: application/json" -i http://www.restfulapp.appspot.com/rest/recipes/0
    {"id":0,"title":"Montreal's Poutine","description":"French fries are covered with fresh cheese curds, and topped with brown gravy.","type":"MAIN_DISH","author":"Anthony"}
    ```

*   PUTting a recipe

    要更新一个配方，我们必须使用 PUT HTTP 谓词请求配方资源。

    为此，我们有一个专用的异步任务：`UpdateRecipeTask`，它将实例化一个`RestTemplate`实例，携带更新的配方（只要用户按下`Save`按钮，我们就调用`updateNote()`方法，该方法将视图的内容与当前配方的模型同步）。

    ```
    // Create a new RestTemplate instance
    RestTemplate restTemplate = new RestTemplate();
    restTemplate.getMessageConverters()
       .add(new MappingJacksonHttpMessageConverter());

    // Populate the headers in an HttpEntity object HttpEntity<Recipe> requestEntity = new HttpEntity<Recipe>(recipe,requestHeaders);
    try {
       // Perform the HTTP PUT request
       Log.i(TAG,"Updating the recipe with id : "
          +recipe.getId() + " : " + url);
       ResponseEntity<Void> responseEntity = 
          restTemplate.exchange(url, HttpMethod.PUT, requestEntity,
          Void.class);
       if(responseEntity.getStatusCode() != HttpStatus.OK) {
          throw new HttpServerErrorException(
             responseEntity.getStatusCode());
       }
    }
    catch (RestClientException e) {
       Log.d(TAG, e.getMessage(), e);
       exception = e;
    }
    ```

    你可以看到这里真正重要的部分是`RequestEntity`，它包装了我们的配方：`RestTemplate`将传递给 Jackson，Jackson 将其转换为 JSON 字符串。

    如果服务器没有响应 HTTP 状态 200（OK），我们可以考虑出错，并保持用户界面的异常。

    ```
    curl --user s4a:s4a  -H "Accept: application/json" -H "Content-type: application/json"  -X PUT -d '{"id":"0", "title":"a title","description":"a description","type":"a type","author":"an author"}'  -i http://www.restfulapp.appspot.com/rest/recipes/
    ```

*   POSTing a recipe

    要创建一个配方，我们必须使用 POST HTTP 谓词请求配方资源。

    在其余的文献中，您还将阅读关于 PUT HTTP 谓词创建实体的用法；但有一个条件——您必须提供 ID（这样，一行中的几个 PUT 不会改变资源状态。PUT 与 GET 和 DELETE 一样是幂等的，与 DELETE 和 POST 一样不安全）。

    ### 注

    在我们的例子中，我们创建了一个新的资源，所以 POST 很好地反映了我们的意图。

    我们来看看`CreateRecipeTask`，它与`UpdateRecipeTask`非常相似：

    ```
    // Populate the headers in an HttpEntity object 
    HttpEntity<Recipe> requestEntity = 
       new HttpEntity<Recipe>(recipe,requestHeaders);
    try {
       // Perform the HTTP POST request
       Log.i(TAG,"Posting the recipe with id : "
          +recipe.getId() + " : to " +url);
       ResponseEntity<Void> responseEntity = 
          restTemplate.exchange(url, HttpMethod.POST, requestEntity,
          Void.class);
       if(responseEntity.getStatusCode() != HttpStatus.CREATED) {
          throw new HttpServerErrorException(
             responseEntity.getStatusCode());
       }
    }
    catch (RestClientException e) {
       Log.d(TAG, e.getMessage(), e);
       exception = e;
    }
    return null;
    ```

    需要注意的一些有趣的事情：该配方没有任何 ID 设置，因为用户是从无到有创建配方的。web 服务将为该配方分配一个 ID（并应返回所创建资源的 URI）；并且期望状态不是 200，而是 201（`HttpStatus.CREATED`。

    ```
    curl --user s4a:s4a  -H "Accept: application/json" -H "Content-type: application/json"  -X POST -d '{"title":"a title","description":"a description","type":"a type","author":"an author"}'  -i http://www.restfulapp.appspot.com/rest/recipes/
    ```

*   DELETing a recipe

    要删除一个配方，我们必须使用 delete HTTP 谓词请求配方资源。

    名为`DeleteRecipeTask`的 AsyncTask 与`GetRecipeTask`类似，它只需要将配方的 ID 附加到资源 URI 中（不需要像 PUT 和 POST 那样携带整个配方）。

    ```
    try {
       // Perform the HTTP DELETE request
       Log.i(TAG,"Deleting the recipe with id : "
          +recipe.getId() + " : from " +url +recipe.getId() );
       ResponseEntity<Void> responseEntity = 
          restTemplate.exchange(url+recipe.getId(), 
          HttpMethod.DELETE, requestEntity,	Void.class);
       if(responseEntity.getStatusCode() != HttpStatus.NO_CONTENT) {
          throw new HttpServerErrorException(
          responseEntity.getStatusCode());
       }
    }
    catch (RestClientException e) {
       Log.d(TAG, e.getMessage(), e);
       exception = e;
    }
    ```

    此请求需要一个带有 204 HTTP 代码的响应，这意味着请求成功，但没有返回任何内容（`HttpStatus.NO_CONTENT`。

    ### 注

    HTTP 代码 200 可以作为对成功删除请求的响应。

    查看您的 web 服务文档（或者更好，例如使用 cURL 进行实验），以对应该返回的 web 服务做出最佳假设。

    ```
    curl --user s4a:s4a  -H "Accept: application/json" -X DELETE   -i http://www.restfulapp.appspot.com/rest/recipes/1
    ```

## 安卓注释

您可能已经在[上听说过该项目 https://github.com/excilys/androidannotations/](https://github.com/excilys/androidannotations/) 旨在减少在 Android 应用程序中注入视图、活动、提供者、服务等所需的代码量。

项目负责人已经决定使用 Spring for Android 的`RestTemplate`作为支持 REST 注释的 REST 客户端库。

### 注

Android 注解基于**注解处理器工具**（**apt**），现在是 Java 6 编译器的一部分；每个带注释的类都将触发子类的生成（命名为同一子类，并在文件名后附加一个`_`，例如`OriginalActivity_.java`），该子类将包含注释保存下来的所有样板代码！

因此，除了`@Eactivity`（允许活动使用 Android 注释）、`@ViewById`（注入视图）之外，还有`@Get`、`@Post`、`@Put`等等。

让我们通过 JSON 示例（从`Ifconfig.me`获取 IP 地址）来了解如何从 Android 注释中获益。

```
@EActivity(R.layout.activity_main)
public class MainActivity extends Activity {

   private IfConfigMeJson all;

   //inject the view to the activity layout
    @ViewById(R.id.result_text)
    TextView resultTextView;

    //inject the Rest service that wraps RestTemplate
    @RestService
   IfConfigMeRestClient restClient;

    //Use the Rest Service in a background thread
    @Background
    @AfterInject
    void getAllInfo() {
       all = restClient.getAll();
    }

    //wait a few seconds for the service to finish
   @UiThread(delay = 5000)
   @AfterViews
   void afterViews() {
      resultTextView.setText("Your IP is : "+all.getIpAddr());
   }

}
```

代码肯定少了，对吧？

您可能已经注意到，我们正在使用一个名为`IfConfigMeRestClient`的新类：

```
@Rest(rootUrl = "http://ifconfig.me", converters = 
      { MappingJacksonHttpMessageConverter.class })
public interface IfConfigMeRestClient {

   @Get("/all.json")
   @Accept(MediaType.APPLICATION_JSON)
   IfConfigMeJson getAll();

}
```

此类配置`RestTemplate`，提供转换器类、使用的 HTTP 谓词、映射类（`IfConfigMeJson`和接受的媒体类型。

Android 注释为 Spring 提供了对 Android 的`RestTemplate`的良好支持（参见[https://github.com/excilys/androidannotations/wiki/Rest-API](https://github.com/excilys/androidannotations/wiki/Rest-API) 查看基于`RestTemplate`的注释列表），我建议您尝试一下，看看您是否喜欢在基于 Android 的 Spring 项目中使用它。

### 注

如果您从头开始使用 Android 注释，我建议您仔细遵循以下环境说明：[https://github.com/excilys/androidannotations/wiki/Building-Project-Maven-Eclipse](https://github.com/excilys/androidannotations/wiki/Building-Project-Maven-Eclipse) 。

# 快速启动–OAuth

正如维基百科所说，OAuth 是一个开放的授权标准。

OAuth 允许用户与网站、桌面或移动应用程序共享其托管在服务提供商上的数据或资源。

当然，如果你向那些网站或应用程序提供了你的凭据（用户名和密码），他们可以代表你访问你的数据；但是，你会相信第三方应用程序或网站能保证你的凭证（你数字生活的钥匙）安全吗？如果此应用程序或网站是恶意的，该怎么办？或者干脆不担保？你读过多少次关于一个网站的用户证书被盗，或者在他们的数据库中以明文形式保存密码？

OAuth 就是这样；允许第三方应用程序或网站（通过授权或范围列表：`access user email`、`access user profile`、`can post messages on user behalf`等）有限地访问您的数据，这些数据由服务提供商托管（著名的 OAuth 服务提供商有谷歌、Facebook、推特、雅虎、GitHub、LinkedIn 等），而无需向他们提供您的凭据。

## 依赖服务提供商开发网站或应用程序

您是否注意到一些网站（如[Deezer.com](http://Deezer.com)、[StackOverFlow.com](http://StackOverFlow.com)等）上的**使用 Facebook**登录或**使用谷歌**按钮登录，或者您是否曾在安卓设备（如 Twicca）上使用第三方 Twitter 应用程序请求您的 Twitter 凭据？

所有这些网站和应用程序都使用 OAuth 访问您的数据：

*   首先，它们为您省去了创建和记住其他凭证的麻烦。他们甚至通过访问您的数据（例如您的个人资料图片、活动信息等）来丰富您的用户体验。
*   此外，他们聚集了更多的受众（因为用户不必经历繁琐的帐户创建过程），他们也不必管理身份验证凭据（有风险）或授权。

通常，如果网站或应用程序创建者希望从提供 OAuth 授权的服务中获益，他/她必须向 OAuth 服务提供商（谷歌、Facebook 等）注册，这反过来会给他/她一个**客户 ID**和**客户机密**值：

![Developing a website or an app relying on a service provider](graphics/1905_04_01.jpg)

使用 GoogleAPI 控制台注册新应用程序并将其与客户端 ID 和客户端密码关联

让我们来了解一下这个客户端 ID 和客户端机密如何使应用程序能够访问用户的数据。

## 非统舞

Android 应用程序（或任何其他已安装的应用程序）依赖于 OAuth 2.0 服务提供商，如谷歌。让我们通过以下五个简单步骤来了解 OAuth 授权流程的工作流程：

1.  The user launches the app for the first time; it will generate the token request – a URL to the service provider, including the app client ID and client secret, and also the several authorizations needed for the app (user info, userinfo e-mail, and so on).

    Google OAuth 2.0 服务提供商的一个示例：

    ```
    https://accounts.google.com/o/oauth2/auth?
    client_id=508046100884-o6jgcn8e7c1g5gklhc8gibr80ouio8df.apps.googleusercontent.com&
    response_type=code&
    redirect_uri=http://localhost&
    scope=https://www.googleapis.com/auth/userinfo.profile https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/plus.me
    ```

2.  此 URL 由 Android Chrome 浏览器加载，很可能是通过网络视图嵌入到应用程序中。用户被要求接受或拒绝应用程序请求的授权。
3.  In return, if the user grants the app, the app will intercept the response from the embedded browser that contains an authorization code.

    Google OAuth 2.0 服务提供商的响应示例：

    ```
    http://localhost/?code=4/urIB_wqrOqGpX-2w1UPXD8dHQAYO.ArEX_6EbNP0ZuJJVnL49Cc98lfsNdgI
    ```

4.  The app will finally exchange this authorization code for a token (if the lifetime of the token is limited, the app will also receive a refresh token and the expire time). This access token will be saved securely by the app.

    Google OAuth 2.0 服务提供商的令牌请求/响应示例。

    **请求**：

    ```
    POST /o/oauth2/token HTTP/1.1
    Host: accounts.google.com
    Content-Type: application/x-www-form-urlencoded

    code=4/v6xr77ewYqhvHSyW6UJ1w7jKwAzu&
    client_id=8819981768.apps.googleusercontent.com&
    client_secret={client_secret}&
    redirect_uri=https://oauth2-login-demo.appspot.com/code&
    grant_type=authorization_code
    ```

    **响应**：

    ```
    {
      "access_token":"1/fFAGRNJru1FTz70BzhT3Zg",
      "expires_in":3920,
      "token_type":"Bearer",
      "refresh_token":"1/xEoDL4iW3cxlI7yDbSRFYNG01kVKM2C-259HOF2aQbI"
    }
    ```

5.  The app will finally be able to interact with the resource (such as a REST service), provided it sends a valid token along with each of its requests.

    Google OAuth 2.0 服务提供商使用令牌的请求示例：

    ```
    GET /oauth2/v1/userinfo HTTP/1.1
    Authorization: Bearer 1/fFBGRNJru1FQd44AzqT3Zg
    Host: googleapis.com
    ```

### 注

大多数 OAuth 2.0 服务提供商（如果不是全部的话）只接受 HTTPS 上的授权服务调用，以确保令牌不能被截获。

![The OAuth dance](graphics/1905_04_02.jpg)

从[访问谷歌用户信息服务的 OAuth 工作流 https://developers.google.com/accounts/docs/OAuth2](https://developers.google.com/accounts/docs/OAuth2)

### 注

您可以阅读[https://developers.google.com/accounts/docs/OAuth2InstalledApp](https://developers.google.com/accounts/docs/OAuth2InstalledApp) 了解谷歌 OAuth 2.0 服务提供商的详细信息，或[http://developers.facebook.com/docs/concepts/login/login-architecture/](http://developers.facebook.com/docs/concepts/login/login-architecture/) 了解 Facebook OAuth 2.0 服务提供商的详细信息。

强烈建议在开始使用客户机应用程序之前阅读 OAuth 服务提供商文档（每个文档都有一些细微的差异，例如请求令牌的参数、回调 url 等等）。

## Android 认证模块的 Spring

Spring for Android`Auth`模块支持 OAuth 1.0a 和 OAuth 2.0。

简言之：

*   OAuth 2.0 允许更好地支持非 Web 应用程序（如 Android 应用程序）
*   OAuth2.0 不再要求开发人员使用加密技术
*   OAuth 2.0 访问令牌是*短期*（由于刷新令牌）

### 注

要了解更多关于 OAuth 2.0 的信息，您可以在他的博客[上阅读*Eran Hammer*中的几篇文章 http://hueniverse.com/2010/05/introducing-oauth-2-0/](http://hueniverse.com/2010/05/introducing-oauth-2-0/)

Android`Auth`模块的 Spring 取决于以下几点：

*   Android 内核的 Spring（常见类：`Base64`、`StringUtils`、资源抽象等）
*   Android 的 Spring`RestTemplate`（REST API 抽象底层 HttpClient）
*   Spring Social Core（包装 OAuth 流的 OAuth 1.0 和 2.0 API：请求授权代码、请求令牌等）
*   Spring Security Crypto（支持对称加密、密钥生成和密码编码）

`Auth`模块本身为 Android 定义了加密和 SQL 类（使您能够将授权令牌安全地持久化到 SQLite Android 数据库）。

### 注

Spring for Android 的`Auth`到目前为止只包含七个类，它们是关于在 Android 设备上持久化 OAuth 令牌的支持；所有 OAuth 代码都在 Spring Social Core 中。

为了让 Twitter、Facebook 和 Google 应用开发者的生活更轻松，Spring Social 提供了扩展，分别命名为 Spring Social Twitter、Spring Social Facebook 和 Spring Social Google。这些 API 定义了访问每个社交网络中用户信息、帖子、联系人和议程的 API。

## 使用 Google 的 OAuth 示例

我们将构建一个安卓应用程序，显示谷歌用户的信息：我们当然将在安卓`Auth`中使用 Spring，但更重要的是 Spring 社交和 Spring 社交谷歌。

### 注

官方文档的例子是关于 Facebook 和 Twitter 的。如果您想创建一个与这些社交网络交互的应用程序，请查看[上的 Android Spring 示例 https://github.com/SpringSource/spring-android-samples](https://github.com/SpringSource/spring-android-samples) 。

让我们看看这个项目的`pom.xml`文件，特别是包含 Spring 社交谷歌：

```
<dependency>
  <groupId>org.springframework.social</groupId>
  <artifactId>spring-social-google</artifactId>
  <version>1.0.0.M1</version>
  <exclusions>
    <!-- Exclude in favor of Spring Android RestTemplate -->
    <exclusion>
      <artifactId>spring-web</artifactId>
      <groupId>org.springframework</groupId>
      </exclusion>
      <exclusion>
      <artifactId>spring-core</artifactId>
      <groupId>org.springframework</groupId>
    </exclusion>
  </exclusions>
</dependency>
[...]
<repository>
  <id>spring.social.google</id>
  <name>Spring Social Google</name>
  <url>https://github.com/GabiAxel/maven/raw/master/</url>
</repository>
```

您会注意到这里（在`repository`部分），这个模块不是由 Spring Source 托管的，因为它实际上是一个未经 Spring Source 认可的社区项目。

### 注

此`pom.xml`文件包含许多排除项；这是因为使用的大多数库都是用 JavaSE 开发的，这就是为什么它们依赖 SpringCore、SpringMVC 等等。Spring for Android Core 和`RestTemplate`为这些模块提供了必要的依赖关系。

现在我们来看一下`AndroidManifest.xml`文件：

```
[...]
<application
    android:name=".MainApplication"
    android:icon="@drawable/app_notes"
    android:label="@string/app_name" >
    <activity
        android:name=".GoogleActivity"
        android:label="@string/title_main" >
        [...]
    </activity>
    <activity
        android:name=".GoogleWebOAuthActivity"
        android:excludeFromRecents="true"
        android:noHistory="true" />
    <activity android:name=".GoogleProfileActivity" />
</application>
```

在我们的示例中，我们将首次使用一个名为`MainApplication`的`Application`类。

### 注

`GoogleWebOAuthActivity`将嵌入一个浏览器，并且仅为验证而启动。我们不希望此活动成为应用程序历史记录的一部分，也不希望用户能够返回到它；这就是我们添加了`android:noHistory="true"`和`android:excludeFromRecents="true"`的原因。更多信息请访问[http://developer.android.com/guide/topics/manifest/activity-element.html](http://developer.android.com/guide/topics/manifest/activity-element.html) 。

本课程将用于准备我们应用程序中最重要的两个工厂（它们将在所有活动中访问）：`ConnectionFactoryRegistry`和`ConnectionRepository`：

```
public class MainApplication extends Application {
  private ConnectionFactoryRegistry connectionFactoryRegistry;
  private SQLiteOpenHelper repositoryHelper;
  private ConnectionRepository connectionRepository;

  // ***************************************
  // Application Methods
  // ***************************************
  @Override
  public void onCreate() {
    // create a new ConnectionFactoryLocator and populate it with Google ConnectionFactory
    this.connectionFactoryRegistry = new ConnectionFactoryRegistry();
    this.connectionFactoryRegistry.addConnectionFactory(new GoogleConnectionFactory(getClientId(),
        getClientSecret()));

    // set up the database and encryption
    this.repositoryHelper = new SQLiteConnectionRepositoryHelper(this);
    this.connectionRepository = new SQLiteConnectionRepository(this.repositoryHelper,
        this.connectionFactoryRegistry, AndroidEncryptors.text("password", "5c0744940b5c369b"));
  }
```

如您所见，在`onCreate()`方法中，我们初始化：

*   `ConnectionFactoryRegistry`：使用`ConnectionFactoryRegistry`中的客户端 ID 和应用程序的客户端机密，我们可以访问`GoogleConnectionFactory`，这是`OAuth2ConnectionFactory`的 Google 服务扩展，它允许访问所有 OAuth 操作
*   `ConnectionRepository`：这将负责持久化`ConnectionFactoryRegistry`，以便可以检索 OAuth 令牌，而无需每次执行整个 OAuth 工作流

### 注

您可能已经注意到在数据库初始化期间使用了 salt 和密码（加密）。

这将防止恶意应用程序能够访问设备数据库以检索用户 OAuth 令牌。一个简短的提醒：该应用程序将永远无法访问用户的谷歌密码。服务提供商（本例中为谷歌）的身份验证始终从设备浏览器执行。

让我们看看该项目的主要活动，`GoogleActivity`将在启动时启动：

```
@Override
public void onStart() {
  super.onStart();
  if (isConnected()) {
    showGoogleOptions();
  } else {
    showConnectOption();
  }
}

private boolean isConnected() {
  return connectionRepository.findPrimaryConnection(Google.class) != null;
}
```

如果用户已连接，此活动将显示与用户配置文件相关的条目列表；如果用户尚未连接，则仅显示一个**连接**按钮（因为`GoogleConnectionFactoryRegistry`保存在数据库中，只需在`ConnectionRepository`中查找`Google`类型的连接即可）足以知道是否已获取访问令牌）。

![An OAuth example using Google](graphics/1905_04_03.jpg)

如果用户尚未登录，则显示 GoogleActivity

所以，在我们没有连接的情况下，点击**连接**会调用`displayGoogleAuthorization()`，这将启动`GoogleWebOAuthActivity`。

`GoogleWebOAuthActivity`当然是这个应用最重要的活动。它负责 OAuth 2.0 身份验证和授权。

```
@Override
public void onCreate(Bundle savedInstanceState) {
  super.onCreate(savedInstanceState);

  //javascript is mandatory
  getWebView().getSettings().setJavaScriptEnabled(true);

  // Using a custom web view client to capture the access token
  getWebView().setWebViewClient(new GoogleOAuthWebViewClient());

  this.connectionRepository = getApplicationContext().getConnectionRepository();
  this.connectionFactory = getApplicationContext().getGoogleConnectionFactory();
}

@Override
public void onStart() {
  super.onStart();

  // display the Google authorization page
  getWebView().loadUrl(getAuthorizeUrl());
}

// ***************************************
// Private methods
// ***************************************
private String getAuthorizeUrl() {
  String redirectUri = getString(R.string.google_oauth_callback_url);
  String scope = getString(R.string.google_scope);

  // Generate the Google authorization url to be used in the browser 
  OAuth2Parameters params = new OAuth2Parameters();
  params.setRedirectUri(redirectUri);
  params.setScope(scope);
  return this.connectionFactory.getOAuthOperations().buildAuthorizeUrl(GrantType.AUTHORIZATION_CODE, params);
}
```

请注意，当您创建了一个自定义的 JavaScript 视图时，Google T1 需要将此 JavaScript 添加到一个[OAU]视图中，并将[OAU]视图添加到一个[OAU]视图中对象，我们将使用它来拦截 OAuth 流（稍后将详细介绍）。

然后，当活动开始时，我们要求 WebView（嵌入式 Chrome 浏览器）请求该应用程序的授权代码（参见*OAuth 舞蹈*部分的步骤 1）。

此请求使用回调 URL、应用程序所需的授权范围以及客户端 ID 和机密（这两个在我们创建`ConnectionFactoryRegistry`时已经提供给 Spring OAuth）来构建。

```
<resources>
    <string name="google_app_id">508046100884-o6jgcn8e7c1g5gklhc8gibr80ouio8df.apps.googleusercontent.com</string>
    <string name="google_app_secret">RuUyrF5qoGYWTFm1r_o8Gs4F</string>
    <string name="google_oauth_callback_url">http://localhost</string>
    <string name="google_scope">https://www.googleapis.com/auth/userinfo.profile https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/plus.me</string>
</resources>
```

### 注

这里的回调 URL 是[http://localhost](http://localhost) ，因为谷歌 OAuth 2.0 服务提供商提供了[之间的选择 http://localhost](http://localhost) 和`urn:ietf:wg:oauth:2.0:oob`。

这将影响持有授权代码的响应；它是查询字符串参数的一部分还是在浏览器的标题栏中。您可以阅读[https://developers.google.com/accounts/docs/OAuth2InstalledApp#choosingredirecturi](https://developers.google.com/accounts/docs/OAuth2InstalledApp#choosingredirecturi) 了解更多详情。

如果用户尚未通过其设备对任何 Google web 服务进行身份验证，他/她应该会看到一个对话框，邀请他/她进行身份验证：

![An OAuth example using Google](graphics/1905_04_04.jpg)

此对话框仅在用户尚未通过其设备上任何 Google 服务的身份验证时出现

但在所有情况下，用户都会看到此授权对话框，其中列出了应用程序请求的所有*范围*：

![An OAuth example using Google](graphics/1905_04_05.jpg)

Google OAuth 2.0 服务提供商授权对话框

### 注

如果用户拒绝授权，那么，正如预期的那样，授权过程将终止。

根据服务提供商的不同，此对话框可能会有所不同。

一旦用户接受请求的授权，`GoogleWebOAuthActivity`将检测到 web 客户端被重定向到本地主机（**回调 URI**），授权代码为：

```
private class GoogleOAuthWebViewClient extends WebViewClient {

  private static final String LOCALHOST = "localhost";
  private static final String CODE = "code";

  /*
   * The WebViewClient has another method called shouldOverridUrlLoading which does not capture the javascript 
   * redirect to the success page. So we're using onPageStarted to capture the url.
   */
  @Override
  public void onPageStarted(WebView view, String url, Bitmap favicon) {
    // parse the captured url
    Uri uri = Uri.parse(url);
     // log the url : very interesting for debugging the OAuth workflow
    Log.d(TAG, url);

    /*
     * The WebViewClient is launched to load an URL from the provider that will ask the user whether or not he accepts our app to access his data.
     * Once the provider successfully gets the approval from the user, it will redirect this WebViewClient to the callback_uri, with a query parameter named "code" : this is the authorization code
     */
    String host = uri.getHost();
    String code = uri.getQueryParameter(CODE);

    // The WebViewClient is redirected to the callback_uri, let's trade the authorization code for the access token
    if (LOCALHOST.equals(host)) {
      if(!exchangeAuthorizationCodeForAccessToken.getStatus().equals(AsyncTask.Status.RUNNING)) {
        exchangeAuthorizationCodeForAccessToken.execute(code);
        Toast.makeText(getApplicationContext(), "Redirecting you to the app main activity", Toast.LENGTH_LONG).show();
        //preparing to quit this activity for the main activity
        getWebView().setVisibility(View.INVISIBLE);
      }
    }
  }
}
```

`exchangeAuthorizationCodeForAccessToken.execute(code)`将执行以下异步任务（我们将使用`RestTemplate`从我们的应用程序发回授权代码，依赖 Java`UrlConnection`，因此我们需要从后台线程对该调用进行编码）：

```
private AsyncTask<String, Void, Void> exchangeAuthorizationCodeForAccessToken =  new AsyncTask<String, Void, Void>() {

  private Exception exception;

  @Override
  protected Void doInBackground(String... params) {
    // executed by a background thread
    //params[0] should contain the authorization code
    try {
      AccessGrant exchangeForAccess = connectionFactory.getOAuthOperations().exchangeForAccess(params[0], getString(R.string.google_oauth_callback_url), null);
      Connection<Google> connection = connectionFactory.createConnection(exchangeForAccess);
      connectionRepository.addConnection(connection);
    } catch (DuplicateConnectionException e) {
      Log.e(TAG,"something went wrong when adding the accessToken to the connection repository",e);
      exception = e;
    } catch (Exception e) {
      Log.e(TAG,"something went wrong when adding the accessToken to the connection repository",e);
      exception = e;
    }
    return null;
  }

  @Override
  protected void onPostExecute(Void result) {
    // executed by the UI thread once the background thread is done getting the result
    if(exception != null) {
      Toast.makeText(getApplicationContext(), exception.getMessage(), Toast.LENGTH_LONG).show();
    }
      // we go back to the main activity to display the options
      displayGoogleOptions();
  }

};
```

调用`exchangeForAccess`方法后，我们检索用户令牌，并将其保存在`ConnectionRepository`类中。

我们的应用程序最终被授权访问用户的谷歌档案！

![An OAuth example using Google](graphics/1905_04_06.jpg)

如果用户尚未登录，则显示 GoogleActivity

如果用户点击**档案**，他将启动`GoogleProfileActivity`，正如您所料，我们将从中获得用户档案。

为此，我们正在使用一个名为`FetchProfileTask`的异步任务，它将访问两个 Google web 服务：`UserOperations`（用于读取用户的主配置文件和他/她的配置文件图片）和`PersonOperations`（用于读取他/她的 Google+配置文件，这里我们将访问**关于我的**描述）：

```
@Override
protected LegacyGoogleProfile doInBackground(Void... params) {

    LegacyGoogleProfile userProfile = google.userOperations().getUserProfile();
    aboutMe = google.personOperations().getGoogleProfile().getAboutMe();
    profileBitmap = BitmapFactory.decodeStream(new URL(userProfile.getProfilePictureUrl()).openConnection().getInputStream());
    return userProfile;

}
```

然后将此信息注入视图：

![An OAuth example using Google](graphics/1905_04_07.jpg)

GoogleProfileActivity 显示用户配置文件图片、“关于我”描述和一些配置文件信息

# 你应该了解的人和地方

如果您需要 springforandroid（或 REST 或 OAuth）的帮助，以下是一些非常有价值的人和地方。

## 官方网站

*   首页：[http://www.springsource.org/spring-android](http://www.springsource.org/spring-android)
*   手册和文件：[http://static.springsource.org/spring-android/docs/1.0.x/reference/htmlsingle/](http://static.springsource.org/spring-android/docs/1.0.x/reference/htmlsingle/)
*   博客：[http://blog.springsource.org/category/android/](http://blog.springsource.org/category/android/)
*   源代码：[https://github.com/SpringSource/spring-android](https://github.com/SpringSource/spring-android)
*   官方示例源代码：[https://github.com/SpringSource/spring-android-samples](https://github.com/SpringSource/spring-android-samples)
*   安卓 Maven 插件：[http://code.google.com/p/maven-android-plugin/](http://code.google.com/p/maven-android-plugin/)

## 文章和教程

*   OAuth 解释：[http://hueniverse.com/oauth/guide/](http://hueniverse.com/oauth/guide/)
*   用于谷歌服务的 OAuth:[http://support.google.com/a/bin/answer.py?hl=en &答案=61017](http://support.google.com/a/bin/answer.py?hl=en&answer=61017)
*   关于远程连接的官方 Android 文档：[http://developer.android.com/training/basics/network-ops/connecting.html](http://developer.android.com/training/basics/network-ops/connecting.html)

## 社区

*   官方论坛：[http://forum.springsource.org/forumdisplay.php?88-安卓](http://forum.springsource.org/forumdisplay.php?88-Android)
*   官方 bug 追踪器：[https://jira.springsource.org/browse/ANDROID](https://jira.springsource.org/browse/ANDROID)

## 博客

*   安卓团队博客：[http://android-developers.blogspot.ca/](http://android-developers.blogspot.ca/)

## 推特

*   关注 Twitter 上 Android 的 Spring:[https://twitter.com/springandroid](https://twitter.com/springandroid)
*   在 Twitter 上关注 Roy Clarkson（Android 首席开发人员的 Spring）：[https://twitter.com/royclarkson](https://twitter.com/royclarkson)
*   有关更多开源信息，请访问 Packt:[http://twitter.com/#!/packtopensource](http://twitter.com/#!/packtopensource)