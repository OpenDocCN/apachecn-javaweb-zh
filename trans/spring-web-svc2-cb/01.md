# 第 1 章：构建 SOAP Web 服务

在本章中，我们将介绍：

*   使用 Maven 构建和运行 SpringWS 项目
*   创建数据契约
*   使用 `DispatcherServlet`设置 Web 服务
*   使用 `MessageDispatcherServlet`简化 Web 服务的创建
*   在 JMS 传输上设置 Web 服务
*   在电子邮件传输上设置 Web 服务
*   在嵌入式 HTTP 服务器传输上设置 Web 服务
*   在 XMPP 传输上设置 Web 服务
*   为 Web 服务设置简单的端点映射
*   设置契约优先 Web 服务
*   通过注释有效负载根来设置端点
*   设置与传输无关的 WS-Addressing 端点
*   使用 XPath 表达式设置端点
*   使用 DOM 处理传入的 XML 消息
*   使用 JDOM 处理传入的 XML 消息
*   使用 JAXB2 处理传入的 XML 消息
*   使用拦截器在服务器端验证 XML 消息

# 导言

SOAP（Simple Object Access Protocol，简单对象访问协议）被设计为独立于语言、传输和平台，是传统中间件技术（如 CORBA 和 DCOM）的替代品。SOAP 也被设计为可扩展的。被称为 WS-*-WS-Addressing、WS-Policy、WS-Security 等的标准是基于 SOAP 协议构建的。

使用 SOAP 以及 WSDL 和 XML 模式的 Web 服务已经成为交换基于 XML 的消息的标准。SpringWeb 服务通过为创建灵活的 Web 服务提供一组全面的 API 和配置来促进 SOAP 服务的开发。下图显示了 SpringWS 在接收到传入消息时的工作方式（该图为抽象形式）：

![Introduction](graphics/5825_01_01.jpg)

`MessageDispatcher`是 SpringWeb 服务的中心点，将 Web 服务消息发送到注册的端点。在 SpringWS 中，请求/响应消息被包装在 `MessageContext`对象中， `MessageContext`将被传递到 `MessageDispatcher`（响应将在调用端点后被设置到 MessageContext 中）。消息到达时，MessageDispatcher 使用请求对象获取端点。（将请求映射到端点称为**端点映射**，可以通过使用应用程序上下文中的 bean 注册、扫描和自动检测注释中的数据来完成）。然后， `MessageDispatcher`通过使用端点，获取 endpopint 的拦截器（范围从零到多），并对其调用 HandlerRequest 方法。

顾名思义，拦截器（`EndpointInterceptor`在调用端点之前（针对请求）/之后（针对响应）截取请求/响应以执行一些操作。此 `EndpointInterceptor`在调用相应端点之前/之后被调用，以执行多个处理方面，如日志记录、验证、安全性等。接下来， `MessageDispatcher`为要调用的端点方法获取适当的端点适配器。此适配器提供了与各种类型的端点方法的兼容性。每个适配器专用于调用具有特定方法参数和返回类型的方法。

最后， `EndpointAdapter`调用端点的方法，将响应转换为所需的形式，并将其设置为 `MessageContext`对象。现在，传递给 `MessageDispatcher`的初始消息上下文包含响应对象，该对象将转发给客户端（由 `MessageDispatcher)`的调用者）

SpringWS 只支持契约优先的开发风格，其中创建契约（XSD 或 WSDL）是第一步。使用 SpringWS 构建契约优先 Web 服务所需的步骤如下：

1.  契约定义（XSD 或 WSDL）
2.  创建端点：接收和处理传入消息的类。
3.  SpringBean 和端点的配置。

有两种类型的端点，即有效负载端点和消息端点。虽然消息端点可以访问整个 XML SOAP 信封，但有效负载端点将只访问 SOAP 信封的有效负载部分，即 SOAP 信封的主体。在本书中，重点是创建有效负载端点。

在本章中，在解释了如何从一组 XML 消息创建契约之后，重点将放在实现端点及其相关配置上。

为了说明 Web 服务的构建过程，本书使用了一个简单的虚拟餐厅 LiveRestaurant 的业务场景，它需要接受客户的在线订单。Live Restaurant 决定将其 `OrderService`组件发布为 Web 服务。为简单起见， `OrderService`（Java 接口）只考虑两个操作。

![Introduction](graphics/5825_01_02.jpg)

本项目将遵循以下领域模型：

![Introduction](graphics/5825_01_03.jpg)

本书中的每个配方都将逐步构建项目的一部分，使其成为一个完整的 Web 服务应用程序。Java 项目名称为 `LiveRestaurant`，每个配方将使用稍微不同的项目版本，扩展名为 `_R-x.x`。例如，本章中的第一个配方将使用 `LiveRestaurant_R-1.1`作为 Web 服务服务器， `LiveRestaurant_R-1.1-Client for the client`作为项目名称。

### 注

设置一个 Web 服务是本章的目标，因此更多的重点是解释服务器端代码和设置。本章使用客户端代码检查服务器的功能。有关客户端代码、设置和测试的更多信息将在以下章节中讨论。

# 使用 Maven 构建和运行 SpringWS 项目

最近的现代软件开发基于企业级开源技术，需要新一代的构建和项目管理工具。这些工具可以成为构建、管理和部署小规模到大规模应用程序的标准方法。

由 Apache 软件基金会主办的 Maven 是一个项目管理和自动化的构建和部署工具。Maven 基于 Ant 的特性构建，并添加了一些特性，如特性依赖性和项目管理。Maven 最初用于 Java 编程，但也可以用于构建和管理用其他编程语言编写的项目。近年来，Maven 已被用于自动化构建、管理和测试主要开源项目部署的过程。

本食谱详细介绍了为构建、测试和部署本书中使用的项目而设置 Maven 所需的步骤。

## 准备好了吗

此配方需要安装以下软件或工具：

1.  Java 6 或更高版本和 Maven 3.0.2：下载和安装请参考[http://maven.apache.org/](http://maven.apache.org/) 和[http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html) 。
2.  Add your custom repositories to `settings.xml` under `MAVEN_HOME/conf` or `.m2` folders `(MAVEN_HOME` is the folder in which Maven is installed and `.m2` is the folder in which Maven downloads its artifacts to).

    稍后，您可以向自定义存储库添加额外的存储库。您可以通过将`activeByDefault`设置为`false`来禁用此存储库（包含存储库的文件位于`resources`文件夹中）：

    ```
    <profile>
    <id>my-repository</id>
    <activation>
    <activeByDefault>true</activeByDefault>
    </activation>
    <!-- list of standard repository -->
    <repositories>
    ...
    ...
    <repository>
    <id>maven2-repository.java.net</id>
    <name>Java.net Repository for Maven</name>
    <url>http://download.java.net/maven/2</url>
    </repository>
    ....
    <repository>
    <id>maven1-repository.java.net</id>
    <name>Java.net Repository for Maven</name>
    <url>http://download.java.net/maven/1</url>
    </repository>
    </repositories>
    </profile>

    ```

将 Maven 存储库包含到 Maven 构建中的另一种方法是直接在 POM 文件中包含存储库数据。这两种包含存储库的方法的示例都包含在本章资源包的 `Using Maven`文件夹下。

## 怎么做。。。

1.  构建和部署项目。

    ```
    mvn clean package tomcat:run

    ```

2.  浏览以下 Web 服务 WSDL 文件：

    ```
    http://localhost:8080/LiveRestaurant/OrderService.wsdl

    ```

3.  以下是浏览器的输出：

    ```
    <wsdl:definitions
    targetNamespace="http://www.packtpub.com/liverestaurant/OrderService/schema">
    <wsdl:types>
    <schema elementFormDefault="qualified" targetNamespace="http://www.packtpub.com/liverestaurant/OrderService/schema">
    <element name="placeOrderRequest">
    <complexType>
    <sequence>
    <element name="order" type="QOrder:Order" />
    </sequence>
    </complexType>
    ........
    </schema>
    </wsdl:types>
    .......
    <wsdl:binding name="OrderServiceSoap11" type="tns:OrderService">
    <soap:binding style="document"
    transport="http://schemas.xmlsoap.org/soap/http" />
    <wsdl:operation name="placeOrder">
    <soap:operation soapAction="" />
    <wsdl:input name="placeOrderRequest">
    <soap:body use="literal" />
    </wsdl:input>
    <wsdl:output name="placeOrderResponse">
    <soap:body use="literal" />
    </wsdl:output>
    </wsdl:operation>
    <wsdl:operation name="cancelOrder">
    <soap:operation soapAction="" />
    <wsdl:input name="cancelOrderRequest">
    <soap:body use="literal" />
    </wsdl:input>
    <wsdl:output name="cancelOrderResponse">
    <soap:body use="literal" />
    </wsdl:output>
    </wsdl:operation>
    </wsdl:binding>
    <wsdl:service name="OrderServiceService">
    <wsdl:port binding="tns:OrderServiceSoap11" name="OrderServiceSoap11">
    <soap:address
    location="http://localhost:8080/LiveRestaurant/spring-ws/OrderService" />
    </wsdl:port>
    </wsdl:service>
    </wsdl:definitions>

    ```

4.  以下是 Maven 命令的输出：

```
...........
[INFO] Building war: C:\...\LiveRestaurant.war
.......
[INFO] --- tomcat-maven-plugin:1.1:run ...@ LiveRestaurant ---
[INFO] Running war on http://localhost:8080/LiveRestaurant
[INFO] Creating Tomcat server configuration ...
Oct 15,...org.apache.catalina.startup.Embedded start
INFO: Starting tomcat server
Oct 15...org.apache.catalina.core.StandardEngine start
INFO: Starting Servlet Engine: Apache Tomcat/6.0.29
org.apache.catalina.core.ApplicationContext log
...Set web app root ..: 'webapp.root' = [...src\main\webapp\]
INFO: Initializing log4j from..WEB-INF\log4j.properties]
...
INFO: Initializing Spring FrameworkServlet 'spring-ws'
......
INFO .. - FrameworkServlet 'spring-ws': initialization ..
Oct .. org.apache.coyote.http11.Http11Protocol init
INFO: Initializing Coyote HTTP/1.1 on http-8080
Oct .. org.apache.coyote.http11.Http11Protocol start
INFO: Starting Coyote HTTP/1.1 on http-8080 

```

### 注

要将 Maven 项目导入 Eclipse IDE，请执行以下操作：

转到项目的根目录（\chapterOne\LiveRestaurant\u R-1.1）并执行：

```
mvn eclipse:eclipse -Declipse.projectNameTemplate="LiveRestaurant_R-1.1" 

```

然后，您可以将 Maven 项目作为 Eclipse 项目导入。

如果 Maven 找不到 JAR 文件，可以使用以下命令使用自定义存储库：

```
mvn -P my-repository clean package tomcat:run 

```

## 它是如何工作的。。。

`mvn clean package`将所需组件安装到本地存储库中，并创建项目的 WAR/JAR 文件：

```
[INFO] Building war: ...LiveRestaurant.war 

```

`mvn tomcat:run`在 Tomcat 插件上运行项目的 WAR 文件。 `mvn jetty:run`在 Jetty 插件上运行项目的 WAR 文件：

```
INFO] --- tomcat-maven-plugin:1.1:... LiveRestaurant ---
[INFO] Running war on http://localhost:8080/LiveRestaurant
[INFO] Creating Tomcat server configuration at 

```

# 创建数据合约

WSDL 文档（称为服务契约）提供了 Web 服务客户机和服务器交换数据的标准方式。使用 WSDL，客户机和服务器可以位于不同的应用程序或平台上。XML 模式定义（XSD），称为数据契约，描述 Web 服务服务器和客户端之间交换的数据类型的结构。XSD 描述了类型、字段以及这些字段上的任何验证（如 max/min 或 pattern 等）。而 WSDL 是特定于 Web 服务的，并描述 Web 服务的构件，例如通过这些方法传递的方法和数据（WSDL 本身使用 XSD）、URL 等等；XSD 只显示数据的结构。

为了能够建立 SpringWeb 服务，我们需要一个合同。有四种不同的方法可以为 XML 定义这样的契约：

*   DTD
*   XML 模式（XSD）
*   放松
*   Schematron

DTD 的命名空间支持有限，因此不适合 Web 服务。RELAXNG 和 Schematron 当然比 XMLSchema 更容易。不幸的是，它们在不同的平台上并没有得到广泛的支持。SpringWS 使用 XML 模式。

数据契约是 SpringWS 的中心，可以从数据契约生成服务契约。创建 XSD 的最简单方法是从示例文档推断它。任何好的 XML 编辑器或 JavaIDE 都提供此功能。基本上，这些工具使用一些示例 XML 文档并从中生成一个模式来验证它们。在此配方中，我们将讨论示例 XML 数据消息以及如何将它们转换为单个模式文件。生成的模式在本书中用作数据契约。

## 准备好了吗

1.  安装 Java（如第一个配方中所述）。
2.  从[安装 xmlbeans-2.5.0http://xmlbeans.apache.org/](http://xmlbeans.apache.org/) 。
3.  此配方的资源包含在文件夹 Create Data Contract 中。

## 怎么做。。。

1.  将您的 XML 消息 `(placeOrderRequest.xml, placeOrderResponse, cancelOrderRequest.xml`和 `cancelOrderResponse.xml)`复制到 `xmlbeans-2.5.0\bin`工作文件夹中。
2.  运行以下命令：

    ```
    inst2xsd -design rd -enumerations never placeOrderRequest.xml placeOrderResponse.xml cancelOrderRequest 

    ```

3.  前面的命令创建了 `schema0.xsd`模式文件。生成的模式结果当然需要修改，但这是一个很好的起点。这是最终的抛光方案`(orderService.xsd)`：

    ```
    <?xml version="1.0" encoding="UTF-8"?>
    ......
    <schema...">
    <element name="placeOrderRequest">
    <complexType>
    <sequence>
    <element name="order" type="QOrder:Order"></element>
    </sequence>
    </complexType>
    </element>
    <element name="placeOrderResponse">
    <complexType>
    <sequence>
    <element name="refNumber" type="string"></element>
    </sequence>
    </complexType>
    </element>
    .........
    data contractdata contractcreating<complexType name="Order">
    <sequence>
    <element name="refNumber" type="string"></element>
    <element name="customer" type="QOrder:Customer"></element>
    <element name="dateSubmitted" type="dateTime"></element>
    <element name="orderDate" type="dateTime"></element>
    <element name="items" type="QOrder:FoodItem"
    maxOccurs="unbounded" minOccurs="1">
    </element>
    </sequence>
    </complexType>
    <complexType name="Customer">
    <sequence>
    <element name="addressPrimary" type="QOrder:Address"></element>
    <element name="addressSecondary" type="QOrder:Address"></element>
    <element name="name" type="QOrder:Name"></element>
    </sequence>
    </complexType>
    ....
    </schema>

    ```

### 它是如何工作的。。。

最初，需要输入和输出示例消息。在本书中，有四条 XML 消息（placeOrderRequest.XML、 `placeOrderResponse, cancelOrderRequest.xml`和 `cancelOrderResponse.xml)`，所有配方都使用这些消息数据格式进行通信。 `Inst2xsd`从现有的 XML 示例消息生成一个模式文件。此配方的资源包含在本章资源包的 `Create Data Contract`文件夹下。

# 使用 DispatcherServlet 设置 Web 服务

SpringWS 提供了在 Java 平台上开发 Web 服务的最简单机制之一。这个方法着重于使用 SpringMVC `DispatcherServlet`和 SpringWS 提供的组件构建一个非常简单的 Web 服务。

## 准备好了吗

在此配方中，项目名称为 `LiveRestaurant_R-1.2`，具有以下 Maven 依赖项：

*   `spring-ws-core-2.0.1.RELEASE.jar`
*   `log4j-1.2.9.jar`

## 怎么做。。。

1.  从 `resources`文件夹`(orderService.wsdl).`复制服务合同
2.  创建端点`(OrderSeviceMessageReceiverEndpoint)`。
3.  在服务器 Spring 配置文件`(Dispatcher-servlet.xml)` 中配置端点、服务合约 `WebServiceMessageReceiverHandlerAdapter, MessageDispatcher`和 `WsdlDefinitionHandlerAdapter`。
4.  在 `web.xml`文件中配置 `DispatcherServlet`。
5.  使用以下命令运行服务器：

    ```
    mvn clean package tomcat:run 

    ```

    ```
    ...........................
    [INFO] Running war on http://localhost:8080/LiveRestaurant
    ...................................
    18-Oct-2011 10:23:02.....ApplicationContext log
    INFO: Initializing Spring FrameworkServlet 'Dispatcher'
    18-Oct-2011 10:23:02 org.apache.coyote.http11.Http11Protocol init
    INFO: Initializing Coyote HTTP/1.1 on http-8080
    18-Oct-2011 10:23:02 org.apache.coyote.http11.Http11Protocol start
    INFO: Starting Coyote HTTP/1.1 on http-8080 

    ```

    *   以下是输出：
6.  要浏览您的服务 WSDL，请在浏览器中打开以下链接：

    ```
    http://localhost:8080/LiveRestaurant/Dispatcher/OrderService.wsdl

    ```

7.  要进行测试，请打开一个新的命令窗口，转到文件夹 `LiveRestaurant_R-1.2-Client`，然后运行以下命令：

```
mvn clean package exec:java 

```

*   以下是服务器端输出：

```
Inside method, OrderSeviceMethodEndpoint.receive - message content = <?xml version="1.0" encoding="UTF-8"?><tns:placeOrderRequest xmlns:tns="http://www.packtpub.com/liverestaurant/OrderService/schema">
<tns:order>
<tns:refNumber>9999</tns:refNumber>
<tns:customer>
........
</tns:customer>
<tns:dateSubmitted>2008-09-29T05:49:45</tns:dateSubmitted>
<tns:orderDate>2014-09-19T03:18:33</tns:orderDate>
<!--1 or more repetitions:-->
<tns:items>
<tns:type>Snacks</tns:type>
<tns:name>Pitza</tns:name>
<tns:quantity>2</tns:quantity>
</tns:items>
</tns:order>
</tns:placeOrderRequest> 

```

## 它是如何工作的。。。

`DispatcherServlet`接收所有传入的请求，并根据请求上下文将请求转发给端点（请求 URL 的一般形式为 `http://<host>:<port>/<appcontext>/<requestcontext>`（此处 `appcontext`为 Liverestaurant， `requestcontext`应以 `/Dispatcher/)`开头）。以 `/OrderService`结尾的请求上下文转到 `OrderSeviceMessageReceiverEndpoint`，以 `*.wsdl`结尾的请求转到 `SimpleWsdl11Definition)`。

`web.xml`中配置的`DispatcherServlet`负责接收 URL 映射为 `[/Dispatcher/*]`的所有请求。

```
<servlet>
<servlet-name>Dispatcher</servlet-name>
<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
<load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
<servlet-name>Dispatcher</servlet-name>
<url-pattern>/Dispatcher/*</url-pattern>
</servlet-mapping>

```

您可以更改 URL 模式以满足您的需求。

`DispatcherServlet`在拦截 HTTP 请求并加载 Springbean 配置文件方面起主要作用。默认情况下，它通过名称`<servlet-name>-servlet.xml`检测 bean 配置文件。因为我们在 `web.xml`文件中将 `DispatcherServlet`命名为 `Dispatcher`，所以服务器会将 `Dispatcher-servlet.xml`作为应用程序上下文文件名。您可以使用 `web.xml:`中的以下上下文 `param`配置另一个文件

```
<context-param>
<param-name>contextConfigLocation</param-name>
<param-value>/WEB-INF/classes/applicationContext.xml</param-value>
</context-param>

```

`DispatcherServlet`需要单独的 `WebServiceMessageReceiverHandlerAdapter, MessageDispatcher`实例，本配方中的 `WsdlDefinitionHandlerAdapter`实例配置在 `Dispatcher-servlet.xml`中。默认情况下， `DispatcherServlet`委托给控制器处理请求，但在配置文件中，它被配置为委托给 `MessageDispatcher``(WebServiceMessageReceiverHandlerAdapter). SaajSoapMessageFactory`是 Spring WS 中创建消息的特定消息工厂。

```
<beans ...">
<bean class="org.springframework.ws.transport.http.WebServiceMessageReceiverHandlerAdapter">
<property name="messageFactory">
<bean class="org.springframework.ws.soap.saaj.SaajSoapMessageFactory"></bean>
</property>
</bean>
.......

```

让 `DispatcherServlet`处理配置文件中注册的 WSDL 契约 `WsdlDefinitionHandlerAdapter`；它使用 `WsdlDefinition`实现`(SimpleWsdl11Definition)`读取 WSDL 文件源，并将结果写入 `HttpServletResponse`。

`SimpleUrlHandlerMapping`是使用 URL 模式将客户端请求重定向到适当的端点。此处以 `*.wsdl`结尾的请求 URL 将被重定向到 `sampleServiceDefinition`（即使用 `OrderService.wsdl`生成响应的 `SimpleWsdl11Definition`，如果请求 URL 包含 `/OrderService`，则将被重定向到 `OrderSeviceMessageReceiverEndpoint. SOAPMessageDispatcher`是向注册的端点`(OrderSeviceMessageReceiverEndpoint)`发送 SOAP 消息。

```
.......
<bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping">
<property name="mappings">
<props>
<prop key="*.wsdl">sampleServiceDefinition</prop>
<prop key="/OrderService">OrderServiceEndpoint</prop>
</props>
</property>
<property name="defaultHandler" ref="messageDispatcher"/>
</bean>
<bean id="messageDispatcher" class="org.springframework.ws.soap.server.SoapMessageDispatcher"/>
<bean id="OrderServiceEndpoint" class="com.packtpub.liverestaurant.service.endpoint.OrderSeviceMessageReceiverEndpoint"/>
<bean class="org.springframework.ws.transport.http.WsdlDefinitionHandlerAdapter"/>
<bean id="sampleServiceDefinition" class="org.springframework.ws.wsdl.wsdl11.SimpleWsdl11Definition">
<property name="wsdl" value="/WEB-INF/OrderService.wsdl"/>
</bean>
</beans>
OrderSeviceMessageReceiverEndpoint is a very basic endpoint that get incoming message (messageContext.getRequest().getPayloadSource()) and prin it out:
........
public class OrderSeviceMessageReceiverEndpoint implements
WebServiceMessageReceiver {
public OrderSeviceMessageReceiverEndpoint() {
}
public void receive(MessageContext messageContext) throws Exception {
System.out
.println("Inside method, OrderSeviceMethodEndpoint.receive - message content = "
+ xmlToString(messageContext.getRequest().getPayloadSource()));
}

```

### 提示

您可以更改 URL 模式以满足您的需求。

```
private String xmlToString(Source source) {
try {
StringWriter stringWriter = new StringWriter();
Result result = new StreamResult(stringWriter);
TransformerFactory factory = TransformerFactory.newInstance();
Transformer transformer = factory.newTransformer();
transformer.transform(source, result);
return stringWriter.getBuffer().toString();
} catch (TransformerConfigurationException e) {
e.printStackTrace();
} catch (TransformerException e) {
e.printStackTrace();
}
return null;
}
}

```

## 另见

本章中的*使用 MessageDispatcherServlet*方法设置 Web 服务。

# 使用 MessageDispatcherServlet 简化 Web 服务的创建

`MessageDispatcherServlet`是 Spring WS 的核心部件。通过简单的配置，可以在几分钟内设置 Web 服务。这个 servlet 是一种配置 SpringMVC `DispatcherServlet`替代品的简单方法。与第二个方法一样，*使用 DispatcherServlet*设置 Web 服务， `DispatcherServlet`需要单独的 `WebServiceMessageReceiverHandlerAdapter, MessageDispatcher`和 `WsdlDefinitionHandlerAdapter`实例。但是， `MessageDispatcherServlet`可以通过在应用程序上下文中设置来动态检测 `EndpointAdapters, EndpointMappings, EndpointExceptionResolvers`和 `WsdlDefinition`。

由于这是配置 SpringWeb 服务的默认方法，因此将在以后的食谱中使用。在此配方中，详细介绍了设置 SpringWS 的一个非常基本的实现。更多的高级实现将在后面的*创建契约优先 Web 服务*中解释。

## 准备好了吗

在此配方中，项目名称为 `LiveRestaurant_R-1.3`，具有以下 Maven 依赖项：

*   `spring-ws-core-2.0.1.RELEASE.jar`
*   `log4j-1.2.9.jar`

## 怎么做。。。

1.  从 `resources`文件夹`(orderService.wsdl)`中复制服务合同。
2.  创建端点`(OrderSeviceMethodEndpoint)`。
3.  配置端点。服务合约在服务器 Spring 配置文件`(spring-ws-servlet.xml)`中。
4.  在 `web.xml`文件中配置 `MessageDispatcherServlet`。
5.  使用以下命令运行服务器：

    ```
    mvn clean package tomcat:run 

    ```

    ```
    ...........................
    [INFO] >>> tomcat-maven-plugin:1.1:run .. LiveRestaurant >>>
    [..............
    [INFO] Running war on http://localhost:8080/LiveRestaurant
    [I...........
    ..XmlBeanDefinitionReader.. Loading..spring-ws-servlet.xml]
    ...
    ..SimpleMethodEndpointMapping#0, OrderService, OrderServiceEndpoint]; root of factory hierarchy
    INFO [main] (SaajSoapMessageFactory.java:135) -..
    INFO [main] (FrameworkServlet.java:320) - FrameworkServlet '
    ........
    INFO: Starting Coyote HTTP/1.1 on http-8080 

    ```

    *   以下是服务器成功运行后的输出：
6.  要浏览您的服务 WSDL，请在浏览器中打开以下链接：

    ```
    http://localhost:8080/LiveRestaurant/spring-ws/OrderService.wsdl

    ```

7.  要进行测试，请打开一个新的命令窗口，转到文件夹 `LiveRestaurant_R-1.3-Client`，然后运行以下命令：

```
mvn clean package exec:java 

```

*   以下是服务器端输出：

```
Sent response
...
<tns:placeOrderResponse....>
<tns:refNumber>order-John_Smith_1234</tns:refNumber>
</tns:placeOrderResponse>
.....
for request
<tns:placeOrderRequest.... >
<tns:order>
<tns:refNumber>9999</tns:refNumber>
<tns:customer>
........
</tns:customer>
<tns:dateSubmitted>2008-09-29T05:49:45</tns:dateSubmitted>
<tns:orderDate>2014-09-19T03:18:33</tns:orderDate>
<!--1 or more repetitions:-->
<tns:items>
<tns:type>Snacks</tns:type>
<tns:name>Pitza</tns:name>
<tns:quantity>2</tns:quantity>
</tns:items>
</tns:order>
.... 

```

## 它是如何工作的。。。

`MessageDispatcherServlet`在 web 配置文件 `web.xml:`中配置

```
<servlet>
<servlet-name>spring-ws</servlet-name>
<servlet-class>
org.springframework.ws.transport.http.MessageDispatcherServlet</servlet-class>
<load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
<servlet-name>spring-ws</servlet-name>
<url-pattern>/*</url-pattern>
</servlet-mapping>

```

### 提示

**下载示例代码**

您可以下载您在[账户购买的所有 Packt 书籍的示例代码文件 http://www.PacktPub.com](http://www.PacktPub.com) 。如果您在其他地方购买了本书，您可以访问[http://www.PacktPub.com/support](http://www.PacktPub.com/support) 并注册，将文件直接通过电子邮件发送给您。

`MessageDispatcherServlet`是在其他组件`(EndpointAdapters, EndpointMappings, EndpointExceptionResolvers`和 `WsdlDefinition)`的帮助下处理传入 SOAP 请求的中心元素。它结合了 `DispatcherServlet`和 `MessageDispatcher`的属性，将其分派到适当的端点。这是建议使用 SpringWS 构建 Web 服务的标准 servlet。

由于 `MessageDispatcherServlet`是从 `FrameworkServlet`继承而来的，因此它在类路径中查找名为`<servlet-name>-servlet.xml`的配置文件（您可以使用 `web.xml`中的 `context-param, contextConfigLocation`设置来更改配置文件名，如*使用 DispatcherServlet 设置 Web 服务*中所述。在本例中，由于 `web.xml`文件中的 servlet 名称设置为 Spring WS，因此文件 `spring-ws-servlet.xml`是 Web 服务配置文件。

`MessageDispatcherServlet`然后在配置文件中查找端点映射元素，以便将客户端请求映射到端点。这里，`<sws:static-wsdl`以 WSDL 格式设置数据契约。这是 `spring-ws-servlet.xml`中要配置的元素，用于设置 Web 服务：

```
<bean class="org.springframework.ws.server.endpoint.mapping.SimpleMethodEndpointMapping">
<property name="endpoints">
<ref bean="OrderServiceEndpoint"/>
</property>
<property name="methodPrefix" value="handle"></property>
</bean>
<sws:static-wsdl id="OrderService" location="/WEB-INF/orderService.wsdl"/>
<bean id="OrderServiceEndpoint" class="com.packtpub.liverestaurant.service.endpoint.OrderSeviceMethodEndpoint">
</bean>

```

该示例使用将客户端请求映射到 `MethodEnpoints`的 `SimpleMethodEndpointMapping`。它将传入请求映射到以消息 `(handle+placeOrderRequest)`的 `handle+root`元素开头的方法。在端点类中，应定义`(OrderSeviceMethodEndpoint), a method with the name handleplaceOrderRequest`。

在该方法中，参数源包括传入消息，可以从该参数中提取呼叫订单服务的输入参数，然后该方法调用 `orderService`方法，并将传出消息包装在 `StringSource`中，发送回客户端：

```
public class OrderSeviceMethodEndpoint {
OrderService orderService;
public void setOrderService(OrderService orderService) {
this.orderService = orderService;
}
public @ResponsePayload
Source handleplaceOrderRequest(@RequestPayload Source source) throws Exception {
//extract data from input parameter
String fName="John";
String lName="Smith";
String refNumber="1234";
return new StringSource(
"<tns:placeOrderResponse xmlns:tns=\"http://www.packtpub.com/liverestaurant/OrderService/schema\"><tns:refNumber>"+orderService.placeOrder(fName,lName,refNumber)+"</tns:refNumber></tns:placeOrderResponse>");
}

```

端点映射将在后面的配方中详细介绍。

## 另见

本章讨论的方法*使用 DispatcherServlet 设置 Web 服务，为 Web 服务*设置简单的端点映射，以及*设置契约优先 Web 服务*。

# 在 JMS 传输上设置 Web 服务

HTTP 是最常见的 Web 服务协议。但是，Web 服务目前构建在多个传输上，每个传输具有不同的场景。

1999 年，Sun Microsystems 将 JMS 包括在 Java2、J2EE 中。使用 JMS，系统能够同步或异步通信，并且基于点对点和发布-订阅模型。SOAP over JMS 继承了 JSM 特性并满足以下要求：

*   其中需要异步消息传递
*   消息使用者比生产者慢的地方
*   保证信息的传递
*   拥有发布者/订阅者（多个）模型
*   发送方/接收方可能断开连接的时间

SpringWeb 服务提供了在 Spring 框架中基于 JMS 功能构建的 JMS 协议上设置 Web 服务的功能。在此配方中，介绍了如何设置 SpringWS-overJMS。

## 准备好了吗

在此配方中，项目名称为 `LiveRestaurant_R-1.4`，具有以下 Maven 依赖项：

*   `spring-ws-core-2.0.1.RELEASE.jar`
*   `spring-ws-support-2.0.1.RELEASE.jar`
*   `spring-test-3.0.5.RELEASE.jar`
*   `spring-jms-3.0.5.RELEASE.jar`
*   `junit-4.7.jar`
*   `xmlunit-1.1.jar`
*   `log4j-1.2.9.jar`
*   `jms-1.1.jar`
*   `activemq-core-4.1.1.jar`

在此配方中，ApacheActiveMQ 用于设置 JMS 服务器并创建与 JMS 服务器相关的对象（此处使用队列和代理）。SpringWS 系列 JAR 提供了设置 SpringWS 的功能， `spring-jms`和 `jms`JAR 提供了 SpringWS 基于 JMS 构建的 JMS 功能。

## 怎么做。。。

1.  创建端点`(OrderSeviceMethodEndpoint)`。
2.  在 Spring 配置文件（`applicationContext.xml`中配置 `MessageListenerContainer, MessageListener`和 `connectionFactory`。
3.  配置包含 `applicationContext.xml`内端点映射的 `MessageDispatcher`。
4.  使用以下命令运行配方项目：

    ```
    mvn clean package 

    ```

5.  以下是项目成功运行后的输出：

```
INFO [main] (SaajSoapMessageFactory.java:135) -..
INFO [main] (DefaultLifecycleProcessor.java:330) -..
INFO [main] .. - ActiveMQ 4.1.1 JMS Message Broker (localhost)..
..
INFO [JMX connector] ..
INFO [main]..ActiveMQ JMS Message Broker ..started
INFO [main] ..- Connector vm://localhost Started
.....
Received response ....
<tns:placeOrderResponse ..><tns:refNumber>..</tns:refNumber>
</tns:placeOrderResponse>....
for request ....
<tns:placeOrderRequest ....>
<tns:order>
<tns:refNumber>9999</tns:refNumber>
<tns:customer>
.....
</tns:customer>
<tns:dateSubmitted>2008-09-29T05:49:45</tns:dateSubmitted>
<tns:orderDate>2014-09-19T03:18:33</tns:orderDate>
<!--1 or more repetitions:-->
<tns:items>
<tns:type>Snacks</tns:type>
<tns:name>Pitza</tns:name>
<tns:quantity>2</tns:quantity>
</tns:items>
</tns:order>
</tns:placeOrderRequest>
........ 

```

## 它是如何工作的。。。

`DefaultMessageListenerContainer`监听 `destinationName``(RequestQueue)`接收消息。当消息到达时，此侦听器将使用消息工厂`(messageFactory)`提取消息，并使用分派器`(messageDispatcher)`将消息分派到端点`(SimplePayloadEndpoint)`。。。。。。。。。。。。。

在应用程序上下文中， `WebServiceMessageListener`是 `MessageListenerContainer`中的侦听器。消息容器使用 `connectionfactory`连接到目的地（RequestQueue）：

```
<bean id="connectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory">
<property name="brokerURL" value="vm://localhost?broker.persistent=false"/>
</bean>
<bean id="messageFactory" class="org.springframework.ws.soap.saaj.SaajSoapMessageFactory"/>
<bean class="org.springframework.jms.listener.DefaultMessageListenerContainer">
<property name="connectionFactory" ref="connectionFactory"/>
<property name="destinationName" value="RequestQueue"/>
<property name="messageListener">
<bean class="org.springframework.ws.transport.jms.WebServiceMessageListener">
<property name="messageFactory" ref="messageFactory"/>
<property name="messageReceiver" ref="messageDispatcher"/>
</bean>
</property>
</bean>

```

此侦听器使用 `message Dispatcher`和 `messageFactory`接收传入消息并发送传出 SOAP 消息。 `messageDiapatcher`内包含端点映射，设置端点 `(SimplePayloadEndpoint)`和端点映射类型 `(PayloadRootQNameEndpointMapping)`：

```
<bean id="messageDispatcher" class="org.springframework.ws.soap.server.SoapMessageDispatcher">
<property name="endpointMappings">
<bean class="org.springframework.ws.server.endpoint.mapping.PayloadRootQNameEndpointMapping">
<property name="defaultEndpoint">
<bean class="com.packtpub.liverestaurant.service.endpoint.SimplePayloadEndpoint">
<property name="orderService">
<bean class="com.packtpub.liverestaurant.service.OrderServiceImpl"/>
</property>
</bean>
</property>
</bean>
</property>
</bean>

```

当服务器收到请求时，将调用来自端点`(SimplePayloadEndpoint)`的 `invoke`方法，并返回响应发送回客户端：

```
public class SimplePayloadEndpoint implements PayloadEndpoint {
OrderService orderService;
public void setOrderService(OrderService orderService) {
this.orderService = orderService;
}
public Source invoke(Source request) throws Exception {
//extract data from input parameter
String fName="John";
String lName="Smith";
String refNumber="1234";
return new StringSource(
"<tns:placeOrderResponse xmlns:tns=\"http://www.packtpub.com/liverestaurant/OrderService/schema\"><tns:refNumber>"+orderService.placeOrder(fName, lName, refNumber)+"</tns:refNumber></tns:placeOrderResponse>");
}

```

`JmsTransportWebServiceIntegrationTest`包含在项目中，用于加载应用程序上下文、设置 JMS 服务器和测试 Web 服务。然而，这里不讨论这些细节。JMS 传输的客户端将在下一章中讨论。

## 另见

[第 2 章](02.html "Chapter 2. Building Clients for SOAP Web-Services")中讨论的*在 JMS 传输上创建 Web 服务客户端*配方、*为 SOAP Web 服务构建客户端*和*在[第 10 章](10.html "Chapter 10. Spring Remoting")、*中讨论的*公开使用 JMS 作为底层通信协议的 Web 服务*配方春季远程处理。**

# 在电子邮件传输上设置 Web 服务

HTTP 很容易理解，因此经常被定义和实现，但在任何情况下，它显然都不是最适合 Web 服务的传输。

电子邮件传输上的 Web 服务可以利用存储转发消息传递为 SOAP 提供异步传输。此外，电子邮件上没有防火墙问题，那些能够一起通信的应用程序不需要 web 服务器来设置 web 服务。这允许通过邮件传输的 SOAP 在 HTTP 不适用的许多场景中使用。

下面列出了通过 HTTP 设置 Web 服务不合适的原因，以及电子邮件可能是作为传输协议的解决方案的原因：

*   如果系统受防火墙保护，则无法控制 HTTP 请求/响应，但电子邮件始终可以访问。
*   如果系统不需要请求/响应，则使用传统模型。例如，需要发布/订阅服务器模型。
*   如果请求需要太长时间才能完成。例如，如果服务器必须运行复杂且耗时的服务，客户端将收到 HTTP 超时错误。在这种情况下，电子邮件上的 Web 服务更合适。

在此配方中，介绍了通过电子邮件传输设置 Web 服务。要加载应用程序上下文并测试 Web 服务，需要使用测试类。此类还启动和关闭服务器。

## 准备好了吗

在此配方中，项目名称为 `LiveRestaurant_R-1.5`，具有以下 Maven 依赖项：

*   `spring-ws-core-2.0.1.RELEASE.jar`
*   `spring-ws-support-2.0.1.RELEASE.jar`
*   `spring-test-3.0.5.RELEASE.jar`
*   `mail-1.4.1.jar`
*   `mock-javamail-1.6.jar`
*   `junit-4.7.jar`
*   `xmlunit-1.1.jar`

在使用 JavaMail 进行测试的系统之外设置邮件服务器是困难的。Mock JavaMail 解决了这个问题，并使用 JavaMail 为系统提供了一个可插入组件。系统可以使用此组件发送/接收针对内存中临时*邮箱*的电子邮件。

## 怎么做。。。

1.  创建端点`(SimplePayloadEndpoint)`。
2.  在 `applicationContext.xml`中配置包含端点映射的 `MessageReceiver`和 `MessageDispatcher`。
3.  使用以下命令运行配方项目：

```
mvn clean package 

```

*   以下是输出：

```
........
INFO [main] ...- Creating SAAJ 1.3 MessageFactory with SOAP 1.1 Protocol
..- Starting mail receiver [imap://server@packtpubtest.com/INBOX]
....
Received response...
<tns:placeOrderResponse xmlns:tns="....">
<tns:refNumber>...</tns:refNumber></tns:placeOrderResponse>
...for request ..
<tns:placeOrderRequest xmlns:tns="...">
<tns:order>
<tns:refNumber>9999</tns:refNumber>
<tns:customer>
....
</tns:customer>
<tns:dateSubmitted>2008-09-29T05:49:45</tns:dateSubmitted>
<tns:orderDate>2014-09-19T03:18:33</tns:orderDate>
<!--1 or more repetitions:-->
<tns:items>
<tns:type>Snacks</tns:type>
<tns:name>Pitza</tns:name>
<tns:quantity>2</tns:quantity>
</tns:items>
</tns:order>
</tns:placeOrderRequest>
...... 

```

## 它是如何工作的。。。

发送到某个地址的邮件将保存在收件箱中。消息接收器`(messageReceiver)`以连续的间隔监控收件箱，一旦检测到新的电子邮件，它就会读取电子邮件，提取消息，并将消息转发给消息发送器`(messageDispatcher)`。消息分派器将在其默认端点`(SamplePayloadEndpoint)`内调用 `invoke`方法，在处理程序方法 `(invoke)`内，将响应发送回客户端。

加载应用程序上下文时， `MailMessageReceiver`启动一个邮件接收器及其收件箱文件夹`(imap://server@packtpubtest.com/INBOX)`，即内存中的临时收件箱。加载应用程序上下文后， `messageReceiver`bean 根据可插拔策略`(monotoringStrategy)`充当传入消息的服务器监控器，该策略监控 `INBOX`文件夹`(imap://server@packtpubtest.com/INBOX)`上 1000 毫秒的新消息。 `storeUri`是要监控传入消息`(imap://server@packtpubtest.com/INBOX)`和 `transportUri`的位置是用于发送响应的邮件服务器：

```
<bean id="messageFactory" class="org.springframework.ws.soap.saaj.SaajSoapMessageFactory"/>
<bean id="messagingReceiver" class="org.springframework.ws.transport.mail.MailMessageReceiver">
<property name="messageFactory" ref="messageFactory"/>
<property name="from" value="server@packtpubtest.com"/>
<property name="storeUri" value="imap://server@packtpubtest.com/INBOX"/>
<property name="transportUri" value="smtp://smtp.packtpubtest.com"/>
<property name="messageReceiver" ref="messageDispatcher"/>
<property name="session" ref="session"/>
<property name="monitoringStrategy">
<bean class="org.springframework.ws.transport.mail.monitor.Pop3PollingMonitoringStrategy">
<property name="pollingInterval" value="1000"/>
</bean>
</property>
</bean>

```

`messageDiapatcher`中包含端点映射，设置端点 `(SimplePayloadEndpoint)`和端点映射类型`(PayloadRootQNameEndpointMapping)`：

```
<bean id="messageDispatcher" class="org.springframework.ws.soap.server.SoapMessageDispatcher">
<property name="endpointMappings">
<bean class="org.springframework.ws.server.endpoint.mapping.PayloadRootQNameEndpointMapping">
<property name="defaultEndpoint">
<bean class="com.packtpub.liverestaurant.service.endpoint.SimplePayloadEndpoint">
<property name="orderService">
<bean class="com.packtpub.liverestaurant.service.OrderServiceImpl"/>
</property>
</bean>
</property>
</bean>
</property>
</bean>

```

`SimplePayloadEndpoint`接收请求并使用 `OrderService`返回固定的虚拟响应。当服务器收到请求时，将调用 `invoke`方法，并返回响应，该响应将发送回客户端：

```
public class SimplePayloadEndpoint implements PayloadEndpoint {
OrderService orderService;
public void setOrderService(OrderService orderService) {
this.orderService = orderService;
}
public Source invoke(Source request) throws Exception {
//extract data from input parameter
String fName="John";
String lName="Smith";
String refNumber="1234";
return new StringSource(
"<tns:placeOrderResponse xmlns:tns=\"http://www.packtpub.com/liverestaurant/OrderService/schema\"><tns:refNumber>"+orderService.placeOrder(fName, lName, refNumber)+"</tns:refNumber></tns:placeOrderResponse>");
}

```

为了测试这个配方，使用了一个 `webServiceTemplate`。我们将在下一章讨论它。

`MailTransportWebServiceIntegrationTest`包含在项目中，用于加载应用程序上下文、设置邮件服务器和测试 Web 服务。

## 另见

*在电子邮件传输上创建 Web 服务客户端*配方，在[第 2 章](02.html "Chapter 2. Building Clients for SOAP Web-Services")*为 SOAP Web 服务构建客户端中讨论。*

# 在嵌入式 HTTP 传输上设置 Web 服务

外部 HTTP 服务器可能能够提供多种功能，但它们并不轻便，需要配置才能设置。

SpringWS 提供了使用嵌入式 Sun 的 JRE 1.6HTTP 服务器设置基于 HTTP 的 Web 服务的功能。嵌入式 HTTP 服务器是一种轻型独立服务器，可以用作外部服务器的替代品。虽然在传统的外部服务器`(web.xml)`中必须配置 web 服务器，但嵌入式 HTTP 服务器不需要任何部署描述符来操作，其唯一要求是通过应用程序上下文配置服务器实例。

在此配方中，介绍了在嵌入式 HTTP 服务器上设置 SpringWeb 服务。由于没有外部 HTTP 服务器，因此使用 Java 类加载应用程序上下文并启动服务器。

## 准备好了吗

在此配方中，项目名称为 `LiveRestaurant_R-1.6`，具有以下 Maven 依赖项：

*   `spring-ws-core-2.0.1.RELEASE.jar`
*   `log4j-1.2.9.jar`

## 怎么做。。。

1.  从资源文件夹复制服务合同`(OrderService.wsdl)`。
2.  创建服务及其实现，并用 `@Service("serviceName")``(OrderSevice,OrderServiceImpl)`注释其实现。
3.  在要自动扫描和检测的应用程序上下文`(applicationContext)`中配置服务。
4.  在应用程序上下文中配置嵌入式 HTTP 服务器。
5.  使用 main 方法添加一个 Java 类来加载应用程序上下文，以设置嵌入式 HTTP 服务器。
6.  使用以下命令运行服务器：

    ```
    mvn clean package exec:java 

    ```

7.  从 `LiveRestaurant_R-1.6-Client`运行以下命令：

```
mvn clean package exec:java 

```

*   以下是服务器成功运行时的输出：

```
<tns:placeOrderRequest xmlns:tns="...">
<tns:order>
<tns:refNumber>order-John_Smith_1234</tns:refNumber>
<tns:customer>
.......
</tns:customer>
<tns:dateSubmitted>2008-09-29T05:49:45</tns:dateSubmitted>
<tns:orderDate>2014-09-19T03:18:33</tns:orderDate>
<!--1 or more repetitions:-->
<tns:items>
<tns:type>Snacks</tns:type>
<tns:name>Pitza</tns:name>
<tns:quantity>2</tns:quantity>
</tns:items>
</tns:order>
</tns:placeOrderRequest> 

```

*   以下是客户端输出：

```
<tns:placeOrderResponse ...><refNumber>order-John_Smith_1234</refNumber></tns:placeOrderResponse>>
......
..... 

```

## 它是如何工作的。。。

在应用程序上下文中， `SimpleHttpFactoryBean`创建了一个简单的 HTTP 服务器（来自嵌入式 Sun 的 JRE 1.6），并在初始化时启动 HTTP 服务器，在销毁时停止。

具有上下文属性的 HTTP 服务器设置一个 Web 服务，服务类`(orderServiceImpl)`设置为端点，并指定上下文`(localhost:3478/OrderService)`中属性定义的 URL。此服务接口在上下文属性中注册。

但是，服务实现是使用 `component-scan. HttpInvokerProxyFactoryBean`为特定服务器 URL 创建客户端代理的自动检测。

```
<context:annotation-config />
<context:component-scan base-package="com.packtpub.liverestaurant.service.endpoint" />
<bean id="httpServer" class="org.springframework.remoting.support.SimpleHttpServerFactoryBean">
<property name="contexts">
<util:map>
<entry key="/OrderService">
<bean class="org.springframework.remoting.httpinvoker.SimpleHttpInvokerServiceExporter">
<property name="serviceInterface" value="com.packtpub.liverestaurant.service.endpoint.IOrderServiceEndPoint" />
<property name="service" ref="orderServiceImpl" />
</bean>
</entry>
</util:map>
</property>
<property name="port" value="3478" />
<property name="hostname" value="localhost" />
</bean>

```

`IOrderServiceEndPointImpl`和 `IOrderServiceEndPoint`是简单的服务接口和实现类。 `IOrderServiceEndPointImpl`由 `@Service``(orderServiceImpl)`注释，将被检测为服务实现。

```
package com.packtpub.liverestaurant.service.endpoint;
public interface OrderService {
String invoke(String request) throws Exception;
}
package com.packtpub.liverestaurant.service.endpoint;
import org.apache.log4j.Logger;
import org.springframework.stereotype.Service;
@Service("orderServiceImpl")
public class OrderServiceImpl implements OrderService {
static Logger logger = Logger.getLogger(OrderServiceImpl.class);
private static final String responseContent = "<tns:placeOrderResponse xmlns:tns=\"http://www.packtpub.com/liverestaurant/OrderService/schema\"><refNumber>Order Accepted!</refNumber></tns:placeOrderResponse>";
public String invoke(String request) throws Exception {
logger.info("invoke method request:"+request);
return responseContent;
}
}

```

`ServerStartUp.java`用于加载应用上下文并启动服务器：

```
package com.packtpub.liverestaurant.server;
public class ServerStartUp {
public static void main(String[] args) throws IOException {
ClassPathXmlApplicationContext appContext = new ClassPathXmlApplicationContext("/applicationContext.xml");
System.out.println(appContext);
char c;
// Create a BufferedReader using System.in
BufferedReader br = new BufferedReader(new
InputStreamReader(System.in));
System.out.println("Enter any character to quit.");
c = (char) br.read();
appContext.close();
}

```

# 在 XMPP 运输上设置弹簧 WS

HTTP 最常用作 Web 服务传输协议。但是，它不能满足异步通信的要求。

XMPP 传输上的 Web 服务能够进行异步通信，其中客户端不需要等待来自服务的响应；相反，当流程完成时，服务将响应发送给客户端。SpringWS2.0 包括 XMPP（Jabber）支持，其中 Web 服务可以通过 XMPP 协议进行通信。在此配方中，介绍了在 XMPP 传输上设置 Spring WS。由于没有外部 HTTP 服务器，因此使用测试类加载应用程序上下文。

## 准备好了吗

在此配方中，项目名称为 `LiveRestaurant_R-1.7`，具有以下 Maven 依赖项：

*   `spring-ws-core-2.0.1.RELEASE.jar`
*   `spring-ws-support-2.0.1.RELEASE.jar`
*   `spring-test-3.0.5.RELEASE.jar`
*   `junit-4.7.jar`
*   `xmlunit-1.1.jar`
*   `smack-3.1.0.jar`

## 怎么做。。。

1.  创建端点`(SamplePlayLoadEndPoint).`
2.  在应用程序上下文`(applicationContext.xml)`中配置到 XMPP 服务器的连接。
3.  在应用程序上下文中配置消息接收器。
4.  运行以下命令：

```
mvn clean package 

```

*   收到的答复如下：

```
<placeOrderRequest ><id>9999</id></placeOrderRequest>
...
for request
...<placeOrderRequest ><id>9999</id></placeOrderRequet>... 

```

## 它是如何工作的。。。

在应用程序上下文中， `messageFactory`bean 负责创建传入和传出 SOAP 消息。 `messageReceiver`bean 充当服务器，使用连接（到 `XMPP server:google talk)`，并使用用户名和密码监听特定服务上的主机。

```
<bean id="messageFactory" class="org.springframework.ws.soap.saaj.SaajSoapMessageFactory"/>
<bean id="connection" class="org.springframework.ws.transport.xmpp.support.XmppConnectionFactoryBean">
<property name="host" value="talk.google.com"/>
<property name="username" value="yourUserName@gmail.com"/>
<property name="password" value="yourPassword"/>
<property name="serviceName" value="gmail.com"/>
</bean>
<bean id="messagingReceiver" class="org.springframework.ws.transport.xmpp.XmppMessageReceiver">
<property name="messageFactory" ref="messageFactory"/>
<property name="connection" ref="connection"/>
<property name="messageReceiver" ref="messageDispatcher"/>
</bean>

```

一旦客户端发送消息，它将被转发到由消息调度器在 `messageDispatcher)`内配置的端点`(SamplePlayLoadEndPoint`，并将响应返回给客户端：

```
<bean id="messageDispatcher"
class="org.springframework.ws.soap.server.SoapMessageDispatcher">
<property name="endpointMappings">
<bean class="org.springframework.ws.server.endpoint.mapping.PayloadRootQNameEndpointMapping">
<property name="defaultEndpoint"> <bean class="com.packtpub.liverestaurant.service.endpoint.SamplePlayLoadEndPoint"/>
</property> </bean>
</property>
</bean>

```

此处使用`Webservicetemplate`作为客户；这将在下一章讨论。

`SamplePlayLoadEndPoint`刚刚收到请求并返回响应：

```
public class SamplePlayLoadEndPoint implements PayloadEndpoint {
static Logger logger = Logger.getLogger(SamplePlayLoadEndPoint.class);
public Source invoke(Source request) throws Exception {
return request;
}

```

项目中包含一个测试类，用于加载应用程序上下文、设置 XMPPWeb 服务服务器和测试 Web 服务。

## 另见

*在 XMPP 传输*上创建 Web 服务客户端的方法在[第 2 章](02.html "Chapter 2. Building Clients for SOAP Web-Services")*SOAPWeb 服务客户端中讨论。*

# 建立合同优先 Web 服务

从 Java 代码生成 WSDL 和 XSD 契约并设置 Web 服务称为**契约最后一次开发**。这种方法的主要缺点是，如果 Java 类中有任何更改，Web 服务的契约（WSDL 或 XSD）最终可能会更改。通过这种方式，客户端必须更新客户端类，这总是不好的。引入合同优先的方法作为解决合同最后一个瓶颈的替代方法。在契约优先方法中，契约（WSDL 或模式）是建立 Web 服务的主要构件。

“合同优先”方法比“合同后”方法的一些优点如下：

*   性能：在 contract last 中，客户端和服务器之间可能会交换一些额外的数据，即 Java 代码的序列化，这会降低性能，而 contract last 则会精确地交换所需的数据并最大限度地提高性能。
*   一致性：不同的供应商可能会在契约最后一种方法中生成不同的 WSDL，而契约第一种方法通过站在同一个契约上消除了这个问题。
*   版本控制：更改 contract last Web Service 的版本意味着更改客户端和服务器端的 Java 类，如果有许多客户端调用 Web Service，那么最终可能会很昂贵，而在 contract first 中，因为 contract 与实现是解耦的，版本控制可以简单地通过在同一端点类中添加新方法实现或使用样式表将旧消息格式转换为新消息格式来完成。
*   维护/增强成本：仅更改合同比在客户端和服务器端更改 Java 代码要便宜得多。在本食谱中，我们将讨论如何使用 SpringWS 建立契约优先 Web 服务。

## 准备好了吗

在此配方中，项目名称为 `LiveRestaurant_R-1.8`，具有以下 Maven 依赖项：

*   `spring-ws-core-2.0.1.RELEASE.jar`
*   `jdom-1.0.jar`

## 怎么做。。。

1.  从资源文件夹复制数据合同`(orderService.xsd)`。
2.  创建端点`(OrderEndpoint)`。
3.  使用 server Spring 配置文件`(spring-ws-servlet.xml)`中的组件扫描配置端点的自动检测。
4.  配置从数据契约`(orderService.xsd)`动态生成 WSDL。
5.  使用以下命令运行服务器：

    ```
    mvn clean package tomcat:run 

    ```

6.  浏览到以下链接以查看 WSDL:

    ```
    http://localhost:8080/LiveRestaurant/OrderService.wsdl

    ```

7.  从 `LiveRestaurant_R-1.8-Client:`运行客户端

```
mvn clean package 

```

*   以下是服务器成功运行时的输出：

```
Sent response....
<tns:placeOrderResponse xmlns:tns="...."><tns:refNumber>tns:refNumber>order-John_S
mith_9999</tns:refNumber></tns:refNumber></
tns:placeOrderResponse>...
for request ...
<tns:placeOrderRequest xmlns:tns="....">
<tns:order>
<tns:refNumber>9999</tns:refNumber>
<tns:customer>
....
</tns:customer>
<tns:dateSubmitted>2008-09-29T05:49:45</tns:dateSubmitted>
<tns:orderDate>2014-09-19T03:18:33</tns:orderDate>
<!--1 or more repetitions:-->
<tns:items>
<tns:type>Snacks</tns:type>
<tns:name>Pitza</tns:name>
<tns:quantity>2</tns:quantity>
</tns:items>
</tns:order>
</tns:placeOrderRequest> 

```

## 它是如何工作的。。。

此配方的步骤与配方*相同，简化了使用 MessageDispatcherServlet*创建 Web 服务的过程，只是实现了端点处理方法。

此注释作为 `@Component`的专门化，允许通过在服务器应用程序上下文文件`(spring-ws-servlet.xml)`中配置的类路径扫描自动检测实现类：

```
<context:component-scan base-package="com.packtpub.liverestaurant.service"/>
<sws:annotation-driven/>

```

`OrderEndpoint`为本配方的 `endPoint`，且 `@Endpoint`注释也与 `@service`相同，允许通过类路径扫描自动检测实现类。具有根元素 `placeOrderRequest` `(localPart = "placeOrderRequest")`和命名空间 `http://www.packtpub.com/liverestaurant/OrderService/schema`的请求将被转发以调用相应的方法`(handlePlaceOrderRequest)`。

```
@Endpoint
public class OrderEndpoint {
private static final Log logger = LogFactory.getLog(OrderEndpoint.class);
private static final String NAMESPACE_URI = "http://www.packtpub.com/liverestaurant/OrderService/schema";
private OrderService orderService;
@Autowired
public OrderEndpoint(OrderService orderService) {
this.orderService = orderService;
}
@PayloadRoot(namespace = NAMESPACE_URI, localPart = "placeOrderRequest")
@ResponsePayload
public Source handlePancelOrderRequest(@RequestPayload Element placeOrderRequest) throws Exception {
String refNumber=placeOrderRequest.getElementsByTagNameNS(NAMESPACE_URI, "refNumber") .item(0).getTextContent();
String fName=placeOrderRequest.getElementsByTagNameNS(NAMESPACE_URI, "fName") .item(0).getTextContent();
String lName=placeOrderRequest.getElementsByTagNameNS(NAMESPACE_URI, "lName") .item(0).getTextContent();
return new StringSource(
"<tns:placeOrderResponse xmlns:tns=\"http://www.packtpub.com/liverestaurant/OrderService/schema\"><tns:refNumber>"+orderService.placeOrder(fName,lName, refNumber)+"</tns:refNumber></tns:placeOrderResponse>");
}
}

```

关于注释以及如何将请求映射到端点方法的其他详细信息包含在本章中。

`spring-ws-servlet.xml`文件中的以下设置会导致应用程序根据数据契约`(orderService.xsd)`自动生成 WSDL 文件。

```
<sws:dynamic-wsdl id="OrderService" portTypeName="OrderService" locationUri="http://localhost:8080/LiveRestaurant/spring-ws/OrderService"
targetNamespace="http://www.packtpub.com/liverestaurant/OrderService/schema">
<sws:xsd location="/WEB-INF/orderService.xsd"/>
</sws:dynamic-wsdl>

```

### 注

尽管可以从数据契约（XSD）自动生成 WSDL，但 Spring WS 建议避免自动生成 WSDL，原因如下：

*   保持版本之间的一致性（不同版本的自动生成的 WSDL 之间可能会有细微差异）
*   WSDL 的自动生成很慢，尽管一旦生成，WSDL 将被缓存并在以后使用。

因此，SpringWS 建议在开发时，通过浏览器自动生成一次 WSDL 并保存它，然后使用静态 WSDL 公开服务契约。

## 另见

本章讨论的方法*通过注释有效负载根来设置端点，简化了使用 MessageDispatcherServlet*创建 Web 服务的过程，以及[第 2 章](02.html "Chapter 2. Building Clients for SOAP Web-Services")、*讨论的方法*在 HTTP 传输上创建 Web 服务客户端*方法为 SOAP Web 服务构建客户端。*

另请参见[第 10 章](10.html "Chapter 10. Spring Remoting")、*Spring 远程处理*中讨论的方法，了解如何设置 contract last Web 服务。

# 为 Web 服务设置简单的端点映射

这个方法演示了一个非常简单的端点映射，它将 Web 服务请求映射到 Java 类方法。

## 准备好了吗

在此配方中，项目名称为 `LiveRestaurant_R-1.9`，具有以下 Maven 依赖项：

*   `spring-ws-core-2.0.1.RELEASE.jar`
*   `log4j-12.9.jar`

## 怎么做。。。

此配方的步骤与上一配方相同，*设置契约优先 Web 服务*，只是端点的注册，即方法端点映射，在 `spring-ws-servlet.xml`中配置。

1.  根据方法映射标准`(SimpleMethodEndpointMapping)`定义一个端点`(OrderSeviceMethodEndpoint)`。
2.  在 `spring-ws-servlet.xml`中配置方法端点映射。
3.  运行 `mvn clean package tomcat:run`命令并浏览以查看 WSDL:

    ```
    http://localhost:8080/LiveRestaurant/OrderService.wsdl

    ```

4.  要进行测试，请打开一个新的命令窗口，转到 `Liverestaurant_R-1.9-Client`，然后运行以下命令：

```
mvn clean package exec:java 

```

*   以下是服务器端输出：

```
Sent response ..
<tns:placeOrderResponse xmlns:tns="..."><tns:refNumber>order-John_Smith_1234</tns:refNumber>
</tns:placeOrderResponse>...
for request ...
<tns:placeOrderRequest xmlns:tns="...">
<tns:order>
<tns:refNumber>order-9999</tns:refNumber>
<tns:customer>
........
</tns:customer>
<tns:dateSubmitted>2008-09-29T05:49:45</tns:dateSubmitted>
<tns:orderDate>2014-09-19T03:18:33</tns:orderDate>
<!--1 or more repetitions:-->
<tns:items>
<tns:type>Snacks</tns:type>
<tns:name>Pitza</tns:name>
<tns:quantity>2</tns:quantity>
</tns:items>
</tns:order>
</tns:placeOrderRequest> 

```

## 它是如何工作的。。。

`SimpleMethodEndpointMapping`从请求有效负载`(placeOrderRequest)`的本地名称映射到 POJO 类的方法。以下是请求有效负载的示例（请注意请求有效负载的本地名称）：

```
<tns:placeOrderRequest ...>
<tns:order>
......
</tns:order>
</tns:placeOrderRequest>

```

端点 bean 是使用 `endpoints`属性注册的。此属性告诉您在 `endpoint`类`(OrderServiceEndpoint)`中应该有一个名称以 `methodPrefix(handle)`开头并以请求负载本地名称`(placeOrderRequest)`结尾的方法。这通过使用 `spring-ws-servlet.xml:`中的配置增加了端点命名的灵活性

```
<bean class="org.springframework.ws.server.endpoint.mapping.SimpleMethodEndpointMapping">
<property name="endpoints">
<ref bean="OrderServiceEndpoint"/>
</property>
<property name="methodPrefix" value="handle"></property>
<property name="interceptors">
<list>
<bean
class="org.springframework.ws.server.endpoint.interceptor.PayloadLoggingInterceptor">
<property name="logRequest" value="true" />
<property name="logResponse" value="true" />
</bean>
</list>
</property>
</bean>
<bean id="OrderServiceEndpoint" class="com.packtpub.liverestaurant.service.endpoint.OrderSeviceMethodEndpoint">
</bean>

```

端点方法名称应与 `handle+request`消息根名称`(handleplaceOrderRequest)`匹配。在方法主体中，我们应该处理请求并最终以 `javax.xml.transform.Source:`的形式返回响应

```
public class OrderSeviceMethodEndpoint {
private OrderService orderService;
@Autowired
public void setOrderService(OrderService orderService) {
this.orderService = orderService;
}
public @ResponsePayload Source handleplaceOrderRequest(@RequestPayload Source source) throws Exception {
//extract data from input parameter
String fName="John";
String lName="Smith";
String refNumber="1234";
return new StringSource(
"<tns:placeOrderResponse xmlns:tns=\"http://www.packtpub.com/liverestaurant/OrderService/schema\"><tns:refNumber>"+orderService.placeOrder(fName, lName, refNumber)+"</tns:refNumber></tns:placeOrderResponse>");
}
}

```

## 另见

本章讨论的方法*设置传输中立的 WS-Addressing 端点*和*通过注释有效负载根*来设置端点。

# 通过注释有效负载根来设置端点

SpringWS 通过其注释特性进一步简化了复杂 Web 服务的创建，并减少了 XML 中的代码和配置。

## 准备好了吗

在此配方中，项目名称为 `LiveRestaurant_R-1.10`，具有以下 Maven 依赖项：

*   `spring-ws-core-2.0.1.RELEASE.jar`
*   `log4j-12.9.jar`

## 怎么做。。。

此配方的步骤与*建立契约优先 Web 服务*的步骤相同，这里我们想在 `endpoint`类中描述使用注释的端点映射。

1.  运行以下命令：

    ```
    mvn clean package tomcat:run 

    ```

2.  浏览到以下链接以查看 WSDL:

    ```
    http://localhost:8080/LiveRestaurant/OrderService.wsdl

    ```

3.  要进行测试，请打开一个新的命令窗口，转到 `LiveRestaurant-1.10-Client`，然后运行以下命令：

```
mvn clean package exec:java 

```

*   以下是服务器端输出：

```
Sent response ..
<tns:placeOrderResponse xmlns:tns="..."><tns:refNumber>order-John_Smith_1234</tns:refNumber>
</tns:placeOrderResponse>...
for request ...
<tns:placeOrderRequest xmlns:tns="...">
<tns:order>
<tns:refNumber>order-9999</tns:refNumber>
<tns:customer>
........
</tns:customer>
<tns:dateSubmitted>2008-09-29T05:49:45</tns:dateSubmitted>
<tns:orderDate>2014-09-19T03:18:33</tns:orderDate>
<!--1 or more repetitions:-->
<tns:items>
<tns:type>Snacks</tns:type>
<tns:name>Pitza</tns:name>
<tns:quantity>2</tns:quantity>
</tns:items>
</tns:order>
</tns:placeOrderRequest> 

```

## 它是如何工作的。。。

通过在 Spring WS 配置文件`(spring-ws-servlet.xml)`中包含组件扫描和注释驱动的设置，Spring 容器将扫描整个包中的端点、服务和依赖项，以便相互注入和自动连接以构建 Web 服务块。您无法在此处看到适配器和其他处理程序，因为容器会动态地智能地选择正确/默认适配器（messageDispatcher 从 endponit 的现有适配器列表中运行适配器的支持方法，如果支持方法返回 `true`，则该适配器就是正确的适配器）：

```
<context:component-scan base-package="com.packtpub.liverestaurant.service"/>
<sws:annotation-driven/>
<sws:dynamic-wsdl id="OrderService" portTypeName="OrderService" locationUri="http://localhost:8080/LiveRestaurant/spring-ws/OrderService"
targetNamespace="http://www.packtpub.com/liverestaurant/OrderService/schema">
<sws:xsd location="/WEB-INF/orderService.xsd"/>
</sws:dynamic-wsdl>

```

`OrderSeviceAnnotationEndpoint`的 `@Endpoint`注释使其成为端点，带有 `PayloadRootAnnotationMethodEndpointMapping`，具有指向方法端点映射的精确指针和方法级注释：

```
@Endpoint
public class OrderSeviceAnnotationEndpoint {
private final String SERVICE_NS = "http://www.packtpub.com/liverestaurant/OrderService/schema";
private OrderService orderService;
@Autowired
public OrderSeviceAnnotationEndpoint(OrderService orderService) {
this.orderService = orderService;
}
@PayloadRoot(localPart = "placeOrderRequest", namespace = SERVICE_NS)
public @ResponsePayload
Source handlePlaceOrderRequest(@RequestPayload Source source) throws Exception {
//extract data from input parameter
String fName="John";
String lName="Smith";
String refNumber="1234";
return new StringSource(
"<tns:placeOrderResponse xmlns:tns=\"http://www.packtpub.com/liverestaurant/OrderService/schema\"><tns:refNumber>"+orderService.placeOrder(fName, lName, refNumber)+"</tns:refNumber></tns:placeOrderResponse>");
}
@PayloadRoot(localPart = "cancelOrderRequest", namespace = SERVICE_NS)
public @ResponsePayload
Source handleCancelOrderRequest(@RequestPayload Source source) throws Exception {
//extract data from input parameter
boolean cancelled =true ;
return new StringSource(
"<tns:cancelOrderResponse xmlns:tns=\"http://www.packtpub.com/liverestaurant/OrderService/schema\"><cancelled>"+(cancelled?"true":"false")+"</cancelled></tns:cancelOrderResponse>");
}

```

`@PayloadRoot`通过参数注释 `@RequestPayload`帮助 `MessageDispatcher`将请求映射到方法，该注释将整个 SOAP 消息的确切消息有效负载部分指定为方法中的参数（它通过请求的根元素查找方法，该元素等于 `localPart`，例如 `placeOrderRequest`或 `placeCancelRequest). @RequestPayload`告诉容器参数 `RequestPayload`将从 SOAP 消息中提取，并在运行时作为参数注入方法。

返回类型注释 `@ResponsePayload`指示 `MessageDispatcher`的实例 `javax.xml.transform.Source`为 `ResponsePayload`。smart Spring WS-framework 在运行时检测这些对象的类型，并将其委托给相应的 `PayloadMethodProcessor`。在这种情况下，它是 `SourcePayloadMethodProcessor`，因为输入参数和返回值的类型是 `javax.xml.transform.Source`。

## 另见

本章讨论的方法*为 Web 服务*设置与传输无关的 WS-Addressing 端点和*为 Web 服务*设置简单的端点映射。

# 设置与传输无关的 WS-Addressing 端点

使用 XML 消息中的 HTTP 传输信息将消息路由到端点，将数据和操作混合在一起，这些消息将被请求的客户端回复。

WS-Addressing 通过分离路由数据并将其包含在 SOAP 头中来标准化路由机制。WS-Addressing 可以使用自己的元数据，而不是使用 HTTP 传输数据进行端点路由。此外，来自客户端的请求可能会返回到 WS-Addressing 中的不同客户端。例如，考虑到来自客户端的以下请求，客户端可以将 `ReplyTo`设置为自己的地址， `FaultTo`设置为管理端点地址。然后，服务器向客户端发送成功消息，向管理员地址 `[<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/">`发送故障消息。

```
<SOAP-ENV:Header xmlns:wsa="http://www.w3.org/2005/08/addressing">
<wsa:To>server_uri</wsa:To>
<wsa:Action>action_uri</wsa:Action>
<wsa:From>client_address </wsa:From>
<wsa:ReplyTo>client_address</wsa:ReplyTo>
<wsa:FaultTo>admen_uri </wsa:FaultTo>
<wsa:MessageID>..</wsa:MessageID>
</SOAP-ENV:Header>
<SOAP-ENV:Body>
<tns:placeOrderRequest>....</tns:placeOrderReques>
</SOAP-ENV:Body></SOAP-ENV:Envelope>] 

```

在此配方中，我们将使用 WS-Addressing 设置 Spring WS。

## 准备好了吗

在此配方中，项目名称为 `LiveRestaurant_R-1.11`，具有以下 Maven 依赖项：

*   `spring-ws-core-2.0.1.RELEASE.jar`
*   `log4j-12.9.jar`

## 怎么做。。。

此配方的步骤与*通过注释有效负载根*来设置端点的步骤相同，但端点类除外。因此，按照上述方法的步骤，使用 WS-Addressing 标准定义一个新端点。

1.  运行以下命令：

    ```
    mvn clean package tomcat:run 

    ```

2.  要进行测试，打开一个新的命令窗口到 `Liverestaurant_R-1.11-Client`并运行以下命令：

```
mvn clean package exec:java

```

*   以下是服务器端输出：

```
Sent response [<SOAP-ENV:Envelope ...><SOAP-ENV:Header...>
<wsa:To ...>http://www.w3.org/2005/08/addressing/anonymous</wsa:To>
<wsa:Action>http://www.packtpub.com/OrderService/OrdReqResponse</wsa:Action>
<wsa:MessageID>...</wsa:MessageID>
<wsa:RelatesTo>urn:uuid:2beaead4-c04f-487c-86fc-caab64ad8461</wsa:RelatesTo>
</SOAP-ENV:Header>
<SOAP-ENV:Body>
<tns:placeOrderResponse ...><tns:refNumber>order-John_Smith_1234</tns:refNumber></tns:placeOrderResponse>
</SOAP-ENV:Body></SOAP-ENV:Envelope>...
for request <SOAP-ENV:Envelope ..><SOAP-ENV:Header ...>
<wsa:To SOAP-..>http://www.packtpub.com/liverestaurant/OrderService/schema</wsa:To>
<wsa:Action>http://www.packtpub.com/OrderService/OrdReq</wsa:Action>
<wsa:MessageID>...</wsa:MessageID>
</SOAP-ENV:Header><SOAP-ENV:Body>
<tns:placeOrderRequest ...>
<tns:order>
<tns:refNumber>9999</tns:refNumber>
<tns:customer>
...
</tns:customer>
<tns:dateSubmitted>2008-09-29T05:49:45</tns:dateSubmitted>
<tns:orderDate>2014-09-19T03:18:33</tns:orderDate>
<!--1 or more repetitions:-->
<tns:items>
<tns:type>Snacks</tns:type>
<tns:name>Pitza</tns:name>
<tns:quantity>2</tns:quantity>
</tns:items>
</tns:order>
</tns:placeOrderRequest>
</SOAP-ENV:Body></SOAP-ENV:Envelope> 

```

## 它是如何工作的。。。

与前面的方法相同，*通过注释有效负载根*来设置端点，传入的 WS-Addressing SOAP 消息将转发到端点`(OrderEndpoint`，该端点由 `@Endpoint)`自动检测。从输出中可以看到，WS-Addressing 用于端点方法的映射和调度目的的 SOAP 信封中添加了一个头。

```
<SOAP-ENV:Header ...>
<wsa:To SOAP-..>http://www.packtpub.com/liverestaurant/OrderService/schema</wsa:To>
<wsa:Action>http://www.packtpub.com/OrderService/OrdReq</wsa:Action>
<wsa:MessageID>...</wsa:MessageID>
</SOAP-ENV:Header> 

```

在此配方中，服务器应用 `AnnotationActionEndpointMapping`，使用 `@Action`(http://www.packtpub.com/OrderService/OrdReq). `@Action`与 `@PayloadRoot`相似，识别终点`(OrderEndpoint)`中的`(handleOrderRequest)`处理方式。

```
@Endpoint
public class OrderEndpoint {
private OrderService orderService;
@Autowired
public void setOrderService(OrderService orderService) {
this.orderService = orderService;
}
@Action("http://www.packtpub.com/OrderService/OrdReq")
public @ResponsePayload
Source handleOrderRequest(@RequestPayload Source source) throws Exception {
//extract data from input parameter
String fName="John";
String lName="Smith";
String refNumber="1234";
return new StringSource(
"<tns:placeOrderResponse xmlns:tns=\"http://www.packtpub.com/liverestaurant/OrderService/schema\"><tns:refNumber>"+orderService.placeOrder(fName, lName, refNumber)+"</tns:refNumber></tns:placeOrderResponse>");
}
}

```

## 另见

[第 2 章](02.html "Chapter 2. Building Clients for SOAP Web-Services")中讨论的*为 WS-Addressing 端点*创建 Web 服务客户端的方法；*为 SOAP Web 服务构建客户端的方法*，以及本章讨论的*通过注释有效负载根目录*来设置端点的方法。

# 使用 XPath 表达式设置端点

SpringWS 允许我们使用带有 XPath 表达式的注释来提取 `endpoint`方法签名中传递的参数。例如，在 `endpoint`方法的 `handleOrderRequest`（@RequestPayload `Source source)`中），如果您想在源对象中查找任何元素的值，必须使用 Java API 来提取该值。您可以通过在方法的签名中使用 XPath 从传入的 XML 数据中提取数据来消除在 handler 方法中使用 Java API，如下所示： `handleOrderRequest(@XPathParam("/OrderRequest/message") String message)`。

此配方通过注释说明了 XPath 表达式在端点映射中的用法。

## 准备好了吗

在此配方中，项目名称为 `LiveRestaurant_R-1.12`，具有以下 Maven 依赖项：

*   `spring-ws-core-2.0.1.RELEASE.jar`
*   `log4j-12.9.jar`

## 怎么做。。。

此配方的步骤与*通过注释有效负载根*来设置端点的步骤相同，但端点处理方法的实现除外。因此，按照上述方法的步骤，使用 XPath 表达式从传入消息中提取数据并创建响应。

1.  从 `LiveRestaurant_R-1.12:`

    ```
    mvn clean package tomcat:run 

    ```

    运行以下命令
2.  浏览以下链接以查看 Web 服务合同：

    ```
    http://localhost:8080/LiveRestaurant/OrderService.wsdl

    ```

3.  要进行测试，请打开一个新的命令窗口，转到 `LiveRestaurant_R-1.12-Client`，然后运行以下命令：

```
mvn clean package exec:java s

```

*   以下是服务器端输出：

```
Sent response ..
<tns:placeOrderResponse xmlns:tns="">
<tns:refNumber>order-John_Smith_9999</tns:refNumber>
</tns:placeOrderResponse>
...
for request ...
<tns:placeOrderRequest xmlns:tns="...">
<order>
<refNumber>9999</refNumber>
<customer>
......
</customer>
<dateSubmitted>2008-09-29T05:49:45</dateSubmitted>
<orderDate>2014-09-19T03:18:33</orderDate>
<items>
<type>Snacks</type>
<name>Pitza</name>
<quantity>2</quantity>
</items>
</order>
</tns:placeOrderRequest>
...
Sent response...
<tns:cancelOrderResponse xmlns:tns="...">
<tns:cancelled>true</tns:cancelled>
</tns:cancelOrderResponse>
...
for request ...
<tns:cancelOrderRequest xmlns:tns="...">
<refNumber>9999</refNumber>
</tns:cancelOrderRequest> 

```

## 它是如何工作的。。。

传递方法参数与通过注释有效负载根目录来设置端点的配方*相同，只是它使用了 `@XPathParam`，它指定消息中的数据路径，该路径将作为参数传递到方法中。此处 `XpathParamMethodArgumentResolver`负责从消息中提取值并将其传递给方法。*

注释 `XpathParam`帮助 `MethodArgumentResolvers (XpathParamMethodArgumentResolver)` 从 XML 中提取信息，并将节点值绑定到方法参数（使用 `// cause`递归搜索整个消息，例如 `//lName`搜索整个 `placeRequestRequest`消息）。方法 `cancelOrderRequest:`使用相同的实现

```
@Endpoint
public class OrderEndpoint {
private final String SERVICE_NS = "http://www.packtpub.com/liverestaurant/OrderService/schema";
private OrderService orderService;
@Autowired
public OrderEndpoint(OrderService orderService) {
this.orderService = orderService;
}
@PayloadRoot(localPart = "placeOrderRequest", namespace = SERVICE_NS)
public @ResponsePayload
Source handleOrderRequest(@XPathParam("//fName") String fName,@XPathParam("//lName") String lName,@XPathParam("//refNumber") String refNumber) throws Exception {
return new StringSource(
"<tns:placeOrderResponse xmlns:tns=\"http://www.packtpub.com/liverestaurant/OrderService/schema\"><tns:refNumber>" + orderService.placeOrder(fName, lName, refNumber)+"</tns:refNumber></tns:placeOrderResponse>");
}
@PayloadRoot(localPart = "cancelOrderRequest", namespace = SERVICE_NS)
public @ResponsePayload
Source handleCancelOrderRequest(@XPathParam("//refNumber") String refNumber) throws Exception {
boolean cancelled = orderService.cancelOrder(refNumber);
return new StringSource(
"<tns:cancelOrderResponse xmlns:tns=\"http://www.packtpub.com/liverestaurant/OrderService/schema\"><cancelled>"+(cancelled?"true":"false")+"</cancelled></tns:cancelOrderResponse>");
}

```

方法参数可以是以下任一参数：

*   `boolean`或 `Boolean`
*   `double`或 `Double`
*   `String`
*   `Node`
*   `NodeList`

## 另见

配方*通过注释有效负载根*来设置端点，本章将对此进行讨论。

# 使用 DOM 处理传入的 XML 消息

端点的实现要求我们获取传入的 XML 消息并提取其数据。在 Java 中，有各种方法 `(W3C DOM, SAX, XPath, JAXB, Castor, XMLBeans, JiBX`或 `XStream)`用于从输入 XML 消息中提取数据，但大多数方法都不是语言无关的。

DOM 被创建为语言中立的，最初用于 HTML 页面的 JavaScript 操作。在 Java 中，提供了 W3CDOM 库来与 XML 数据交互。W3CDOM 库中的类，如 `org.w3c.dom.Document, org.w3c.dom.Element, org.w3c.dom.Node`和 `org.w3c.dom.Text`，用于从输入 XML 消息中提取数据。

在此配方中，W3CDOM 用于从传入消息中提取数据。

## 准备好了吗

在此配方中，项目名称为 `LiveRestaurant_R-1.13`，具有以下 Maven 依赖项：

*   `spring-ws-core-2.0.1.RELEASE.jar`
*   `log4j-1.2.9.jar`

## 怎么做。。。

此配方的步骤与配方*通过注释有效负载根*来设置端点的步骤相同，但端点处理方法的实现除外。因此，按照上述方法的步骤，使用 DOM 从传入消息中提取数据并创建响应。

1.  运行命令 `mvn clean package tomcat:run`并浏览到以下链接：

    ```
    http://localhost:8080/LiveRestaurant/OrderService.wsdl

    ```

2.  要进行测试，请打开新的命令窗口并运行以下命令：

```
mvn clean package exec:java 

```

*   以下是服务器端输出：

```
Sent response ....
<placeOrderResponse >
<refNumber>order-John_Smith_1234</refNumber></placeOrderResponse>
...
for request ...
<tns:placeOrderRequest xmlns:tns="...">
<tns:order>
<tns:refNumber>9999</tns:refNumber>
<tns:customer>
.... </tns:customer>
<tns:dateSubmitted>2008-09-29T05:49:45</tns:dateSubmitted>
<tns:orderDate>2014-09-19T03:18:33</tns:orderDate>
<!--1 or more repetitions:-->
<tns:items>
<tns:type>Snacks</tns:type>
<tns:name>Pitza</tns:name>
<tns:quantity>2</tns:quantity>
</tns:items>
</tns:order>
</tns:placeOrderRequest>
,

```

## 它是如何工作的。。。

传递方法参数与*通过注释有效负载根*来设置端点的方法相同，只是我们使用 `@RequestPayload`，它指定消息中数据的 DOM 元素作为参数传递到方法中。这里， `DomPayloadMethodProcessor`负责从消息中提取值并将其传递给方法。由于 `@ResponsePayload`指定的返回类型也是 DOM 元素类型， `DomPayloadMethodProcessor`被用作返回处理程序。

`@PayloadRoot`注释通知 SpringWS `handleCancelOrderRequest`方法是 XML 消息的处理方法。此方法可以处理的消息类型由注释值指示（元素 `@RequestPayload`告诉它是 DOM 元素类型）。在本例中，它可以处理具有 `placeOrderRequest`本地部分和 `http://www.packtpub.com/liverestaurant/OrderService/schema`命名空间的 XML 元素。

```
@PayloadRoot(namespace = NAMESPACE_URI, localPart = "placeOrderRequest")
@ResponsePayload
public Element handlePlaceOrderRequest(@RequestPayload Element placeOrderRequest) throws Exception {
String refNumber=placeOrderRequest.getElementsByTagNameNS(NAMESPACE_URI, "refNumber") .item(0).getTextContent();
String fName=placeOrderRequest.getElementsByTagNameNS(NAMESPACE_URI, "fName") .item(0).getTextContent();
String lName=placeOrderRequest.getElementsByTagNameNS(NAMESPACE_URI, "lName") .item(0).getTextContent();

```

前面的代码通过 `getElementsByTagNameNS`方法从传入的 XML 消息`(placeOrderRequest)`中提取元素 `refNumber, fName`和 `lName`。然后，它查找并返回 `refNumber, fName`中第一项的文本内容和 `lName`元素（通过 `item(0).getTextContent())`）

代码的以下部分通过创建 `placeOrderResponse`元素（使用 `document.createElementNS)`创建一条传出 XML 消息。然后，它创建子元素 `refNumber`（使用 `document.createElementNS)`并创建该元素的文本（使用 `createTextNode and appendChild)`。然后，它将 `refNumber`元素附加到响应元素 `placeOrderResponse`（使用 `appendChild`方法）：

```
Document document = documentBuilder.newDocument();
Element responseElement = document.createElementNS(NAMESPACE_URI,
"placeOrderResponse");
Element canElem=document.createElementNS(NAMESPACE_URI,"refNumber");
Text responseText = document.createTextNode(orderService.placeOrder(fName, lName, refNumber));
canElem.appendChild(responseText);
responseElement.appendChild(canElem);
return responseElement;

```

## 另见

本章讨论的方法*通过注释有效负载根*来设置端点，以及[第 2 章](02.html "Chapter 2. Building Clients for SOAP Web-Services")讨论的方法*在 HTTP 传输*上创建 Web 服务客户端*为 SOAP Web 服务构建客户端。*

# 使用 JDOM 处理传入的 XML 消息

端点的实现要求我们获取传入的 XML 消息并提取其数据。DOM 可以从 XML 文档中获取数据，但它速度慢、占用内存，并且具有非常基本的特性。

JDOM 文档未内置到内存中；它是按需构建的（惰性初始化设计模式）。此外，JDOM 提供了一个标准的基于 Java 的集合接口，使得在文档树中导航或操作元素变得更加容易。在此配方中，JDOM 用于从传入消息中提取数据。

## 准备好了吗

在此配方中，项目名称为 `LiveRestaurant_R-1.14`，具有以下 Maven 依赖项：

*   `spring-ws-core-2.0.1.RELEASE.jar`
*   `jdom-1.0.jar`
*   `log4j-1.2.9.jar`
*   `jaxen-1.1.jar`
*   `xalan-2.7.0.jar`

## 怎么做。。。

此配方的步骤与*通过注释有效负载根*配方来设置端点的步骤相同，但端点处理方法的实现除外。因此，按照上述方法的步骤，使用 JDOM 从传入消息中提取数据，并创建响应。

1.  运行以下命令：

    ```
    mvn clean package tomcat:run 

    ```

2.  浏览至以下链接：

    ```
    http://localhost:8080/LiveRestaurant/OrderService.wsdl

    ```

3.  要进行测试，请打开一个新的命令窗口并运行以下命令：

```
mvn exec:java exec:java 

```

*   以下是服务器端输出：

```
Sent response ...
<tns:placeOrderResponse xmlns:tns="...">
<tns:refNumber>order-John_Smith_1234</tns:refNumber>
</tns:placeOrderResponse>....
for request ....
<tns:placeOrderRequest xmlns:tns="....">
<tns:order>
<tns:refNumber>9999</tns:refNumber>
<tns:customer>
........
</tns:customer>
<tns:dateSubmitted>2008-09-29T05:49:45</tns:dateSubmitted>
<tns:orderDate>2014-09-19T03:18:33</tns:orderDate>
<!--1 or more repetitions:-->
<tns:items>
<tns:type>Snacks</tns:type>
<tns:name>Pitza</tns:name>
<tns:quantity>2</tns:quantity>
</tns:items>
</tns:order> 

```

## 它是如何工作的。。。

它的工作方式与前面的配方中解释的相同，只是它在方法实现中使用了 `JDOM`。

下面的代码部分使用名称空间和 XPath 对象从传入的 XML 消息`(placeOrderRequest)`中提取值 `refNumber, fName`和 `lName`：

```
Namespace namespace = Namespace.getNamespace("tns", NAMESPACE_URI);
XPath refNumberExpression = XPath.newInstance("//tns:refNumber");
refNumberExpression.addNamespace(namespace);
XPath fNameExpression = XPath.newInstance("//tns:fName");
fNameExpression.addNamespace(namespace);
XPath lNameExpression = XPath.newInstance("//tns:lName");
lNameExpression.addNamespace(namespace);
String refNumber = refNumberExpression.valueOf(placeOrderRequest);
String fName = fNameExpression.valueOf(placeOrderRequest);
String lName = lNameExpression.valueOf(placeOrderRequest);

```

代码的以下部分通过创建 `placeOrderResponse`元素（使用 `new Element(...))`来创建传出消息。然后，它创建子元素 `refNumber`（使用 `new Element(...))`并创建该元素的文本（使用 `setText(...))`。然后，它将消息元素附加到响应元素 `placeOrderResponse`（使用 `addContent`方法）：

```
Namespace resNamespace = Namespace.getNamespace("tns", NAMESPACE_URI);
Element root = new Element("placeOrderResponse", resNamespace);
Element message = new Element("refNumber", resNamespace);
message.setText(orderService.placeOrder(fName, lName, refNumber));
root.addContent(message);
Document doc = new Document(root);
return doc.getRootElement();

```

## 另见

本章将讨论使用 DOM 处理传入 XML 消息的方法*通过注释有效负载根*和*来设置端点。*

*在 HTTP 传输*上创建 Web 服务客户端的方法，在[第 2 章](02.html "Chapter 2. Building Clients for SOAP Web-Services")*为 SOAP Web 服务构建客户端中讨论。*

# 使用 JAXB2 处理传入的 XML 消息

Java Architecture for XML Binding（JAXB）是用于对象 XML 编组的 Java 标准。JAXB 定义了一个程序员 API，用于在 XML 文档中读取和写入 Java 对象。对象 XML 映射通常在类中进行注释。JAXB 提供了一组有用的注释，其中大多数注释的默认值使编组工作变得简单。

这个方法演示了如何使用 JAXB 以非常简单的方式在 Web 服务中处理传入的 XML 消息。为了简单起见并延续之前的方法，重复使用相同的方法，但在将 XML 模式转换为域类以演示 JAXB 的使用方面几乎没有改进。

## 准备好了吗

在此配方中，项目名称为 `LiveRestaurant_R-1.15`，具有以下 Maven 依赖项：

*   `spring-ws-core-2.0.1.RELEASE.jar`
*   `log4j-1.2.9.jar`

## 怎么做。。。

此配方的步骤与配方*通过注释有效负载根*来设置端点的步骤相同，但端点处理方法的实现除外。因此，按照上述方法的步骤，使用 JAXB Marshaller/Un Mashaller 将有效负载转换为 POJO 或从 POJO 转换为 POJO。

1.  首先，我们定义了一组需要从数据契约 `OrderService.xsd`到 XML 封送的域对象（请参阅[第 6 章](06.html "Chapter 6. Marshalling and Object-XML Mapping (OXM)")中讨论的使用 JAXB2 的配方*封送，*
2.  将端点`(OrderEndpoint)`的实现更改为使用 JAXB。
3.  运行以下命令：

    ```
    mvn clean package tomcat:run 

    ```

4.  浏览至以下链接：

    ```
    http://localhost:8080/LiveRestaurant/OrderService.wsdl

    ```

5.  要进行测试，打开一个新的命令窗口到 `Liverestaurant_R-1.15-Client`并运行以下命令：

```
mvn clean package exec:java 

```

*   以下是服务器端输出：

```
Sent response ....
<placeOrderResponse >
<refNumber>order-John_Smith_1234</refNumber>
</placeOrderResponse>....
....
<tns:placeOrderRequest xmlns:tns="...">
<tns:order>
<tns:refNumber>9999</tns:refNumber>
<tns:customer>
........
</tns:customer>
<tns:dateSubmitted>2008-09-29T05:49:45</tns:dateSubmitted>
<tns:orderDate>2014-09-19T03:18:33</tns:orderDate>
<!--1 or more repetitions:-->
<tns:items>
<tns:type>Snacks</tns:type>
<tns:name>Pitza</tns:name>
<tns:quantity>2</tns:quantity>
</tns:items>
</tns:order>
</tns:placeOrderRequest> 

```

## 它是如何工作的。。。

在前面的代码中，XML 在运行时使用 `JAXB`与 Java 类绑定。传入的 XML 被转换为 Java 对象（解组），在处理对象之后，结果对象被编组回 XML，然后返回给调用方：

```
@PayloadRoot(localPart = "placeOrderRequest", namespace = SERVICE_NS)
public @ResponsePayload
Source handlePlaceOrderRequest(@RequestPayload Source source) throws Exception {
PlaceOrderRequest request = (PlaceOrderRequest) unmarshal(source, PlaceOrderRequest.class);
PlaceOrderResponse response = new PlaceOrderResponse();
String refNumber=request.getOrder().getRefNumber();
String fName=request.getOrder().getCustomer().getName().getFName();
String lName=request.getOrder().getCustomer().getName().getLName();
response.setRefNumber(orderService.placeOrder(fName,lName,refNumber));
return marshal(response);
}
private Object unmarshal(Source source, Class clazz) throws JAXBException {
JAXBContext context;
try {
context = JAXBContext.newInstance(clazz);
Unmarshaller um = context.createUnmarshaller();
return um.unmarshal(source);
} catch (JAXBException e) {
e.printStackTrace();
throw e;
}
}
private Source marshal(Object obj) throws JAXBException {
JAXBContext context = JAXBContext.newInstance(obj.getClass());
return new JAXBSource(context, obj);
}

```

`JAXB`上下文在运行时类中的注释的帮助下，将通过构造函数传递的 Java 类与传入的 XML 绑定，这指示解组器实例化 XML 标记中的数据并将其加载到对象中。对象现在被传递到服务类`(OrderServiceImpl)`进行处理：

```
public class OrderServiceImpl implements OrderService {
@Service
public class OrderServiceImpl implements OrderService {
public String placeOrder( String fName,String lName,String refNumber){
return "order-"+fName+"_"+lName+"_"+refNumber;
}
public boolean cancelOrder( String refNumber ){
return true;
}

```

这种方法允许开发人员使用简单的编组技术处理 Java 对象，而不是 XML 代码。

## 另见

配方*通过注释有效负载根*来设置端点，本章将对此进行讨论。

使用 JAXB2 进行*编组的方法，在[第 6 章](06.html "Chapter 6. Marshalling and Object-XML Mapping (OXM)")中讨论，*编组和对象 XMLMapping（OXM）——使用编组器和 UN 编组器将 POJO 转换为 XML 消息或从 XML 消息转换为 POJO。**

# 使用拦截器在服务器端验证 XML 消息

数据契约是用于建立 SpringWS 的基本概念。然而，验证是 SOAP 消息在服务器端/客户端发送/回复之前的基本要求。

SpringWS 支持在服务器端和客户端验证消息。在此配方中，应用服务器端验证，当错误的请求到达服务器或错误的响应从服务器重播到客户端时，它抛出异常。

## 准备好了吗

在此配方中，项目名称为 `LiveRestaurant_R-1.16`，具有以下 Maven 依赖项：

*   `spring-ws-core-2.0.1.RELEASE.jar`
*   `log4j-1.2.9.jar`

## 怎么做。。。

此配方的步骤与*使用 DOM*处理传入 XML 消息的步骤相同，只是验证请求/响应消息。

1.  将 `spring-ws-servlet.xml`修改为包含 `PayloadValidatingInterceptor`。
2.  运行以下命令：

    ```
    mvn clean package tomcat:run 

    ```

3.  浏览至以下链接：

    ```
    http://localhost:8080/LiveRestaurant/OrderService.wsdl

    ```

4.  要进行测试，打开一个新的命令窗口到 `Liverestaurant_R-1.16-Client`并运行以下命令：

```
mvn clean package exec:java 

```

*   以下是服务器端输出：

```
Sent response [...
<placeOrderResponse >
<refNumber>order-John_Smith_1234</refNumber>
</placeOrderResponse>...
for request ...
<tns:placeOrderRequest xmlns:tns="...">
<tns:order>
<tns:refNumber>9999</tns:refNumber>
<tns:customer>
<tns:addressPrimary>
.....
</tns:addressPrimary>
.......
</tns:customer>
........
</tns:order>
</tns:placeOrderRequest>
WARN [http-8080-1] (AbstractFaultCreatingValidatingInterceptor.java:156) - XML validation error on request: cvc-complex-type.2.4.a: Invalid content was found s
tarting with element 'tns:address'. One of '{"http://www.packtpub.com/liverestaurant/OrderService/schema":addressPrimary}' is expected.
........ Sent response....
<faultcode>SOAP-ENV:Client</faultcode><faultstring xml:lang="en">Validation error</faultstring><detail><spring-ws:ValidationErr
or xmlns:spring-ws="http://springframework.org/spring-ws">cvc-complex-type.2.4.a: Invalid content was found starting with element 'tns:address'. One of '{"http:
//www.packtpub.com/liverestaurant/OrderService/schema":addressPrimary}' is expected.</spring-ws:ValidationError></detail></SOAP-ENV:Fault></SOAP-ENV:Body></SOAP
-ENV:Envelope>] 

```

## 它是如何工作的。。。

`spring-ws-servlet.xml`与使用 DOM 处理传入 XML 消息的配方*中描述的几乎相同，只是它包括使用模式进行验证的拦截器 `validateRequest`和 `validateResponse`。*

```
<sws:interceptors>
<bean class="org.springframework.ws.soap.server.endpoint.interceptor.PayloadValidatingInterceptor">
<property name="schema" value="/WEB-INF/OrderService.xsd"/>
<property name="validateRequest" value="true"/>
<property name="validateResponse" value="true"/>
</bean>
<bean class="org.springframework.ws.server.endpoint.interceptor.PayloadLoggingInterceptor">
</bean>
</sws:interceptors>

```

运行客户端时，将向服务器发送两个请求。第一个将被处理并将响应发送回客户端，而第二个包含错误的元素（地址而不是将错误响应发送回的 `addressPrimary)`：

```
Sent response....
<faultcode>SOAP-ENV:Client</faultcode><faultstring xml:lang="en">Validation error</faultstring><detail><spring-ws:ValidationErr
or xmlns:spring-ws="http://springframework.org/spring-ws">cvc-complex-type.2.4.a: Invalid content was found starting with element 'tns:address'. One of '{"http: //www.packtpub.com/liverestaurant/OrderService/schema":addressPrimary}' is expected.</spring-ws:ValidationError></detail></SOAP-ENV:Fault></SOAP-ENV:Body></SOAP
-ENV:Envelope>]
.... 

```

## 另见

配方*通过注释有效负载根*来设置端点，本章将对此进行讨论。

*在 HTTP 传输*上创建 Web 服务客户端的方法，在[第 2 章](02.html "Chapter 2. Building Clients for SOAP Web-Services")*为 SOAP Web 服务构建客户端中讨论。*